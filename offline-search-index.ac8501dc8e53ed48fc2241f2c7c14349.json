


















































































































































































[{"body":"本页为您介绍 KLTS 的 Kubernetes 版本支持机制。\n如图所示，V1.16.15 是 Kubernetes 的完整发行版本号，其中 1.16 是大版本号，15 是社区补丁版本，而 lts.0 是 KLTS 的补丁版本号。\n上图以 2021 年 8 月 31 日为例，当时的最新版本为 1.22，Kubernetes 社区仅维护 1.19 – 1.22 四个版本。而 KLTS 则提供从 1.10 到 1.18 的版本维护，每个版本的支持周期至少两年。其中 Kubernetes 1.10 是 DaoCloud Enterprise 3.0 的生产内核，其维护周期会相对更长。我们会将修复 bug 后的稳定版本上传至 KLTS，供社区下载使用。\nKubernetes 社区一般每隔 4 个月左右发布一个大版本，KLTS 维护的 Kubernetes 版本也会随之变化。通常在 Kubernetes 社区停止维护某个版本后的一个月内，KLTS 将开始维护刚被社区停止维护的版本。\n例如，如果社区正式发布 1.23 版本，KLTS 维护的版本也会加一，达到 1.19，以此类推。KLTS 的补丁更新频率将根据实际解决的 bug 情况发布。\n","categories":"","description":"","excerpt":"本页为您介绍 KLTS 的 Kubernetes 版本支持机制。\n如图所示，V1.16.15 是 Kubernetes 的完整发行版本号，其 …","ref":"/zh/docs/intro/","tags":"","title":"简介"},{"body":"This page shows how to install the kubeadm toolbox. For information on how to create a cluster with kubeadm once you have performed this installation process, see the Install page.\nBefore you begin  A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine). Unique hostname, MAC address, and product_uuid for every node. See here for more details. Certain ports are open on your machines. See here for more details. Swap disabled. You MUST disable swap in order for the kubelet to work properly.  Verify the MAC address and product_uuid are unique for every node  You can get the MAC address of the network interfaces using the command ip link or ifconfig -a The product_uuid can be checked by using the command sudo cat /sys/class/dmi/id/product_uuid  It is very likely that hardware devices will have unique addresses, although some virtual machines may have identical values. Kubernetes uses these values to uniquely identify the nodes in the cluster. If these values are not unique to each node, the installation process may fail.\nCheck network adapters If you have more than one network adapter, and your Kubernetes components are not reachable on the default route, we recommend you add IP route(s) so Kubernetes cluster addresses go via the appropriate adapter.\nLetting iptables see bridged traffic Make sure that the br_netfilter module is loaded. This can be done by running lsmod | grep br_netfilter. To load it explicitly call sudo modprobe br_netfilter.\nAs a requirement for your Linux Node’s iptables to correctly see bridged traffic, you should ensure net.bridge.bridge-nf-call-iptables is set to 1 in your sysctl config, e.g.\ncat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system For more details please see the Network Plugin Requirements page.\nCheck required ports Control-plane node(s)    Protocol Direction Port Range Purpose Used By     TCP Inbound 6443* Kubernetes API server All   TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd   TCP Inbound 10250 kubelet API Self, Control plane   TCP Inbound 10251 kube-scheduler Self   TCP Inbound 10252 kube-controller-manager Self    Worker node(s)    Protocol Direction Port Range Purpose Used By     TCP Inbound 10250 kubelet API Self, Control plane   TCP Inbound 30000-32767 NodePort Services† All    † Default port range for NodePort Services.\nAny port numbers marked with * are overridable, so you will need to ensure any custom ports you provide are also open.\nAlthough etcd ports are included in control-plane nodes, you can also host your own etcd cluster externally or on custom ports.\nThe pod network plugin you use (see below) may also require certain ports to be open. Since this differs with each pod network plugin, please see the documentation for the plugins about what port(s) those need.\nSetting node name hostnamectl set-hostname your-new-host-name echo \"127.0.0.1 $(hostname)\" \u003e\u003e /etc/hosts echo \"::1 $(hostname)\" \u003e\u003e /etc/hosts Disable Swap swapoff -a If you want to disable swap permanently, edit the /etc/fstab file to comment out the swap mount\nDisable Selinux setenforce 0 If you want to disable selinux permanently, edit /etc/sysconfig/selinux and replace SELINUX=enforcing with SELINUX=disabled\nInstall Runtime To run containers in Pods, Kubernetes uses a Container Runtime Interface (Container Runtime)\nLinux Node 其它操作系统 By default, Kubernetes uses the Container Runtime Interface (CRI) to interface with your chosen container runtime.\nIf you don’t specify a runtime, kubeadm automatically tries to detect an installed container runtime by scanning through a list of well known Unix domain sockets. The following table lists container runtimes and their associated socket paths:\n   Runtime Path to Unix domain socket     Docker /var/run/dockershim.sock   Containerd /run/containerd/containerd.sock   CRI-O /var/run/crio/crio.sock     If both Docker and containerd are detected, Docker takes precedence. This is needed because Docker 18.09 ships with containerd and both are detectable even if you only installed Docker. If any other two or more runtimes are detected, kubeadm exits with an error. The kubelet integrates with Docker through the built-in dockershim CRI implementation.\n By default, kubeadm uses Docker as the container runtime. The kubelet integrates with Docker through the built-in dockershim CRI implementation.\n Docker Containerd  Red Hat-based distributions Debian-based distributions yum install docker  apt-get install docker.io   VERSION=1.5.4 wget -c https://github.com/containerd/containerd/releases/download/v${VERSION}/containerd-${VERSION}-linux-amd64.tar.gz tar xvf containerd-${VERSION}-linux-amd64.tar.gz -C /usr/local/ mkdir /etc/containerd/ \u0026\u0026 containerd config default \u003e /etc/containerd/config.toml wget -c -O /etc/systemd/system/containerd.service https://raw.githubusercontent.com/containerd/containerd/main/containerd.service systemctl start containerd \u0026\u0026 systemctl enable containerd  See container runtimes for more information.\n","categories":"","description":"","excerpt":"This page shows how to install the kubeadm toolbox. For information on …","ref":"/docs/pre-install/","tags":"","title":"Pre Install"},{"body":"本页介绍如何安装 kubeadm 工具箱。 有关在执行此安装过程后如何使用 kubeadm 创建集群的信息，请参见安装步骤。\n准备工作  准备一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令。 每台主机至少 2 GB 或更多的内存（如果内存太少将影响应用的运行） CPU 2 核或更多 集群中所有主机的网络连通（公网和内网） 单个节点上不能有重复的主机名、MAC 地址或 product_uuid，请参阅确保每个节点上 MAC 地址和 product_uuid 的唯一性。 开启主机上的某些端口，请参阅检查所需端口。 禁用交换分区。为了保证 kubelet 正常工作，您必须禁用交换分区。  确保每个节点上 MAC 地址和 product_uuid 的唯一性   使用命令 ip link 或 ifconfig -a 来获取网络接口的 MAC 地址 使用 sudo cat /sys/class/dmi/id/product_uuid 命令来校验 product_uuid  一般来讲，硬件设备拥有唯一的地址，但是有些虚拟机的地址可能会重复。 Kubernetes 使用 MAC 地址和 product_uuid 来确定集群中的唯一节点。 如果这些值在每个节点上不唯一，可能会导致安装失败。\n检查网络适配器 如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。\n允许 iptables 检查桥接流量 确保 br_netfilter 模块被加载。这一操作可以通过运行 lsmod | grep br_netfilter 来完成。若要显式加载该模块，可执行命令 sudo modprobe br_netfilter。\n为了让您的 Linux 节点上的 iptables 能够正确地查看桥接流量，您需要确保在 sysctl 配置中将 net.bridge.bridge-nf-call-iptables 设置为 1。例如：\ncat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 更多细节请查阅网络插件需求页面。\n检查所需端口 控制平面节点    协议 方向 端口范围 作用 使用者     TCP 入站 6443 Kubernetes API 服务器 所有组件   TCP 入站 2379-2380 etcd 服务器客户端 API kube-apiserver、etcd   TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件   TCP 入站 10251 kube-scheduler kube-scheduler 自身   TCP 入站 10252 kube-controller-manager kube-controller-manager 自身    工作节点    协议 方向 端口范围 作用 使用者     TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件   TCP 入站 30000-32767 NodePort 服务 所有组件    以上是 NodePort 服务的默认端口范围。\n使用 * 标记的任意端口号都可以被覆盖，所以您需要保证定制的端口是开放的。\n虽然控制平面节点已经包含了 etcd 的端口，您也可以使用自定义的外部 etcd 集群，或指定自定义端口。\n您使用的 Pod 网络插件 (见下) 也可能需要某些特定端口开启。由于各个 Pod 网络插件都有所不同，请参阅相应文档中的端口要求。\n设置节点名字 命令的语法格式如下：\nhostnamectl set-hostname your-new-host-name echo \"127.0.0.1 $(hostname)\" \u003e\u003e /etc/hosts echo \"::1 $(hostname)\" \u003e\u003e /etc/hosts 关闭 Swap 执行以下命令关闭 Swap：\nswapoff -a 如果需要永久关闭，请编辑 /etc/fstab 文件，将 swap 的挂载路径改为注释。\n关闭 Selinux 执行以下命令关闭 Selinux：\nsetenforce 0 如果需要永久关闭，请编辑 /etc/sysconfig/selinux 将 SELINUX=enforcing 替换为 SELINUX=disabled。\n安装 runtime 为了在 Pod 中运行容器，Kubernetes 使用容器运行时（Container Runtime）。\nLinux 节点 其它操作系统 默认情况下，Kubernetes 使用容器运行时接口（Container Runtime Interface，CRI）来与您所选择的容器运行时交互。\n如果您不指定运行时，则 kubeadm 会自动尝试检测系统上已经安装的运行时，方法是扫描一组众所周知的 Unix 域套接字。\n下面的表格列举了一些容器运行时及其对应的套接字路径：\n   运行时 域套接字     Docker /var/run/dockershim.sock   Containerd /run/containerd/containerd.sock   CRI-O /var/run/crio/crio.sock     如果同时检测到 Docker 和 Containerd，则优先选择 Docker。 这是必然的，即使您仅安装了 Docker，因为 Docker 18.09 附带了 Containerd，所以两者都是可以检测到的。 如果检测到其他两个或多个运行时，则 kubeadm 输出错误信息并退出。 kubelet 通过内置的 dockershim CRI 实现与 Docker 集成。\n 默认情况下， kubeadm 使用 docker 作为容器运行时。kubelet 通过内置的 dockershim CRI 实现与 Docker 集成。\n Docker Containerd  基于 Red Hat 的发行版 基于 Debian 的发行版 执行以下命令安装基于 Red Hat 发行版的 Docker：\nyum install docker  执行以下命令安装基于 Debian 发行版的 Docker：\napt-get install docker.io   Containerd 官方默认只提供 amd64 架构的下载包，如果您采用的是其他基础架构， 可以从 Docker 官方仓库安装 containerd.io 软件包。在安装 Docker 引擎中 找到为各自的 Linux 发行版设置 Docker 存储库和安装 containerd.io 软件包的有关说明。\n也可以使用以下源代码构建。\nVERSION=1.5.4 wget -c https://github.com/containerd/containerd/releases/download/v${VERSION}/containerd-${VERSION}-linux-amd64.tar.gz tar xvf containerd-${VERSION}-linux-amd64.tar.gz -C /usr/local/ mkdir /etc/containerd/ \u0026\u0026 containerd config default \u003e /etc/containerd/config.toml wget -c -O /etc/systemd/system/containerd.service https://raw.githubusercontent.com/containerd/containerd/main/containerd.service systemctl start containerd \u0026\u0026 systemctl enable containerd  参阅容器运行时以了解更多信息。\n","categories":"","description":"","excerpt":"本页介绍如何安装 kubeadm 工具箱。 有关在执行此安装过程后如何使用 kubeadm 创建集群的信息，请参见安装步骤。\n准备工作  准 …","ref":"/zh/docs/pre-install/","tags":"","title":"安装准备"},{"body":"Clone single branch Since the repos branch is used as a software source for RPM and DEB, direct cloning is very large So try cloning only the single branch\ngit clone --single-branch -b master https://github.com/klts-io/kubernetes-lts ","categories":"","description":"","excerpt":"Clone single branch Since the repos branch is used as a software …","ref":"/docs/developer-guide/clone/","tags":"","title":"Clone"},{"body":"Install yq MacOS Red Hat-based distributions Debian-based distributions brew install jq python@3 # Install brew, See https://brew.sh/ pip3 install yq  yum install -y epel-release yum install -y jq python3 pip3 install yq  apt-get install -y jq python3 python3-pip pip3 install yq  ","categories":"","description":"","excerpt":"Install yq MacOS Red Hat-based distributions Debian-based …","ref":"/docs/developer-guide/dependent/","tags":"","title":"Dependent"},{"body":"KLTS provides a way to install software sources based on Deb and RPM. You can choose the installation method that suits your system\nBefore installation, ensure that Pre Install has been installed\nSet the KLTS software source Red Hat-based distributions Debian-based distributions cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://dl.klts.io/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://dl.klts.io/deb stable main EOF apt-get update  Install Install Install the specified releases  Red Hat-based distributions Debian-based distributions yum install kubeadm kubelet kubectl  apt-get install kubeadm kubelet kubectl    Red Hat-based distributions Debian-based distributions # Search for supported releases yum search kubeadm --showduplicates | grep kubeadm- # Install VERSION=1.18.20-lts.0 yum install kubeadm-v${VERSION} kubelet-v${VERSION} kubectl-v${VERSION}  # Search for supported releases apt-cache show kubeadm | grep Version # Install VERSION=1.18.20-lts.0 apt-get install kubeadm=${VERSION} kubelet=${VERSION} kubectl=${VERSION}   Auto-start Kubelet on boot systemctl enable kubelet Pull the dependency image VERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm config images pull --image-repository ${REPOS} --kubernetes-version v${VERSION} All subsequent operations on Kubeadm need to include --image-repository, --kubernetes-version actively specifying the image\nInitialize the control plane node VERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm init --image-repository ${REPOS} --kubernetes-version v${VERSION} More Reference ","categories":"","description":"","excerpt":"KLTS provides a way to install software sources based on Deb and RPM. …","ref":"/docs/install/","tags":"","title":"Install"},{"body":"安装 yq MacOS 基于 Red Hat 的发行版 基于 Debian 的发行版 brew install jq python@3 # 安装 brew, 请看 https://brew.sh/ pip3 install yq  yum install -y epel-release yum install -y jq python3 pip3 install yq  apt-get install -y jq python3 python3-pip pip3 install yq  ","categories":"","description":"","excerpt":"安装 yq MacOS 基于 Red Hat 的发行版 基于 Debian 的发行版 brew install jq python@3 #  …","ref":"/zh/docs/developer-guide/dependent/","tags":"","title":"依赖"},{"body":"克隆主分支 请尝试只克隆主分支, 由于 repos 仓库是作为 rpm 和 deb 的软件源的, 直接克隆全部的话会非常大\ngit clone --single-branch -b master https://github.com/klts-io/kubernetes-lts ","categories":"","description":"","excerpt":"克隆主分支 请尝试只克隆主分支, 由于 repos 仓库是作为 rpm 和 deb 的软件源的, 直接克隆全部的话会非常大\ngit …","ref":"/zh/docs/developer-guide/clone/","tags":"","title":"克隆"},{"body":"KLTS 提供了基于 deb 和 rpm 软件源的安装方式，您可以选择适合的安装方式。\n安装前请确认已经完成了安装准备的安装。\n设置 KLTS 软件源 基于 Red Hat 的发行版 基于 Debian 的发行版 基于 Red Hat 的发行版, 国内加速 🚀 基于 Debian 的发行版, 国内加速 🚀 执行以下代码设置下载 KLTS 的软件源：\ncat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://dl.klts.io/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  执行以下代码设置下载 KLTS 的软件源：\ncat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://dl.klts.io/deb stable main EOF apt-get update   说明：以下加速均来自第三方, 安全和稳定性不做保障, 仅建议测试环境使用 ❗️❗️❗️ 执行以下代码设置下载 KLTS 的软件源： /etc/hosts hub.fastgit.org ghproxy.com raw.githubusercontents.com raw.staticdn.net curl https://raw.githubusercontent.com/wzshiming/github-hosts/master/hosts \u003e\u003e/etc/hosts cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://dl.klts.io/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://hub.fastgit.org/klts-io/kubernetes-lts/raw/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://ghproxy.com/https://raw.githubusercontent.com/klts-io/kubernetes-lts/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://raw.githubusercontents.com/klts-io/kubernetes-lts/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://raw.staticdn.net/klts-io/kubernetes-lts/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache    说明：以下加速均来自第三方, 安全和稳定性不做保障, 仅建议测试环境使用 ❗️❗️❗️\n执行以下代码设置下载 KLTS 的软件源： /etc/hosts hub.fastgit.org ghproxy.com raw.githubusercontents.com raw.staticdn.net curl https://raw.githubusercontent.com/wzshiming/github-hosts/master/hosts \u003e\u003e/etc/hosts cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://dl.klts.io/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://hub.fastgit.org/klts-io/kubernetes-lts/raw/repos/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://ghproxy.com/https://raw.githubusercontent.com/klts-io/kubernetes-lts/repos/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://raw.githubusercontents.com/klts-io/kubernetes-lts/repos/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://raw.staticdn.net/klts-io/kubernetes-lts/repos/deb stable main EOF apt-get update   安装 安装最高版本 安装指定版本  这里的最高版本指的是 KLTS 维护的最高版本。 基于 Red Hat 的发行版 基于 Debian 的发行版 执行以下命令开始安装：\nyum install kubeadm kubelet kubectl  执行以下命令开始安装：\napt-get install kubeadm kubelet kubectl    基于 Red Hat 的发行版 基于 Debian 的发行版 执行以下命令进行安装：\n# 搜索支持的版本 yum search kubeadm --showduplicates | grep kubeadm- # 安装 VERSION=1.18.20-lts.0 yum install kubeadm-v${VERSION} kubelet-v${VERSION} kubectl-v${VERSION}  执行以下命令进行安装：\n# 搜索支持的版本 apt-cache show kubeadm | grep Version # 安装 VERSION=1.18.20-lts.0 apt-get install kubeadm=${VERSION} kubelet=${VERSION} kubectl=${VERSION}   开机自动启动 Kubelet 执行以下命令开机自动启动 Kubelet：\nsystemctl enable kubelet 拉取依赖镜像 执行以下命令 pull 依赖的镜像：\nVERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm config images pull --image-repository ${REPOS} --kubernetes-version v${VERSION} 后续对 kubeadm 的操作都需要加上 --image-repository，--kubernetes-version 主动指定镜像。\n初始化控制面节点 执行以下命令初始化控制面的节点：\nVERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm init --image-repository ${REPOS} --kubernetes-version v${VERSION} 有关更多安装说明，请参阅Kubernetes 操作指南。\n","categories":"","description":"","excerpt":"KLTS 提供了基于 deb 和 rpm 软件源的安装方式，您可以选择适合的安装方式。\n安装前请确认已经完成了安装准备的安装。 …","ref":"/zh/docs/install/","tags":"","title":"安装步骤"},{"body":"TODO\n","categories":"","description":"","excerpt":"TODO\n","ref":"/docs/post-install/","tags":"","title":"Post Install"},{"body":"TODO\n","categories":"","description":"","excerpt":"TODO\n","ref":"/zh/docs/post-install/","tags":"","title":"安装之后"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/patches/","tags":"","title":"补丁"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/","tags":"","title":"版本日志"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/developer-guide/","tags":"","title":"开发指南"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/glossary/","tags":"","title":"术语"},{"body":"Node-pressure eviction is the process by which the kubelet proactively fails pods to reclaim resources on nodes. tags: - operation --- -- Kubelet proactively terminates pods to reclaim resources on nodes. -- 节点压力驱逐是 Kubelet 主动终止 Pod 以回收节点上资源的过程。\nkubelet 监控集群节点上的 CPU、内存、磁盘空间和文件系统 inode 等资源。 当这些资源中的一个或多个达到特定消耗水平时， kubelet 可以主动使节点上的一个或多个 Pod 失效，以回收资源并防止饥饿。\n节点压力驱逐不用于 API 发起的驱逐。\n","categories":"","description":"","excerpt":"Node-pressure eviction is the process by which the kubelet proactively …","ref":"/zh/docs/glossary/node-pressure-eviction/","tags":["operation"],"title":"节点压力驱逐"},{"body":"API-initiated eviction is the process by which you use the Eviction API to create an Eviction object that triggers graceful pod termination. tags: - operation --- -- API 发起的驱逐是一个先调用 Eviction API 创建驱逐对象，再由该对象体面地中止 Pod 的过程。\n你可以通过 kube-apiserver 的客户端，比如 kubectl drain 这样的命令，直接调用 Eviction API 发起驱逐。 当 Eviction 对象创建出来之后，该对象将驱动 API 服务器终止选定的Pod。\nAPI 发起的驱逐不同于 节点压力引发的驱逐。\n","categories":"","description":"","excerpt":"API-initiated eviction is the process by which you use the Eviction …","ref":"/zh/docs/glossary/api-eviction/","tags":["operation"],"title":"API 发起的驱逐"},{"body":"A entity in the Kubernetes system, representing part of the state of your cluster. tags: - fundamental --- -- Kubernetes 系统中的实体。Kubernetes API 用这些实体表示集群的状态。\n控制平面（Control Plane） works constantly to ensure that the item it represents actually exists. By creating an object, you're effectively telling the Kubernetes system what you want that part of your cluster's workload to look like; this is your cluster's desired state. -- Kubernetes 对象通常是一个“目标记录”-一旦你创建了一个对象，Kubernetes 控制平面（Control Plane） 不断工作，以确保它代表的项目确实存在。 创建一个对象相当于告知 Kubernetes 系统：你期望这部分集群负载看起来像什么；这也就是你集群的期望状态。\n","categories":"","description":"","excerpt":"A entity in the Kubernetes system, representing part of the state of …","ref":"/zh/docs/glossary/object/","tags":["fundamental"],"title":"对象（Object）"},{"body":"端点负责记录与服务的选择算符（Selector）相匹配的 Pods 的 IP 地址。\nEndpoints track the IP addresses of Pods with matching Service selectors. tags: - networking Endpoints track the IP addresses of Pods with matching 选择算符（Selector）. -- 服务（Service） without selectors specified. -- 端点可以手动配置到服务（Service）上，而不必指定选择器标识。\nEndpointSlice resource provides a scalable and extensible alternative to Endpoints. -- EndpointSlice提供了一种可伸缩、可扩展的替代方案。\n","categories":"","description":"","excerpt":"端点负责记录与服务的选择算符（Selector）相匹配的 Pods 的 IP 地址。\nEndpoints track the IP …","ref":"/zh/docs/glossary/endpoint/","tags":["networking"],"title":"端点（Endpoints）"},{"body":"遗留术语，作为运行 控制平面（Control Plane） 的 节点（Node） 的同义词使用。\nLegacy term, used as synonym for nodes running the control plane. tags: - fundamental --- Legacy term, used as synonym for 节点（Node） hosting the 控制平面（Control Plane）. -- Kubeadm, and managed services, to 标签（Label） 节点（Node） with `kubernetes.io/role` and control placement of 控制平面（Control Plane） Pod. -- 该术语仍被一些配置工具使用，如 Kubeadm 以及托管的服务，为 节点（Node） 添加 kubernetes.io/role 的 标签（Label），以及管理控制平面 Pod 的调度。\n","categories":"","description":"","excerpt":"遗留术语，作为运行 控制平面（Control Plane） 的 节点（Node） 的同义词使用。\nLegacy term, used as …","ref":"/zh/docs/glossary/master/","tags":["fundamental"],"title":"Master"},{"body":"A technique for assigning requests to queues that provides better isolation than hashing modulo the number of queues. tags: - fundamental --- -- 混排切片（Shuffle Sharding）是指一种将请求指派给队列的技术，其隔离性好过对队列个数哈希取模的方式。\n我们通常会关心不同的请求序列间的相互隔离问题，目的是为了确保密度较高的 请求序列不会湮没密度较低的序列。 将请求放入不同队列的一种简单方法是对请求的某些特征值执行哈希函数， 将结果对队列的个数取模，从而得到要使用的队列的索引。 这一哈希函数使用请求的与其序列相对应的特征作为其输入。例如，在因特网上， 这一特征通常指的是由源地址、目标地址、协议、源端口和目标端口所组成的 五元组。\n这种简单的基于哈希的模式有一种特性，高密度的请求序列（流）会湮没那些被 哈希到同一队列的其他低密度请求序列（流）。 为大量的序列提供较好的隔离性需要提供大量的队列，因此是有问题的。 混排切片是一种更为灵活的机制，能够更好地将低密度序列与高密度序列隔离。 混排切片的术语采用了对一叠扑克牌进行洗牌的类比，每个队列可类比成一张牌。 混排切片技术首先对请求的特定于所在序列的特征执行哈希计算，生成一个长度 为十几个二进制位或更长的哈希值。 接下来，用该哈希值作为信息熵的来源，对一叠牌来混排，并对整个一手牌（队列）来洗牌。 最后，对所有处理过的队列进行检查，选择长度最短的已检查队列作为请求的目标队列。 在队列数量适中的时候，检查所有已处理的牌的计算量并不大，对于任一给定的 低密度的请求序列而言，有相当的概率能够消除给定高密度序列的湮没效应。 当队列数量较大时，检查所有已处理队列的操作会比较耗时，低密度请求序列 消除一组高密度请求序列的湮没效应的机会也随之降低。因此，选择队列数目 时要颇为谨慎。\n","categories":"","description":"","excerpt":"A technique for assigning requests to queues that provides better …","ref":"/zh/docs/glossary/shuffle-sharding/","tags":["fundamental"],"title":"混排切片（Shuffle Sharding）"},{"body":"Resources that extend the functionality of Kubernetes. tags: - tool --- -- 扩展 Kubernetes 功能的资源。\n安装附加组件 阐释了更多关于如何在集群内使用附加组件，并列出了一些流行的附加组件。\n","categories":"","description":"","excerpt":"Resources that extend the functionality of Kubernetes. tags: - tool …","ref":"/zh/docs/glossary/addons/","tags":["tool"],"title":"附加组件（Add-ons）"},{"body":"CIDR is a notation for describing blocks of IP addresses and is used heavily in various networking configurations. tags: - networking --- -- CIDR (无类域间路由) 是一种描述 IP 地址块的符号，被广泛使用于各种网络配置中。\n节点（Node） is assigned a range of IP addresses through the start address and a subnet mask using CIDR. This allows Nodes to assign each Pod a unique IP address. Although originally a concept for IPv4, CIDR has also been expanded to include IPv6. -- 在 Kubernetes 的上下文中，每个节点（Node） 以 CIDR 形式（含起始地址和子网掩码）获得一个 IP 地址段， 从而能够为每个 Pod 分配一个独一无二的 IP 地址。 虽然其概念最初源自 IPv4，CIDR 已经被扩展为涵盖 IPv6。\n","categories":"","description":"","excerpt":"CIDR is a notation for describing blocks of IP addresses and is used …","ref":"/zh/docs/glossary/cidr/","tags":["networking"],"title":"CIDR"},{"body":"An application acting as an intermediary beween clients and servers tags: - networking --- -- 在计算机领域，代理指的是充当远程服务中介的服务器。\n客户端与代理进行交互；代理将客户端的数据复制到实际服务器；实际服务器回复代理；代理将实际服务器的回复发送给客户端。\n服务（Service） concept. -- kube-proxy 是集群中每个节点上运行的网络代理，实现了部分 Kubernetes 服务（Service） 概念。\n你可以将 kube-proxy 作为普通的用户态代理服务运行。 如果你的操作系统支持，则可以在混合模式下运行 kube-proxy；该模式使用较少的系统资源即可达到相同的总体效果。\n","categories":"","description":"","excerpt":"An application acting as an intermediary beween clients and servers …","ref":"/zh/docs/glossary/proxy/","tags":["networking"],"title":"代理（Proxy）"},{"body":"干扰是指导致一个或者多个 Pod 服务停止的事件。 干扰会影响工作负载资源，比如 Deployment 这种依赖于受影响 Pod 的资源。\nAn event that leads to Pod(s) going out of service tags: - fundamental --- Disruptions are events that lead to one or more Pod going out of service. A disruption has consequences for workload resources, such as Deployment, that rely on the affected Pods. -- 如果您作为一个集群操作人员，销毁了一个从属于某个应用的 Pod, Kubernetes 视之为 自愿干扰（Voluntary Disruption）。如果由于节点故障 或者影响更大区域故障的断电导致 Pod 离线，kubernetes 视之为 非愿干扰（Involuntary Disruption）。\n更多信息请查阅Disruptions\n","categories":"","description":"","excerpt":"干扰是指导致一个或者多个 Pod 服务停止的事件。 干扰会影响工作负载资源，比如 Deployment 这种依赖于受影响 Pod 的资源。 …","ref":"/zh/docs/glossary/disruption/","tags":["fundamental"],"title":"干扰（Disruption）"},{"body":"A set of related paths in the Kubernetes API. tags: - fundamental - architecture ---\t-- Kubernetes API 中的一组相关路径。\n通过更改 API server 的配置，可以启用或禁用每个 API Group。 你还可以禁用或启用指向特定资源的路径。 API group 使扩展 Kubernetes API 更加的容易。 API group 在 REST 路径和序列化对象的 apiVersion 字段中指定。\n 阅读 API Group 了解更多信息。 ","categories":"","description":"","excerpt":"A set of related paths in the Kubernetes API. tags: - fundamental - …","ref":"/zh/docs/glossary/api-group/","tags":["fundamental","architecture"],"title":"API Group"},{"body":"您可以在 Pod 中临时运行的一种 容器（Container） 类型。\nA type of container type that you can temporarily run inside a Pod tags: - fundamental --- A 容器（Container） type that you can temporarily run inside a Pod. -- 如果想要调查运行中有问题的 Pod，可以向该 Pod 添加一个临时容器并进行诊断。 临时容器没有资源或调度保证，因此不应该使用它们来运行任何部分的工作负荷本身。\n","categories":"","description":"","excerpt":"您可以在 Pod 中临时运行的一种 容器（Container） 类型。\nA type of container type that you …","ref":"/zh/docs/glossary/ephemeral-container/","tags":["fundamental"],"title":"临时容器（Ephemeral Container）"},{"body":"An object in the API server that tracks a static pod on a kubelet. tags: - fundamental --- -- Pod object that a kubelet uses to represent a 静态 Pod（Static Pod） -- 镜像 Pod（Mirror Pod）是被 kubelet 用来代表静态 Pod（Static Pod） 的 Pod 对象。\n 当 kubelet 在其配置中发现一个静态容器时， 它会自动地尝试在 Kubernetes API 服务器上为它创建 Pod 对象。 这意味着 pod 在 API 服务器上将是可见的，但不能在其上进行控制。\n（例如，删除镜像 Pod 也不会阻止 kubelet 守护进程继续运行它）。\n","categories":"","description":"","excerpt":"An object in the API server that tracks a static pod on a kubelet. …","ref":"/zh/docs/glossary/mirror-pod/","tags":["基本的"],"title":"镜像 Pod（Mirror Pod）"},{"body":"A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object. tags: - extension - security ---\t-- 在对象持久化之前拦截 Kubernetes Api 服务器请求的一段代码\n准入控制器可针对 Kubernetes Api 服务器进行配置，可以执行验证，变更或两者都执行。任何准入控制器都可以拒绝访问请求。 变更（mutating）控制器可以修改其允许的对象，验证（validating）控制器则不可以。\n Kubernetes 文档中的准入控制器 ","categories":"","description":"","excerpt":"A piece of code that intercepts requests to the Kubernetes API server …","ref":"/zh/docs/glossary/admission-controller/","tags":["extension","security"],"title":"准入控制器（Admission Controller）"},{"body":"JSON 或 YAML 格式的 Kubernetes API 对象规范。\nA serialized specification of one or more Kubernetes API objects. tags: - fundamental Specification of a Kubernetes API object in JSON or YAML format. -- 清单指定了在应用该清单时 kubernetes 将维护的对象的期望状态。每个配置文件可包含多个清单。\n","categories":"","description":"","excerpt":"JSON 或 YAML 格式的 Kubernetes API 对象规范。\nA serialized specification of one …","ref":"/zh/docs/glossary/manifest/","tags":["fundamental"],"title":"清单（Manifest）"},{"body":"A group of Linux processes with optional resource isolation, accounting and limits. tags: - fundamental --- -- 一组具有可选资源隔离、审计和限制的 Linux 进程。\nCgroup 是一个 Linux 内核特性，对一组进程的资源使用（CPU、内存、磁盘 I/O 和网络等）进行限制、审计和隔离。\n","categories":"","description":"","excerpt":"A group of Linux processes with optional resource isolation, …","ref":"/zh/docs/glossary/cgroup/","tags":["fundamental"],"title":"控制组（cgroup）"},{"body":"A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node. tags: - fundamental - operation --- -- 节点（Node）, that run containerized applications. Every cluster has at least one worker node. -- 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。\nPod that are the components of the application workload. The 控制平面（Control Plane） manages the worker nodes and the Pods in the cluster. In production environments, the control plane usually runs across multiple computers and a cluster usually runs multiple nodes, providing fault-tolerance and high availability. -- 工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。\n","categories":"","description":"","excerpt":"A set of worker machines, called nodes, that run containerized …","ref":"/zh/docs/glossary/cluster/","tags":["fundamental","operation"],"title":"集群（Cluster）"},{"body":"The container runtime is the software that is responsible for running containers. tags: - fundamental - workload --- -- 容器运行环境是负责运行容器的软件。\nDocker, containerd, CRI-O, and any implementation of the [Kubernetes CRI (Container Runtime Interface)](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md). -- Kubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 Kubernetes CRI (容器运行环境接口)。\n","categories":"","description":"","excerpt":"The container runtime is the software that is responsible for running …","ref":"/zh/docs/glossary/container-runtime/","tags":["fundamental","workload"],"title":"容器运行时（Container Runtime）"},{"body":"云原生计算基金会（CNCF）建立了可持续的生态系统，并在围绕着 项目 建立一个社区，将容器编排微服务架构的一部分。\nKubernetes 是一个云原生计算基金会项目.\nCloud Native Computing Foundation tags: - community --- The Cloud Native Computing Foundation (CNCF) builds sustainable ecosystems and fosters a community around [projects](https://www.cncf.io/projects/) that orchestrate containers as part of a microservices architecture. Kubernetes is a CNCF project. -- 云原生计算基金会（CNCF）是 Linux 基金会 的下属基金会。它的使命是让云原生计算无处不在。\n","categories":"","description":"","excerpt":"云原生计算基金会（CNCF）建立了可持续的生态系统，并在围绕着 项目 建立一个社区，将容器编排微服务架构的一部分。\nKubernetes 是 …","ref":"/zh/docs/glossary/cncf/","tags":["community"],"title":"云原生计算基金会（CNCF）"},{"body":"A specialized controller used to manage a custom resource tags: - architecture -- 控制器（Controller） to one or more custom resources. -- operator 模式 是一种系统设计, 将 控制器（Controller） 关联到一个或多个自定义资源。\n除了使用作为 Kubernetes 自身一部分的内置控制器之外，你还可以通过 将控制器添加到集群中来扩展 Kubernetes。\n如果正在运行的应用程序能够充当控制器并通过 API 访问的方式来执行任务操控 那些在控制平面中定义的自定义资源，这就是一个 operator 模式的示例。\n","categories":"","description":"","excerpt":"A specialized controller used to manage a custom resource tags: - …","ref":"/zh/docs/glossary/operator-pattern/","tags":["architecture"],"title":"Operator 模式"},{"body":"A container runtime with an emphasis on simplicity, robustness and portability tags: - tool --- -- 强调简单性、健壮性和可移植性的一种容器运行时\n容器（Container） runtime that runs as a daemon on Linux or Windows. containerd takes care of fetching and storing container images, executing containers, providing network access, and more. -- containerd 是一种容器（Container）运行时，能在 Linux 或者 Windows 后台运行。 containerd 能取回、存储容器镜像，执行容器实例，提供网络访问等。\n","categories":"","description":"","excerpt":"A container runtime with an emphasis on simplicity, robustness and …","ref":"/zh/docs/glossary/containerd/","tags":["tool"],"title":"containerd"},{"body":"A lightweight container runtime specifically for Kubernetes tags: - tool -- 该工具可让你通过 Kubernetes CRI 使用 OCI 容器运行时。\n容器运行时接口（CRI） to enable using 容器（Container） runtimes that are compatible with the Open Container Initiative (OCI) [runtime spec](https://www.github.com/opencontainers/runtime-spec). -- CRI-O 是 容器运行时接口（CRI） 的一种实现， 使得你可以使用与开放容器倡议（Open Container Initiative，OCI） 运行时规范 兼容的容器（Container）。\nPod, and to fetch OCI container images from remote registries. -- 部署 CRI-O 允许 Kubernetes 使用任何符合 OCI 要求的运行时作为容器运行时 去运行 Pod， 并从远程容器仓库获取 OCI 容器镜像。\n","categories":"","description":"","excerpt":"A lightweight container runtime specifically for Kubernetes tags: - …","ref":"/zh/docs/glossary/cri-o/","tags":["tool"],"title":"CRI-O"},{"body":"The layer where various containerized applications run. tags: - fundamental --- -- 各种容器化应用运行所在的层。\n","categories":"","description":"","excerpt":"The layer where various containerized applications run. tags: - …","ref":"/zh/docs/glossary/applications/","tags":["fundamental"],"title":"应用（Applications）"},{"body":"The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers. tags: - fundamental -- 控制平面（Control Plane）是指容器编排层，它暴露 API 和接口来定义、 部署容器和管理容器的生命周期。\netcd * kube-apiserver * kube-scheduler * kube-controller-manager * 云控制器管理器（Cloud Controller Manager） These components can be run as traditional operating system services (daemons) or as containers. The hosts running these components were historically called Master. -- 这个编排层是由多个不同的组件组成，例如以下（但不限于）几种：\n etcd kube-apiserver kube-scheduler kube-controller-manager 云控制器管理器（Cloud Controller Manager）  这些组件可以以传统的系统服务运行也可以以容器的形式运行.运行这些组件的主机过去称为 master 节点。\n","categories":"","description":"","excerpt":"The container orchestration layer that exposes the API and interfaces …","ref":"/zh/docs/glossary/control-plane/","tags":["fundamental"],"title":"控制平面（Control Plane）"},{"body":"提供诸如 CPU，内存，网络和存储的能力，以便容器可以运行并连接到网络。\nThe layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network. tags: - fundamental --- The layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network. --","categories":"","description":"","excerpt":"提供诸如 CPU，内存，网络和存储的能力，以便容器可以运行并连接到网络。\nThe layer that provides capacity …","ref":"/zh/docs/glossary/data-plane/","tags":["fundamental"],"title":"数据平面（Data Plane）"},{"body":"The infrastructure layer provides and maintains VMs, networking, security groups and others. tags: - operation -- 基础设施层提供并维护虚拟机、网络、安全组及其他资源。\n","categories":"","description":"","excerpt":"The infrastructure layer provides and maintains VMs, networking, …","ref":"/zh/docs/glossary/cluster-infrastructure/","tags":["operations"],"title":"集群基础设施（Cluster Infrastructure）"},{"body":"The work involved in managing a Kubernetes cluster. tags: - operation --- -- Kubernetes 管理相关工作包括：日常管理操作和协调升级。\n群集操作工作的示例包括：部署新节点来扩容集群；执行软件升级；实施安全控制； 添加或删除存储；配置集群网络；管理集群范围的可观测性；响应集群事件。\n","categories":"","description":"","excerpt":"The work involved in managing a Kubernetes cluster. tags: - operation …","ref":"/zh/docs/glossary/cluster-operations/","tags":["operations"],"title":"集群操作（Cluster Operations）"},{"body":"Provides constraints to limit resource consumption per Containers or Pods in a namespace. tags: - core-object - fundamental - architecture related: - pod - container --- -- 容器（Container） or Pod in a namespace. -- 提供约束来限制命名空间中每个 容器（Container） 或 Pod 的资源消耗。\n容器（Container） or Pod in a namespace. -- LimitRange 按照类型来限制命名空间中对象能够创建的数量，以及单个 容器（Container） 或 Pod 可以请求/使用的计算资源量。\n","categories":"","description":"","excerpt":"Provides constraints to limit resource consumption per Containers or …","ref":"/zh/docs/glossary/limitrange/","tags":["core-object","fundamental","architecture"],"title":"LimitRange"},{"body":"QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction. tags: - core-object - fundamental - architecture related: - pod --- -- QoS Class（Quality of Service Class）为 Kubernetes 提供了一种将集群中的 Pod 分为几个类型并做出有关调度和驱逐决策的方法。\nPod 的 QoS 类是基于 Pod 在创建时配置的计算资源请求和限制。QoS 类用于制定有关 Pod 调度和逐出的决策。 Kubernetes 可以为 Pod 分配以下 QoS 类：Guaranteed，Burstable 或者 BestEffort。\n","categories":"","description":"","excerpt":"QoS Class (Quality of Service Class) provides a way for Kubernetes to …","ref":"/zh/docs/glossary/qos-class/","tags":["core-object","fundamental","architecture"],"title":"QoS 类（QoS Class）"},{"body":"日志是 集群（Cluster） 或应用程序记录的事件列表。\nLogs are the list of events that are logged by cluster or application. tags: - architecture - fundamental --- Logs are the list of events that are logged by 集群（Cluster） or application. -- 应用程序和系统日志可以帮助您了解集群内部发生的情况。日志对于调试问题和监视集群活动非常有用。\n","categories":"","description":"","excerpt":"日志是 集群（Cluster） 或应用程序记录的事件列表。\nLogs are the list of events that are …","ref":"/zh/docs/glossary/logging/","tags":["architecture","fundamental"],"title":"日志（Logging）"},{"body":"容器运行时接口 (CRI) 是一组与节点上 kubelet 集成的容器运行时 API\nAn API for container runtimes to integrate with kubelet tags: - fundamental --- The container runtime interface (CRI) is an API for container runtimes to integrate with kubelet on a node. -- 更多信息， 请参考 容器运行时接口 API 与规格。\n","categories":"","description":"","excerpt":"容器运行时接口 (CRI) 是一组与节点上 kubelet 集成的容器运行时 API\nAn API for container …","ref":"/zh/docs/glossary/cri/","tags":["fundamental"],"title":"容器运行时接口（CRI）"},{"body":"A high-level summary of what phase the Pod is in within its lifecyle. -- 关于 Pod 在其生命周期中处于哪个阶段的更高层次概述。\nPod 生命周期 是关于 Pod 处于哪个阶段的概述。包含了下面5种可能的的阶段: Running、Pending、Succeeded、 Failed、Unknown。关于 Pod 的阶段的更高级描述请查阅 PodStatus phase 字段。\n","categories":"","description":"","excerpt":"A high-level summary of what phase the Pod is in within its lifecyle. …","ref":"/zh/docs/glossary/pod-lifecycle/","tags":["fundamental"],"title":"Pod 生命周期"},{"body":"A workload is an application running on Kubernetes. tags: - fundamental --- -- 工作负载是在 Kubernetes 上运行的应用程序。\nStatefulSet and the web server in a Deployment. -- 代表不同类型或部分工作负载的各种核心对象包括 DaemonSet， Deployment， Job， ReplicaSet， and StatefulSet。\n例如，具有 Web 服务器和数据库的工作负载可能在一个 StatefulSet 中运行数据库， 而 Web 服务器运行在 Deployment。\n","categories":"","description":"","excerpt":"A workload is an application running on Kubernetes. tags: - …","ref":"/zh/docs/glossary/workload/","tags":["fundamental"],"title":"工作负载（Workload）"},{"body":"An object that limits the number of Pod of a replicated application, that are down simultaneously from voluntary disruptions. - PDB related: - pod - container tags: - operation --- -- Pod Disruption Budget 使应用所有者能够为多实例应用创建一个对象，来确保一定数量的具有指定标签的 Pod 在任何时候都不会被主动驱逐。 PDB 无法防止非主动的中断，但是会计入预算（budget）。\n","categories":"","description":"","excerpt":"An object that limits the number of Pod of a replicated application, …","ref":"/zh/docs/glossary/pod-disruption-budget/","tags":["operation"],"title":"Pod Disruption Budget"},{"body":"An interface for getting and setting Unix kernel parameters tags: - tool --- -- sysctl 是一个半标准化的接口，用于读取或更改正在运行的 Unix 内核的属性。\n在类 Unix 系统上， sysctl 既是管理员用于查看和修改这些设置的工具的名称，也是该工具所调用的系统调用的名称。\n容器（Container） runtimes and network plugins may rely on `sysctl` values being set a certain way. -- 容器（Container）运行时和网络插件可能对 sysctl 的取值有一定的要求。\n","categories":"","description":"","excerpt":"An interface for getting and setting Unix kernel parameters tags: - …","ref":"/zh/docs/glossary/sysctl/","tags":["工具"],"title":"sysctl"},{"body":"A container used to run part of a workload. Compare with init container. tags: - workload --- -- 容器（Container） in a Pod that are started after any 初始化容器（Init Container） have completed. -- 应用程序 容器（Container） （或 app 容器）在 Pod 中，在 初始化容器（Init Container） 启动完毕后才开始启动。\n工作负载（Workload）, and that don't need to keep running once the application container has started. If a pod doesn't have any init containers configured, all the containers in that pod are app containers. -- 初始化容器使您可以分离对于工作负载（Workload） 整体而言很重要的初始化细节，并且一旦应用容器启动，它不需要继续运行。 如果 pod 没有配置任何初始化容器，则该 pod 中的所有容器都是应用程序容器。\n","categories":"","description":"","excerpt":"A container used to run part of a workload. Compare with init …","ref":"/zh/docs/glossary/app-container/","tags":["workload"],"title":"应用程序容器（App Container）"},{"body":"A pod managed directly by the kubelet daemon on a specific node. tags: - fundamental --- -- Pod managed directly by the kubelet daemon on a specific node, -- 由特定节点上的 kubelet 守护进程直接管理的 Pod，\nAPI 服务器不了解它的存在。\n","categories":"","description":"","excerpt":"A pod managed directly by the kubelet daemon on a specific node. tags: …","ref":"/zh/docs/glossary/static-pod/","tags":["fundamental"],"title":"静态 Pod（Static Pod）"},{"body":"Software extensions to let Pods access devices that need vendor-specific initialization or setup tags: - fundamental - extension --- -- 节点（Node） and provide Pod with access to resources, such as local hardware, that require vendor-specific initialization or setup steps. -- 设备插件工作在节点主机上，给 Pod 提供访问资源的权限，比如特定厂商初始化或者安装的本地硬件。\nKubelet, so that workload Pods can access hardware features that relate to the Node where that Pod is running. You can deploy a device plugin as a DaemonSet, or install the device plugin software directly on each target Node. -- 设备插件将资源告知 Kubelet ，以便相关节点上运行的工作负载Pod可以访问硬件功能。\n更多信息请查阅设备插件\n","categories":"","description":"","excerpt":"Software extensions to let Pods access devices that need …","ref":"/zh/docs/glossary/device-plugin/","tags":["fundamental","extension"],"title":"设备插件（Device Plugin）"},{"body":"Extensions are software components that extend and deeply integrate with Kubernetes to support new types of hardware. tags: - fundamental - extension -- 扩展组件是扩展并与 Kubernetes 深度集成以支持新型硬件的软件组件。\n大多数集群管理员会使用托管的 Kubernetes 或其某种发行包。因此，大多数 Kubernetes 用户将需要 安装扩展组件， 较少用户会需要编写新的扩展组件。\n","categories":"","description":"","excerpt":"Extensions are software components that extend and deeply integrate …","ref":"/zh/docs/glossary/extensions/","tags":["fundamental","extension"],"title":"扩展组件（Extensions）"},{"body":"主机别名 (HostAliases) 是一组 IP 地址和主机名的映射，用于注入到 Pod 内的 hosts 文件。\nA HostAliases is a mapping between the IP address and hostname to be injected into a Pod's hosts file. tags: - operation --- A HostAliases is a mapping between the IP address and hostname to be injected into a Pod's hosts file. -- HostAliases 是一个包含主机名和 IP 地址的可选列表，配置后将被注入到 Pod 内的 hosts 文件中。 该选项仅适用于没有配置 hostNetwork 的 Pod.\n","categories":"","description":"","excerpt":"主机别名 (HostAliases) 是一组 IP 地址和主机名的映射，用于注入到 Pod 内的 hosts 文件。\nA …","ref":"/zh/docs/glossary/host-aliases/","tags":["operation"],"title":"HostAliases"},{"body":"Pod Priority indicates the importance of a Pod relative to other Pods. tags: - operation -- Pod relative to other Pods. -- Pod 优先级表示一个 Pod 相对于其他 Pod 的重要性。\nPod 优先级 允许用户为 Pod 设置高于或低于其他 Pod 的优先级 – 这对于生产集群 工作负载而言是一个重要的特性。\n","categories":"","description":"","excerpt":"Pod Priority indicates the importance of a Pod relative to other Pods. …","ref":"/zh/docs/glossary/pod-priority/","tags":["operation"],"title":"Pod 优先级（Pod Priority）"},{"body":"Preemption logic in Kubernetes helps a pending Pod to find a suitable Node by evicting low priority Pods existing on that Node. tags: - operation -- Pod to find a suitable 节点（Node） by evicting low priority Pods existing on that Node. -- Kubernetes 中的抢占逻辑通过驱逐节点（Node） 上的低优先级Pod 来帮助悬决的 Pod 找到合适的节点。\n如果一个 Pod 无法调度，调度器会尝试 抢占 较低优先级的 Pod，以使得悬决的 Pod 有可能被调度。\n","categories":"","description":"","excerpt":"Preemption logic in Kubernetes helps a pending Pod to find a suitable …","ref":"/zh/docs/glossary/preemption/","tags":["operation"],"title":"抢占（Preemption）"},{"body":"A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint. tags: - core-object - fundamental -- 污点（Taint）. -- 一个核心对象，由三个必需的属性组成：key、value 和 effect。 容忍度允许将 Pod 调度到具有对应污点（Taint） 的节点或节点组上。\n污点（Taint） work together to ensure that pods are not scheduled onto inappropriate nodes. One or more tolerations are applied to a Pod. A toleration indicates that the Pod is allowed (but not required) to be scheduled on nodes or node groups with matching 污点（Taint）. -- 容忍度和污点（Taint）共同作用可以 确保不会将 Pod 调度在不适合的节点上。 在同一 Pod 上可以设置一个 或者多个容忍度。 容忍度表示在包含对应污点（Taint） 的节点或节点组上调度 Pod 是允许的（但不必要）。\n","categories":"","description":"","excerpt":"A core object consisting of three required properties: key, value, and …","ref":"/zh/docs/glossary/toleration/","tags":["core-object","fundamental"],"title":"容忍度（Toleration）"},{"body":"A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups. tags: - core-object - fundamental -- Pod on 节点（Node） or node groups. -- 污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点（Node） 或节点组上调度 Pod。\n容忍度（Toleration） work together to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node. A node should only schedule a Pod with the matching tolerations for the configured taints. -- 污点和容忍度（Toleration）一起工作， 以确保不会将 Pod 调度到不适合的节点上。 同一节点（Node）上可标记一个或多个污点。 节点应该仅调度那些带着能与污点相匹配容忍度的 Pod。\n","categories":"","description":"","excerpt":"A core object consisting of three required properties: key, value, and …","ref":"/zh/docs/glossary/taint/","tags":["core-object","fundamental"],"title":"污点（Taint）"},{"body":"The lifecycle hooks expose events in the container management lifecycle and let the user run code when the events occur. tags: - extension --- -- 生命周期钩子暴露容器（Container）管理生命周期中的事件，允许用户在事件发生时运行代码。\n容器（Container）container management lifecycle and let the user run code when the events occur. -- 针对容器暴露了两个钩子：PostStart 在容器创建之后立即执行，PreStop 在容器停止之前立即阻塞并被调用。\n","categories":"","description":"","excerpt":"The lifecycle hooks expose events in the container management …","ref":"/zh/docs/glossary/container-lifecycle-hooks/","tags":["extension"],"title":"容器生命周期钩子（Container Lifecycle Hooks）"},{"body":"The aggregation layer lets you install additional Kubernetes-style APIs in your cluster. tags: - architecture - extension - operation --- -- 聚合层允许您在自己的集群上安装额外的 Kubernetes 风格的 API。\nkube-apiserver to [support additional APIs](https://kubernetes.io/docs/tasks/extend-kubernetes/configure-aggregation-layer/), you can add `APIService` objects to \"claim\" a URL path in the Kubernetes API. -- 当您配置了 kube-apiserver 来 支持额外的 API，您就可以在 Kubernetes API 中增加 APIService 对象来 “申领（Claim）” 一个 URL 路径。\n","categories":"","description":"","excerpt":"The aggregation layer lets you install additional Kubernetes-style …","ref":"/zh/docs/glossary/aggregation-layer/","tags":["architecture","extension","operation"],"title":"聚合层（Aggregation Layer）"},{"body":"A whole-number representation of small or large numbers using SI suffixes. tags: - core-object -- 使用全数字来表示较小数值或使用 SI 后缀表示较大数值的表示法。\n量纲是使用紧凑的全数字表示法来表示小数值或带有国际计量单位制（SI） 的大数值的表示法。 小数用 milli 单位表示，而大数用 kilo、mega 或 giga 单位表示。\n例如，数字 1.5 表示为 1500m， 而数字 1000 表示为 1k，1000000 表示为 1M。 你还可以指定二进制表示法后缀；数字 2048 可以写成 2Ki。\n公认的十进制（10 的幂数）单位是 m（milli）、k（kilo，有意小写）、 M（mega）、G（giga）、T（terra）、P（peta）、E（exa）。\n公认的二进制（2 的幂数）单位是 Ki (kibi)、Mi (mebi)、Gi (gibi)、 Ti (tebi)、 Pi (pebi)、 Ei (exbi)。\n","categories":"","description":"","excerpt":"A whole-number representation of small or large numbers using SI …","ref":"/zh/docs/glossary/quantity/","tags":["core-object"],"title":"量纲（Quantity）"},{"body":"FlexVolume is an interface for creating out-of-tree volume plugins. The 容器存储接口（Container Storage Interface，CSI） is a newer interface which addresses several problems with FlexVolumes. tags: - storage -- 容器存储接口（Container Storage Interface，CSI） is a newer interface which addresses several problems with FlexVolumes. -- Flexvolume 是创建树外卷插件的一种接口。 容器存储接口（Container Storage Interface，CSI） 是比 Flexvolume 更新的接口，它解决了 Flexvolume 的一些问题。\n容器存储接口（Container Storage Interface，CSI） driver if possible since it addresses the limitations with FlexVolumes. -- Flexvolume 允许用户编写自己的驱动程序，并在 Kubernetes 中加入对用户自己的数据卷的支持。 FlexVolume 驱动程序的二进制文件和依赖项必须安装在主机上。 这需要 root 权限。如果可能的话，SIG Storage 建议实现 容器存储接口（Container Storage Interface，CSI） 驱动程序， 因为它解决了 Flexvolumes 的限制。\n Kubernetes 文档中的 Flexvolume 更多关于 Flexvolumes 的信息 存储供应商的卷插件 FAQ ","categories":"","description":"","excerpt":"FlexVolume is an interface for creating out-of-tree volume plugins. …","ref":"/zh/docs/glossary/flexvolume/","tags":["storage"],"title":"FlexVolume"},{"body":"The Container Storage Interface (CSI) defines a standard interface to expose storage systems to containers. tags: - storage --- -- 容器存储接口 （CSI） 定义了存储系统暴露给容器的标准接口。\nStorageClass that uses that CSI driver. * [CSI in the Kubernetes documentation](https://kubernetes.io/docs/concepts/storage/volumes/#csi) * [List of available CSI drivers](https://kubernetes-csi.github.io/docs/drivers.html) -- CSI 允许存储驱动提供商为 Kubernetes 创建定制化的存储插件， 而无需将这些插件的代码添加到 Kubernetes 代码仓库（外部插件）。 要使用某个存储提供商的 CSI 驱动，你首先要 将它部署到你的集群上。 然后你才能创建使用该 CSI 驱动的 StorageClass 。\n Kubernetes 文档中关于 CSI 的描述 可用的 CSI 驱动列表 ","categories":"","description":"","excerpt":"The Container Storage Interface (CSI) defines a standard interface to …","ref":"/zh/docs/glossary/csi/","tags":["storage"],"title":"容器存储接口（Container Storage Interface，CSI）"},{"body":"Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification. tags: - networking --- -- 容器网络接口 (CNI) 插件是遵循 appc/CNI 协议的一类网络插件。\n 想了解 Kubernetes 和 CNI 请参考 “网络插件”。 ","categories":"","description":"","excerpt":"Container network interface (CNI) plugins are a type of Network plugin …","ref":"/zh/docs/glossary/cni/","tags":["networking"],"title":"容器网络接口（CNI）"},{"body":"An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume. tags: - core-object --- -- Pod can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a 卷（Volume）. -- ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， Pod 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。\n镜像（Image）, so that your applications are easily portable. -- ConfigMap 将您的环境配置信息和 镜像（Image） 解耦，便于应用配置的修改。\n","categories":"","description":"","excerpt":"An API object used to store non-confidential data in key-value pairs. …","ref":"/zh/docs/glossary/configmap/","tags":["core-object"],"title":"ConfigMap"},{"body":"通过定制化的代码给您的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。\n当 Kubernetes 公开支持的 API 资源不能满足您的需要时，定制资源对象（Custom Resource Definitions）让您可以在您的环境上扩展 Kubernetes API。\n","categories":"","description":"","excerpt":"通过定制化的代码给您的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。\n当 Kubernetes  …","ref":"/zh/docs/glossary/customresourcedefinition/","tags":["fundamental","operation","extension"],"title":"CustomResourceDefinition"},{"body":"Ensures a copy of a Pod is running across a set of nodes in a cluster. tags: - fundamental - core-object - workload --- -- Pod is running across a set of nodes in a 集群（Cluster）. -- 确保 Pod 的副本在集群（Cluster）中的一组节点上运行。\n节点（Node）. -- 用来部署系统守护进程，例如日志搜集和监控代理，这些进程通常必须运行在每个节点（Node）上。\n","categories":"","description":"","excerpt":"Ensures a copy of a Pod is running across a set of nodes in a cluster. …","ref":"/zh/docs/glossary/daemonset/","tags":["fundamental","core-object","workload"],"title":"DaemonSet"},{"body":"Manages a replicated application on your cluster. tags: - fundamental - core-object - workload --- -- Deployment 是管理应用副本的 API 对象，通常通过运行没有本地状态的Pods来实现。\nPod, and the Pods are distributed among the 节点（Node） of a cluster. For workloads that do require local state, consider using a StatefulSet. -- 应用的每个副本就是一个 Pod， 并且这些 Pod 会分散运行在集群的节点（Node）上。\n","categories":"","description":"","excerpt":"Manages a replicated application on your cluster. tags: - fundamental …","ref":"/zh/docs/glossary/deployment/","tags":["fundamental","core-object","workload"],"title":"Deployment"},{"body":"Docker is a software technology providing operating-system-level virtualization also known as containers. tags: - fundamental --- -- 容器（Container）. -- Docker（这里特指 Docker 引擎） 是一种可以提供操作系统级别虚拟化（也称作容器（Container））的软件技术。\nDocker 使用了 Linux 内核中的资源隔离特性（如 cgroup 和内核命名空间）以及支持联合文件系统（如 OverlayFS 和其他）， 允许多个相互独立的“容器”一起运行在同一 Linux 实例上，从而避免启动和维护虚拟机（VMs）的开销。\n","categories":"","description":"","excerpt":"Docker is a software technology providing operating-system-level …","ref":"/zh/docs/glossary/docker/","tags":["fundamental"],"title":"Docker"},{"body":"一种将网络端点与 Kubernetes 资源组合在一起的方法。\nA way to group network endpoints together with Kubernetes resources. tags: - networking --- A way to group network endpoints together with Kubernetes resources. -- kube-proxy to establish network routes on each 节点（Node）. -- 一种将网络端点组合在一起的可扩缩、可扩展方式。 它们将被 kube-proxy 用于在 每个 节点（Node） 上建立网络路由。\n","categories":"","description":"","excerpt":"一种将网络端点与 Kubernetes 资源组合在一起的方法。\nA way to group network endpoints …","ref":"/zh/docs/glossary/endpoint-slice/","tags":["networking"],"title":"EndpointSlice"},{"body":"Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data. tags: - architecture - storage --- -- etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。\n您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。\n要了解 etcd 更深层次的信息，请参考 etcd 文档。\n","categories":"","description":"","excerpt":"Consistent and highly-available key value store used as Kubernetes' …","ref":"/zh/docs/glossary/etcd/","tags":["architecture","storage"],"title":"etcd"},{"body":"A package of pre-configured Kubernetes resources that can be managed with the Helm tool. tags: - tool --- -- Helm Chart 是一组预先配置的 Kubernetes 资源所构成的包，可以使用 Helm 工具对其进行管理。\nChart 提供了一种可重现的用来创建和共享 Kubernetes 应用的方法。 单个 Chart 可用来部署简单的系统（例如一个 memcached Pod）， 也可以用来部署复杂的系统（例如包含 HTTP 服务器、数据库、缓存等组件的完整 Web 应用堆栈）。\n","categories":"","description":"","excerpt":"A package of pre-configured Kubernetes resources that can be managed …","ref":"/zh/docs/glossary/helm-chart/","tags":["tool"],"title":"Helm Chart"},{"body":"An API object that manages external access to the services in a cluster, typically HTTP. tags: - networking - architecture - extension --- -- Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。\nIngress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。\n","categories":"","description":"","excerpt":"An API object that manages external access to the services in a …","ref":"/zh/docs/glossary/ingress/","tags":["networking","architecture","extension"],"title":"Ingress"},{"body":"An open platform (not Kubernetes-specific) that provides a uniform way to integrate microservices, manage traffic flow, enforce policies, and aggregate telemetry data. tags: - networking - architecture - extension --- -- Istio 是个开放平台（非 Kubernetes 特有），提供了一种统一的方式来集成微服务、管理流量、实施策略和汇总度量数据。\n添加 Istio 时不需要修改应用代码。它是基础设施的一层，介于服务和网络之间。 当它和服务的 Deployment 相结合时，就构成了通常所谓的服务网格（Service Mesh）。 Istio 的控制面抽象掉了底层的集群管理平台，这一集群管理平台可以是 Kubernetes、Mesosphere 等。\n","categories":"","description":"","excerpt":"An open platform (not Kubernetes-specific) that provides a uniform way …","ref":"/zh/docs/glossary/istio/","tags":["networking","architecture","extension"],"title":"Istio"},{"body":"A finite or batch task that runs to completion. tags: - fundamental - core-object - workload --- -- Job 是需要运行完成的确定性的或批量的任务。\nPod objects and ensures that a specified number of them successfully terminate. As Pods successfully complete, the Job tracks the successful completions. -- Job 创建一个或多个 Pod 对象，并确保指定数量的 Pod 成功终止。 随着各 Pod 成功结束，Job 会跟踪记录成功完成的个数。\n","categories":"","description":"","excerpt":"A finite or batch task that runs to completion. tags: - fundamental - …","ref":"/zh/docs/glossary/job/","tags":["fundamental","core-object","workload"],"title":"Job"},{"body":"A CLI tool that helps you create, destroy, upgrade and maintain production-grade, highly available, Kubernetes clusters. tags: - tool - operation --- -- kops 是一个命令行工具，可以帮助您创建、销毁、升级和维护生产级，高可用性的 Kubernetes 集群。\n[i18n] note kops has general availability support only for AWS. Support for using kops with GCE and VMware vSphere are in alpha.  -- [i18n] note 注意：官方仅支持 AWS，GCE 和 VMware vSphere 的支持还处于 alpha* 阶段。  kops 为您的集群提供了：\n 全自动化安装 基于 DNS 的集群标识 自愈功能：所有组件都在自动伸缩组（Auto-Scaling Groups）中运行 有限的操作系统支持 (推荐使用 Debian，支持 Ubuntu 16.04，试验性支持 CentOS \u0026 RHEL) 高可用 (HA) 支持 直接提供或者生成 Terraform 清单文件的能力  Kubeadm as a building block. `kops` builds on the kubeadm work. -- 您也可以将自己的集群作为一个构造块，使用 Kubeadm 构造集群。kops 是建立在 kubeadm 之上的。\n","categories":"","description":"","excerpt":"A CLI tool that helps you create, destroy, upgrade and maintain …","ref":"/zh/docs/glossary/kops/","tags":["tool","operation"],"title":"Kops"},{"body":"Control plane component that serves the Kubernetes API. tags: - architecture - fundamental -- 控制平面（Control Plane） that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane. -- API 服务器是 Kubernetes 控制平面（Control Plane）的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。\nKubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。\n","categories":"","description":"","excerpt":"Control plane component that serves the Kubernetes API. tags: - …","ref":"/zh/docs/glossary/kube-apiserver/","tags":["architecture","fundamental"],"title":"kube-apiserver"},{"body":"Component on the master that runs controllers. tags: - architecture - fundamental --- -- 控制器（Controller） processes. -- 运行控制器（Controller）进程的控制平面组件。\n从逻辑上讲，每个控制器（Controller）都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。\n","categories":"","description":"","excerpt":"Component on the master that runs controllers. tags: - architecture - …","ref":"/zh/docs/glossary/kube-controller-manager/","tags":["architecture","fundamental"],"title":"kube-controller-manager"},{"body":"`kube-proxy` is a network proxy that runs on each node in the cluster. tags: - fundamental - networking --- -- 服务（Service） concept. -- kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。\nkube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。\n如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。\n","categories":"","description":"","excerpt":"`kube-proxy` is a network proxy that runs on each node in the cluster. …","ref":"/zh/docs/glossary/kube-proxy/","tags":["fundamental","networking"],"title":"kube-proxy"},{"body":"Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on. tags: - architecture --- -- Pod with no assigned 节点（Node）, and selects a node for them to run on.-- 控制平面组件，负责监视新创建的、未指定运行节点（Node）的 Pod，选择节点让 Pod 在上面运行。\n调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。\n","categories":"","description":"","excerpt":"Control plane component that watches for newly created pods with no …","ref":"/zh/docs/glossary/kube-scheduler/","tags":["architecture","scheduler"],"title":"kube-scheduler"},{"body":"A tool for quickly installing Kubernetes and setting up a secure cluster. tags: - tool - operation -- 用来快速安装 Kubernetes 并搭建安全稳定的集群的工具。\n节点（Node） components. -- 你可以使用 kubeadm 安装控制面和 节点（Node） 组件。\n","categories":"","description":"","excerpt":"A tool for quickly installing Kubernetes and setting up a secure …","ref":"/zh/docs/glossary/kubeadm/","tags":["tool","operation"],"title":"Kubeadm"},{"body":"A command line tool for communicating with a Kubernetes API server. tags: - tool - fundamental --- -- Kubernetes API server. -- kubectl 是用来和 Kubernetes API 服务器进行通信的命令行工具。\n您可以使用 kubectl 创建、检查、更新和删除 Kubernetes 对象。\n","categories":"","description":"","excerpt":"A command line tool for communicating with a Kubernetes API server. …","ref":"/zh/docs/glossary/kubectl/","tags":["tool","fundamental"],"title":"Kubectl"},{"body":"An agent that runs on each node in the cluster. It makes sure that containers are running in a pod. tags: - fundamental - core-object -- 节点（Node） in the cluster. It makes sure that 容器（Container） are running in a Pod. -- 一个在集群中每个节点（Node）上运行的代理。 它保证容器（Container）都 运行在 Pod 中。\nkubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。\n","categories":"","description":"","excerpt":"An agent that runs on each node in the cluster. It makes sure that …","ref":"/zh/docs/glossary/kubelet/","tags":["fundamental","core-object"],"title":"Kubelet"},{"body":"The application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster. tags: - fundamental - architecture --- -- Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。\nKubernetes 资源和\"意向记录\"都是作为 API 对象储存的，并可以通过调用 RESTful 风格的 API 进行修改。 API 允许以声明方式管理配置。 用户可以直接和 Kubernetes API 交互，也可以通过 kubectl 这样的工具进行交互。 核心的 Kubernetes API 是很灵活的，可以扩展以支持定制资源。\n","categories":"","description":"","excerpt":"The application that serves Kubernetes functionality through a RESTful …","ref":"/zh/docs/glossary/kubernetes-api/","tags":["fundamental","architecture"],"title":"Kubernetes API"},{"body":"A tool for running Kubernetes locally. tags: - fundamental - tool --- -- Minikube 是用来在本地运行 Kubernetes 的一种工具。\nMinikube 在用户计算机上的一个虚拟机内运行单节点 Kubernetes 集群。 你可以使用 Minikube 在学习环境中尝试 Kubernetes.\n","categories":"","description":"","excerpt":"A tool for running Kubernetes locally. tags: - fundamental - tool --- …","ref":"/zh/docs/glossary/minikube/","tags":["fundamental","tool"],"title":"Minikube"},{"body":"A Pod represents a set of running containers in your cluster. tags: - core-object - fundamental --- -- 容器（Container） on your cluster. -- Pod 是 Kubernetes 的原子对象。Pod 表示您的集群上一组正在运行的容器（Container）。\nDeployment. -- 通常创建 Pod 是为了运行单个主容器。Pod 还可以运行可选的边车（sidecar）容器，以添加诸如日志记录之类的补充特性。通常用 Deployment 来管理 Pod。\n","categories":"","description":"","excerpt":"A Pod represents a set of running containers in your cluster. tags: - …","ref":"/zh/docs/glossary/pod/","tags":["core-object","fundamental"],"title":"Pod"},{"body":"Enables fine-grained authorization of pod creation and updates. tags: - core-object - fundamental --- -- Pod creation and updates. -- 为 Pod 的创建和更新操作启用细粒度的授权。\nPod 安全策略是集群级别的资源，它控制着 Pod 规约中的安全性敏感的内容。 PodSecurityPolicy对象定义了一组条件以及相关字段的默认值，Pod 运行时必须满足这些条件。Pod 安全策略控制实现上体现为一个可选的准入控制器。\n","categories":"","description":"","excerpt":"Enables fine-grained authorization of pod creation and updates. tags: …","ref":"/zh/docs/glossary/pod-security-policy/","tags":["core-object","fundamental"],"title":"Pod 安全策略"},{"body":"An API resource that automatically scales the number of pod replicas based on targeted CPU utilization or custom metric targets. tags: - operation --- -- Horizontal Pod Autoscaler（Pod 水平自动扩缩器）是一种 API 资源，它根据目标 CPU 利用率或自定义度量目标扩缩 Pod 副本的数量。\n副本控制器（Replication Controller）, Deployment, or ReplicaSet. It cannot be applied to objects that cannot be scaled, for example DaemonSet. -- HPA 通常用于 副本控制器（Replication Controller） 、Deployment 或者 ReplicaSet 上。 HPA 不能用于不支持扩缩的对象，例如 DaemonSet。\n","categories":"","description":"","excerpt":"An API resource that automatically scales the number of pod replicas …","ref":"/zh/docs/glossary/horizontal-pod-autoscaler/","tags":["operation"],"title":"Pod 水平自动扩缩器（Horizontal Pod Autoscaler）"},{"body":"ReplicaSet is the next-generation Replication Controller. tags: - fundamental - core-object - workload --- -- ReplicaSet 是下一代副本控制器。\nReplicaSet 就像 ReplicationController 那样，确保一次运行指定数量的 Pod 副本。ReplicaSet 支持新的基于集合的选择器需求（在标签的用户指南中有相关描述），而副本控制器只支持基于等值的选择器需求。\n","categories":"","description":"","excerpt":"ReplicaSet is the next-generation Replication Controller. tags: - …","ref":"/zh/docs/glossary/replica-set/","tags":["fundamental","core-object","workload"],"title":"ReplicaSet"},{"body":"Stores sensitive information, such as passwords, OAuth tokens, and ssh keys. tags: - core-object - security --- -- Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。\nPod references the secret as a file in a volume mount or by the kubelet pulling images for a pod. Secrets are great for confidential data and [ConfigMaps](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/) for non-confidential data. -- Secret 允许用户对如何使用敏感信息进行更多的控制，并减少信息意外暴露的风险，包括静态encryption（加密）。 Pod 通过挂载卷中的文件的方式引用 Secret，或者通过 kubelet 为 pod 拉取镜像时引用。 Secret 非常适合机密数据使用，而 ConfigMaps 适用于非机密数据。\n","categories":"","description":"","excerpt":"Stores sensitive information, such as passwords, OAuth tokens, and ssh …","ref":"/zh/docs/glossary/secret/","tags":["core-object","security"],"title":"Secret"},{"body":"Provides an identity for processes that run in a Pod. tags: - fundamental - core-object --- -- Pod. -- 为在 Pod 中运行的进程提供标识。\n名字空间（Namespace）. -- 当 Pod 中的进程访问集群时，API 服务器将它们作为特定的服务帐户进行身份验证， 例如 default ，创建 Pod 时，如果你没有指定服务帐户，它将自动被赋予同一个 名字空间（Namespace）中的 default 服务账户。\n","categories":"","description":"","excerpt":"Provides an identity for processes that run in a Pod. tags: - …","ref":"/zh/docs/glossary/service-account/","tags":["fundamental","core-object"],"title":"ServiceAccount"},{"body":"Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod. tags: - fundamental - core-object - workload - storage --- -- Pod, *and provides guarantees about the ordering and uniqueness* of these Pods. -- StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。\nDeployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. -- 和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。\n如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。\n","categories":"","description":"","excerpt":"Manages deployment and scaling of a set of Pods, with durable storage …","ref":"/zh/docs/glossary/statefulset/","tags":["fundamental","core-object","workload","storage"],"title":"StatefulSet"},{"body":"A StorageClass provides a way for administrators to describe different available storage types. tags: - core-object - storage --- -- StorageClass 是管理员用来描述不同的可用存储类型的一种方法。\n持久卷（Persistent Volume） belonging to the class needs to be dynamically provisioned. Users can request a particular class using the name of a StorageClass object. -- StorageClass 可以映射到服务质量等级（QoS）、备份策略、或者管理员任意定义的策略。 每个 StorageClass 对象包含的字段有 provisioner、parameters 和 reclaimPolicy。 动态制备该存储类别的持久卷（Persistent Volume）时需要用到这些字段值。 通过设置 StorageClass 对象的名称，用户可以请求特定存储类别。\n","categories":"","description":"","excerpt":"A StorageClass provides a way for administrators to describe different …","ref":"/zh/docs/glossary/storage-class/","tags":["core-object","storage"],"title":"StorageClass"},{"body":"A Kubernetes systems-generated string to uniquely identify objects. tags: - fundamental --- -- Kubernetes 系统生成的字符串，唯一标识对象。\n在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 uid，它旨在区分类似实体的历史事件。\n","categories":"","description":"","excerpt":"A Kubernetes systems-generated string to uniquely identify objects. …","ref":"/zh/docs/glossary/uid/","tags":["fundamental"],"title":"UID"},{"body":"May refer to: core Kubernetes or the source repo from which a repo was forked. tags: - community --- -- 可能指的是：核心 Kubernetes 仓库或作为当前仓库派生来源的仓库。\n 在 Kubernetes社区：对话中通常使用 upstream 来表示核心 Kubernetes 代码库，也就是更广泛的 kubernetes 生态系统、其他代码或第三方工具所依赖的仓库。 例如，社区成员可能会建议将某个功能特性贡献到 upstream，使其位于核心代码库中，而不是维护于插件或第三方工具中。 在 GitHub 或 git 中：约定是将源仓库称为 upstream，而派生的仓库则被视为 downstream。 ","categories":"","description":"","excerpt":"May refer to: core Kubernetes or the source repo from which a repo was …","ref":"/zh/docs/glossary/upstream/","tags":["community"],"title":"上游（Uptream）"},{"body":"May refer to: code in the Kubernetes ecosystem that depends upon the core Kubernetes codebase or a forked repo. tags: - community --- -- 可以指：Kubernetes 生态系统中依赖于核心 Kubernetes 代码库或分支代码库的代码。\n 在 Kubernetes 社区中：下游(downstream) 在人们交流中常用来表示那些依赖核心 Kubernetes 代码库的生态系统、代码或者第三方工具。例如，Kubernete 的一个新特性可以被下游(downstream) 应用采用，以提升它们的功能性。 在 GitHub 或 git 中：约定用下游(downstream) 表示分支代码库，源代码库被认为是上游(upstream)。 ","categories":"","description":"","excerpt":"May refer to: code in the Kubernetes ecosystem that depends upon the …","ref":"/zh/docs/glossary/downstream/","tags":["community"],"title":"下游（Downstream）"},{"body":"An organization that offers a cloud computing platform. tags: - community --- -- 一个提供云计算平台的商业机构或其他组织。\n节点（Node） and the infrastructure they rely on: networking, storage, and possibly other elements such as load balancers. -- 云供应商，有时也称作云服务供应商（CSPs）提供云计算平台或服务。\n很多云供应商提供托管的基础设施（也称作基础设施即服务或 IaaS）。 针对托管的基础设施，云供应商负责服务器、存储和网络，而用户（你） 负责管理其上运行的各层软件，例如运行一个 Kubernetes 集群。\n你也会看到 Kubernetes 被作为托管服务提供；有时也称作平台即服务或 PaaS。 针对托管的 Kubernetes，你的云供应商负责 Kubernetes 的控制面以及 节点（Node） 及他们所依赖的基础设施： 网络、存储以及其他一些诸如负载均衡器之类的元素。\n","categories":"","description":"","excerpt":"An organization that offers a cloud computing platform. tags: - …","ref":"/zh/docs/glossary/cloud-provider/","tags":["community"],"title":"云供应商（Cloud Provider）"},{"body":"Control plane component that integrates Kubernetes with third-party cloud providers. tags: - core-object - architecture - operation -- 控制平面（Control Plane） component that embeds cloud-specific control logic. The cloud controller manager lets you link your cluster into your cloud provider's API, and separates out the components that interact with that cloud platform from components that only interact with your cluster. -- 云控制器管理器是指嵌入特定云的控制逻辑的 控制平面（Control Plane）组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。\n通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑， 云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的 步调发布新特征。\n","categories":"","description":"","excerpt":"Control plane component that integrates Kubernetes with third-party …","ref":"/zh/docs/glossary/cloud-controller-manager/","tags":["core-object","architecture","operation"],"title":"云控制器管理器（Cloud Controller Manager）"},{"body":"A person who develops and contributes code to the Kubernetes open source codebase. tags: - community - user-type --- -- 为 Kubernetes 开源代码库开发并贡献代码的人。\n成员（Member） who participates in one or more 特别兴趣小组（SIG）. -- 代码贡献者也是加入一个或多个 特别兴趣小组（SIG） 的活跃的 成员（Member）。\n","categories":"","description":"","excerpt":"A person who develops and contributes code to the Kubernetes open …","ref":"/zh/docs/glossary/code-contributor/","tags":["community","user-type"],"title":"代码贡献者（Code Contributor）"},{"body":"One or more initialization containers that must run to completion before any app containers run. tags: - fundamental --- -- 容器（Container） that must run to completion before any app containers run. -- 应用容器（Container）运行前必须先运行完成的一个或多个初始化容器。\n初始化（init）容器像常规应用容器一样，只有一点不同：初始化（init）容器必须在应用容器启动前运行完成。 Init 容器的运行顺序：一个初始化（init）容器必须在下一个初始化（init）容器开始前运行完成。\n","categories":"","description":"","excerpt":"One or more initialization containers that must run to completion …","ref":"/zh/docs/glossary/init-container/","tags":["fundamental"],"title":"初始化容器（Init Container）"},{"body":"A (deprecated) API object that manages a replicated application. tags: - workload - core-object -- Pod are running. -- 一种工作管理多副本应用的负载资源，能够确保特定个数的 Pod 实例处于运行状态。\n控制面确保所指定的个数的 Pods 处于运行状态，即使某些 Pod 会失效， 比如被你手动删除或者因为其他错误启动过多 Pod 时。\n[i18n] note Deployment, which is similar. -- ReplicationController 已被启用。请参见 Deployment 执行类似功能。 ","categories":"","description":"","excerpt":"A (deprecated) API object that manages a replicated application. tags: …","ref":"/zh/docs/glossary/replication-controller/","tags":["workload","core-object"],"title":"副本控制器（Replication Controller）"},{"body":"Allows users to request automatic creation of storage Volumes. tags: - core-object - storage --- -- 卷（Volume）. -- 允许用户请求自动创建存储 卷（Volume）。\nStorageClass, referring to a 卷插件（Volume Plugin） that provisions a 卷（Volume） and the set of parameters to pass to the Volume Plugin. -- 动态供应让集群管理员无需再预先供应存储。相反，它通过用户请求自动地供应存储。 动态卷供应是基于 API 对象 StorageClass 的， StorageClass 可以引用 卷插件（Volume Plugin） 提供的 卷（Volume），也可以引用传递给卷插件（Volume Plugin）的参数集。\n","categories":"","description":"","excerpt":"Allows users to request automatic creation of storage Volumes. tags: - …","ref":"/zh/docs/glossary/dynamic-volume-provisioning/","tags":["core-object","storage"],"title":"动态卷供应（Dynamic Volume Provisioning）"},{"body":"A Volume Plugin enables integration of storage within a Pod. tags: - core-object - storage --- -- Pod. -- 卷插件可以让 Pod 集成存储。\nPod. Volume plugins can be _in tree_ or _out of tree_. _In tree_ plugins are part of the Kubernetes code repository and follow its release cycle. _Out of tree_ plugins are developed independently. -- 卷插件让您能给 Pod 附加和挂载存储卷。 卷插件既可以是 in tree 也可以是 out of tree 。in tree 插件是 Kubernetes 代码库的一部分， 并遵循其发布周期。而 Out of tree 插件则是独立开发的。\n","categories":"","description":"","excerpt":"A Volume Plugin enables integration of storage within a Pod. tags: - …","ref":"/zh/docs/glossary/volume-plugin/","tags":["core-object","storage"],"title":"卷插件（Volume Plugin）"},{"body":"A directory containing data, accessible to the containers in a pod. tags: - core-object - fundamental ---\t-- 容器（Container） in a Pod. -- 包含可被 Pod 中容器（Container）访问的数据的目录。\n每个 Kubernetes 卷在所处的 Pod 存在期间保持存在状态。 因此，卷的生命期会超出 Pod 中运行的容器（Container）， 并且保证容器（Container）重启之后仍保留数据。\n更多信息可参考storage\n","categories":"","description":"","excerpt":"A directory containing data, accessible to the containers in a pod. …","ref":"/zh/docs/glossary/volume/","tags":["core-object","fundamental"],"title":"卷（Volume）"},{"body":"An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster. tags: - fundamental --- -- 集群（Cluster）. -- 名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。\n名字空间用来组织集群中对象，并为集群资源划分提供了一种方法。同一名字空间内的资源名称必须唯一，但跨名字空间时不作要求。 在一些文档里名字空间也称为命名空间。\n","categories":"","description":"","excerpt":"An abstraction used by Kubernetes to support multiple virtual clusters …","ref":"/zh/docs/glossary/namespace/","tags":["fundamental"],"title":"名字空间（Namespace）"},{"body":"A client-provided string that refers to an object in a resource URL, such as `/api/v1/pods/some-name`. tags: - fundamental --- -- 客户端提供的字符串，引用资源 url 中的对象，如/api/v1/pods/some name。\n某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。\n","categories":"","description":"","excerpt":"A client-provided string that refers to an object in a resource URL, …","ref":"/zh/docs/glossary/name/","tags":["fundamental"],"title":"名称（Name）"},{"body":"A repeating task (a Job) that runs on a regular schedule. tags: - core-object - workload --- -- 管理定期运行的 任务。\nCronjob 对象类似 crontab 文件中的一行命令，它声明了一个遵循 Cron 格式的调度任务。\n","categories":"","description":"","excerpt":"A repeating task (a Job) that runs on a regular schedule. tags: - …","ref":"/zh/docs/glossary/cronjob/","tags":["core-object","workload"],"title":"周期调度任务（CronJob）"},{"body":"Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API. tags: - security - fundamental --- -- Kubernetes API. -- 管理授权决策，允许管理员通过 Kubernetes API 动态配置访问策略。\nRBAC 使用 角色 (包含权限规则)和 角色绑定 (将角色中定义的权限授予一组用户)。\n","categories":"","description":"","excerpt":"Manages authorization decisions, allowing admins to dynamically …","ref":"/zh/docs/glossary/rbac/","tags":["security","fundamental"],"title":"基于角色的访问控制（RBAC）"},{"body":"The securityContext field defines privilege and access control settings for a Pod or container. tags: - security --- -- Pod or 容器（Container）. -- securityContext 字段定义 Pod 或 容器（Container）的特权和访问控制设置。\n在一个 securityContext 字段中，你可以设置进程所属用户和用户组、权限相关设置。你也可以设置安全策略（例如：SELinux、AppArmor、seccomp）。\nPodSpec.securityContext 字段配置会应用到一个 Pod 中的所有的 container 。\n","categories":"","description":"","excerpt":"The securityContext field defines privilege and access control …","ref":"/zh/docs/glossary/security-context/","tags":["security"],"title":"安全上下文（Security Context）"},{"body":"Container environment variables are name=value pairs that provide useful information into containers running in a Pod. tags: - fundamental --- -- Pod -- 容器环境变量提供了 name=value 形式的、在 Pod 中运行的容器所必须的一些重要信息。\n容器（Container）. For example, file system details, information about the container itself, and other cluster resources such as service endpoints. -- 容器环境变量为运行中的容器化应用提供必要的信息，同时还提供与 容器（Container） 重要资源相关的其他信息，例如：文件系统信息、容器自身的信息以及其他像服务端点（Service endpoints）这样的集群资源信息。\n","categories":"","description":"","excerpt":"Container environment variables are name=value pairs that provide …","ref":"/zh/docs/glossary/container-env-variables/","tags":["fundamental"],"title":"容器环境变量（Container Environment Variables）"},{"body":"A lightweight and portable executable image that contains software and all of its dependencies. tags: - fundamental - workload -- 容器是可移植、可执行的轻量级的镜像，包含其中的软件及其相关依赖。\n容器使应用和底层的主机基础设施解耦，降低了应用在不同云环境或者操作系统上的部署难度，便于应用扩展。\n","categories":"","description":"","excerpt":"A lightweight and portable executable image that contains software and …","ref":"/zh/docs/glossary/container/","tags":["fundamental","workload"],"title":"容器（Container）"},{"body":"Facilitates the discussion and/or implementation of a short-lived, narrow, or decoupled project for a committee, SIG, or cross-SIG effort. tags: - community --- -- 特别兴趣小组（SIG）, or cross-SIG effort. -- 工作组是为了方便讨论和（或）推进执行一些短周期、窄范围、或者从委员会和 SIG 分离出来的项目、以及跨 SIG 的活动。\n工作组可以将人们组织起来，一起完成一项分散的任务。\n更多信息请参考 kubernetes/community 代码库和当前的 SIGs 和工作组 列表。\n","categories":"","description":"","excerpt":"Facilitates the discussion and/or implementation of a short-lived, …","ref":"/zh/docs/glossary/wg/","tags":["community"],"title":"工作组（Working Group，WG）"},{"body":"A person who customizes the Kubernetes platform to fit the needs of their project. tags: - user-type -- 定制 Kubernetes 平台以满足自己的项目需求的人。\n贡献者（Contributor） and develop extensions which are contributed to the Kubernetes community. Others develop closed-source commercial or site-specific extensions. -- 平台开发人员可以使用定制资源 或使用汇聚层扩展 Kubernetes API 来为其 Kubernetes 实例增加功能，特别是为其应用程序添加功能。 一些平台开发人员也是 kubernetes 贡献者（Contributor）， 他们会开发贡献给 Kubernetes 社区的扩展。 另一些平台开发人员则开发封闭源代码的商业扩展或用于特定网站的扩展。\n","categories":"","description":"","excerpt":"A person who customizes the Kubernetes platform to fit the needs of …","ref":"/zh/docs/glossary/platform-developer/","tags":["user-type"],"title":"平台开发人员（Platform Developer）"},{"body":"A person who writes an application that runs in a Kubernetes cluster. tags: - user-type --- -- 编写可以在 Kubernetes 集群上运行的应用的人。\n应用开发者专注于应用的某一部分。他们工作范围的大小有明显的差异。\n","categories":"","description":"","excerpt":"A person who writes an application that runs in a Kubernetes cluster. …","ref":"/zh/docs/glossary/application-developer/","tags":["user-type"],"title":"应用开发者（Application Developer）"},{"body":"A person responsible for the high-level design of an application. tags: - user-type --- -- 应用架构师是负责应用高级设计的人。\n应用架构师确保应用的实现允许它和周边组件进行可扩展的、可持续的交互。 周边组件包括数据库、日志基础设施和其他微服务。\n","categories":"","description":"","excerpt":"A person responsible for the high-level design of an application. …","ref":"/zh/docs/glossary/application-architect/","tags":["user-type"],"title":"应用架构师（Application Architect）"},{"body":"May refer to: Application Developer, Code Contributor, or Platform Developer. tags: - community - user-type --- -- 指的是：应用开发者（Application Developer）、 代码贡献者（Code Contributor）、 或平台开发人员（Platform Developer）。\n根据上下文的不同，“开发者”这个被多处使用的词条会有不同的含义。\n","categories":"","description":"","excerpt":"May refer to: Application Developer, Code Contributor, or Platform …","ref":"/zh/docs/glossary/developer/","tags":["community","user-type"],"title":"开发者（Developer）"},{"body":"A continuously active contributor in the K8s community. tags: - community --- -- 贡献者（Contributor） in the K8s community. -- K8s 社区中持续活跃的贡献者（Contributor）。\n特别兴趣小组（SIG） through GitHub teams. Pre-submit tests are automatically run for members' PRs. A member is expected to remain an active contributor to the community. -- 可以将问题单（issue）和 PR 指派给成员（Member），成员（Member）也可以通过 GitHub 小组加入 特别兴趣小组（SIG）。针对成员（Member）所提交的 PR，系统自动运行提交前测试。成员（Member）应该是持续活跃的社区贡献者。\n","categories":"","description":"","excerpt":"A continuously active contributor in the K8s community. tags: - …","ref":"/zh/docs/glossary/member/","tags":["community"],"title":"成员（Member）"},{"body":"A software offering maintained by a third-party provider. tags: - extension -- 由第三方供应商负责维护的一种软件产品。\n服务代理（Service Broker）. -- 托管服务的一些例子有 AWS EC2、Azure SQL 数据库和 GCP Pub/Sub 等， 不过它们也可以是可以被某应用使用的任何软件交付件。 服务目录 提供了一种方法用来列举、制备和绑定到 服务代理（Service Broker） 所提供的托管服务。\n","categories":"","description":"","excerpt":"A software offering maintained by a third-party provider. tags: - …","ref":"/zh/docs/glossary/managed-service/","tags":["extension"],"title":"托管服务"},{"body":"A person who can review and approve Kubernetes code contributions. tags: - community --- -- 可以审核并批准 Kubernetes 代码贡献的人。\n代码审核的重点是代码质量和正确性，而批准的重点是对贡献的整体接受。 整体接受包括向后/向前兼容性、遵守 API 和参数约定、细微的性能和正确性问题、与系统其他部分的交互等。 批准者状态的作用域是代码库的一部分。审批者以前被称为维护者。\n","categories":"","description":"","excerpt":"A person who can review and approve Kubernetes code contributions. …","ref":"/zh/docs/glossary/approver/","tags":["community"],"title":"批准者（Approver）"},{"body":"Claims storage resources defined in a PersistentVolume so that it can be mounted as a volume in a container. tags: - core-object - storage -- 持久卷（Persistent Volume） so that it can be mounted as a volume in a 容器（Container）. -- 申领持久卷（Persistent Volume）中定义的存储资源，以便可以将其挂载为容器（Container）中的卷。\n指定存储的数量，如何访问存储（只读、读写或独占）以及如何回收存储（保留、回收或删除）。存储本身的详细信息在 PersistentVolume 对象中。\n","categories":"","description":"","excerpt":"Claims storage resources defined in a PersistentVolume so that it can …","ref":"/zh/docs/glossary/persistent-volume-claim/","tags":["core-object","storage"],"title":"持久卷申领（Persistent Volume Claim）"},{"body":"An API object that represents a piece of storage in the cluster. Available as a general, pluggable resource that persists beyond the lifecycle of any individual Pod. tags: - core-object - storage --- -- Pod. -- 持久卷是代表集群中一块存储空间的 API 对象。 它是通用的、可插拔的、并且不受单个 Pod 生命周期约束的持久化资源。\n持久卷（PersistentVolumes，PV）提供了一个 API，该 API 对存储的供应方式细节进行抽象，令其与使用方式相分离。 在提前创建存储（静态供应）的场景中，PV 可以直接使用。 在按需提供存储（动态供应）的场景中，需要使用 PersistentVolumeClaims (PVCs)。\n","categories":"","description":"","excerpt":"An API object that represents a piece of storage in the cluster. …","ref":"/zh/docs/glossary/persistent-volume/","tags":["core-object","storage"],"title":"持久卷（Persistent Volume）"},{"body":"A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state. tags: - architecture - fundamental --- -- 集群（Cluster）, then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state. --\t在 Kubernetes 中，控制器通过监控集群（Cluster） 的公共状态，并致力于将当前状态转变为期望的状态。\nkube-apiserver (part of the 控制平面（Control Plane）). -- 控制器（控制平面（Control Plane）的一部分） 通过 kube-apiserver 监控你的集群中的公共状态。\nkube-controller-manager. -- 其中一些控制器是运行在控制平面内部的，对 Kubernetes 来说，他们提供核心控制操作。 比如：部署控制器（deployment controller）、守护控制器（daemonset controller）、 命名空间控制器（namespace controller）、持久化数据卷控制器（persistent volume controller）（等）都是运行在 kube-controller-manager 中的。\n","categories":"","description":"","excerpt":"A control loop that watches the shared state of the cluster through …","ref":"/zh/docs/glossary/controller/","tags":["architecture","fundamental"],"title":"控制器（Controller）"},{"body":"An endpoint for a set of Managed Services offered and maintained by a third-party. tags: - extension --- -- 托管服务 offered and maintained by a third-party. -- 由第三方提供并维护的一组托管服务的访问端点。\n服务代理（Service Broker） implement the [Open Service Broker API spec](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md) and provide a standard interface for applications to use their Managed Services. [Service Catalog](https://kubernetes.io/docs/concepts/extend-kubernetes/service-catalog/) provides a way to list, provision, and bind with Managed Services offered by Service Brokers. -- 服务代理（Service Broker）会实现 开放服务代理 API 规范 并为应用提供使用其托管服务的标准接口。 服务目录（Service Catalog）则提供一种方法，用来列举、供应和绑定服务代理商所提供的托管服务。\n","categories":"","description":"","excerpt":"An endpoint for a set of Managed Services offered and maintained by a …","ref":"/zh/docs/glossary/service-broker/","tags":["extension"],"title":"服务代理（Service Broker）"},{"body":"An extension API that enables applications running in Kubernetes clusters to easily use external managed software offerings, such as a datastore service offered by a cloud provider. tags: - extension --- -- 服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。\n托管服务 from 服务代理（Service Broker） without needing detailed knowledge about how those services are created or managed. -- 服务目录可以检索、供应、和绑定由 服务代理（Service Broker） 提供的外部托管服务， 而无需知道那些服务具体是怎样创建和托管的。\n","categories":"","description":"","excerpt":"An extension API that enables applications running in Kubernetes …","ref":"/zh/docs/glossary/service-catalog/","tags":["extension"],"title":"服务目录（Service Catalog）"},{"body":"A way to expose an application running on a set of Pods as a network service. tags: - fundamental - core-object --- -- Pod as a network service. -- 将运行在一组 Pod 上的应用程序公开为网络服务的抽象方法。\n选择算符（Selector）. If more Pods are added or removed, the set of Pods matching the selector will change. The Service makes sure that network traffic can be directed to the current set of Pods for the workload. -- 服务所针对的 Pod 集（通常）由选择算符（Selector）确定。 如果有 Pod 被添加或被删除，则与选择算符匹配的 Pod 集合将发生变化。 服务确保可以将网络流量定向到该工作负载的当前 Pod 集合。\n","categories":"","description":"","excerpt":"A way to expose an application running on a set of Pods as a network …","ref":"/zh/docs/glossary/service/","tags":["fundamental","core-object"],"title":"服务（Service）"},{"body":"Tags objects with identifying attributes that are meaningful and relevant to users. tags: - fundamental -- 用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。\nPod. They are used to organize and to select subsets of objects. -- 标签是一些关联到 Pod 这类对象上的键值对。 它们通常用来组织和选择对象子集。\n","categories":"","description":"","excerpt":"Tags objects with identifying attributes that are meaningful and …","ref":"/zh/docs/glossary/label/","tags":["fundamental"],"title":"标签（Label）"},{"body":"A key-value pair that is used to attach arbitrary non-identifying metadata to objects. tags: - fundamental --- -- 注解是以键值对的形式给资源对象附加随机的无法标识的元数据。\n标签（Label）. Clients such as tools and libraries can retrieve this metadata. -- 注解中的元数据可大可小，可以是结构化的也可以是非结构化的， 并且能包含标签（Label）不允许使用的字符。 像工具和软件库这样的客户端可以检索这些元数据。\n","categories":"","description":"","excerpt":"A key-value pair that is used to attach arbitrary non-identifying …","ref":"/zh/docs/glossary/annotation/","tags":["fundamental"],"title":"注解（Annotation）"},{"body":"Community members who collectively manage an ongoing piece or aspect of the larger Kubernetes open source project. tags: - community --- -- 成员（Member） who collectively manage an ongoing piece or aspect of the larger Kubernetes open source project. -- 共同管理大范畴 Kubernetes 开源项目中某组件或方面的一组成员（Member）。\nSIG 中的成员对推进某个领域（如体系结构、API 机制构件或者文档）具有相同的兴趣。 SIGs 必须遵从 governance guidelines 的规定， 不过可以有自己的贡献策略以及通信渠道（方式）。\n更多的详细信息可参阅 kubernetes/community 仓库以及 SIGs 和工作组（Working Groups）的最新列表。\n","categories":"","description":"","excerpt":"Community members who collectively manage an ongoing piece or aspect …","ref":"/zh/docs/glossary/sig/","tags":["community"],"title":"特别兴趣小组（SIG）"},{"body":"A specification of how groups of Pods are allowed to communicate with each other and with other network endpoints. tags: - networking - architecture - extension --- 网络策略是一种规范，规定了允许 Pod 组之间、Pod 与其他网络端点之间以怎样的方式进行通信。\n网络策略帮助您声明式地配置允许哪些 Pod 之间接、哪些命名空间之间允许进行通信，并具体配置了哪些端口号来执行各个策略。NetworkPolicy 资源使用标签来选择 Pod，并定义了所选 Pod 可以接受什么样的流量。网络策略由网络提供商提供的并被 Kubernetes 支持的网络插件实现。请注意，当没有控制器实现网络资源时，创建网络资源将不会生效。\n","categories":"","description":"","excerpt":"A specification of how groups of Pods are allowed to communicate with …","ref":"/zh/docs/glossary/network-policy/","tags":["networking","architecture","extension"],"title":"网络策略"},{"body":"A node is a worker machine in Kubernetes. tags: - fundamental -- Kubernetes 中的工作机器称作节点。\nPod and is managed by the control plane. The daemons on a node include Kubelet, kube-proxy, and a container runtime implementing the 容器运行时接口（CRI） such as Docker. In early Kubernetes versions, Nodes were called \"Minions\". -- 工作机器可以是虚拟机也可以是物理机，取决于集群的配置。 其上部署了运行 Pod 所必需的本地守护进程或服务， 并由主控组件来管理。 节点上的的守护进程包括 Kubelet、 kube-proxy 以及一个 Docker 这种 实现了 容器运行时接口（CRI） 的容器运行时。\n在早期的 Kubernetes 版本中，节点也称作 “Minions”。\n","categories":"","description":"","excerpt":"A node is a worker machine in Kubernetes. tags: - fundamental -- …","ref":"/zh/docs/glossary/node/","tags":["fundamental"],"title":"节点（Node）"},{"body":"A cryptographically secure file used to validate access to the Kubernetes cluster. tags: - security --- -- 证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。\n证书可以让 Kubernetes 集群中运行的应用程序安全的访问 Kubernetes API。证书可以确认客户端是否被允许访问 API。\n","categories":"","description":"","excerpt":"A cryptographically secure file used to validate access to the …","ref":"/zh/docs/glossary/certificate/","tags":["security"],"title":"证书（Certificate）"},{"body":"A person who reviews code for quality and correctness on some part of the project. tags: - community --- -- 评审者是负责评审项目的某部分代码以便提高代码质量和正确性的人。\n评审者既要了解代码库又要了解软件工程规范。评审者状态是基于代码库的组成部分来设定的。\n","categories":"","description":"","excerpt":"A person who reviews code for quality and correctness on some part of …","ref":"/zh/docs/glossary/reviewer/","tags":["community"],"title":"评审者（Reviewer）"},{"body":"Terms under which a contributor grants a license to an open source project for their contributions. tags: - community --- -- 贡献者（Contributor） grants a license to an open source project for their contributions. -- 贡献者（Contributor）对他们在开源项目中所贡献的代码的授权许可条款。\nCLA 对解决贡献者在开源社区所贡献的资料和智力资产（IP）导致的法律纠纷很有帮助。\n","categories":"","description":"","excerpt":"Terms under which a contributor grants a license to an open source …","ref":"/zh/docs/glossary/cla/","tags":["community"],"title":"贡献者许可协议（CLA）"},{"body":"Someone who donates code, documentation, or their time to help the Kubernetes project or community. tags: - community -- 通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。\n特别兴趣小组（SIG） participation, or organizing community events. -- 贡献形式包括提交拉取请求（PRs）、问题报告（Issues）、反馈、参与特别兴趣小组（SIG）或者组织社区活动等等。\n","categories":"","description":"","excerpt":"Someone who donates code, documentation, or their time to help the …","ref":"/zh/docs/glossary/contributor/","tags":["community"],"title":"贡献者（Contributor）"},{"body":"Provides constraints that limit aggregate resource consumption per namespace. tags: - fundamental - operation - architecture --- -- 名字空间（Namespace）. -- 资源配额提供了限制每个 名字空间（Namespace） 的资源消耗总和的约束。\n限制了命名空间中每种对象可以创建的数量，也限制了项目中可被资源对象利用的计算资源总数。\n","categories":"","description":"","excerpt":"Provides constraints that limit aggregate resource consumption per …","ref":"/zh/docs/glossary/resource-quota/","tags":["fundamental","operation","architecture"],"title":"资源配额（Resource Quotas）"},{"body":"Allows users to filter a list of resources based on labels. tags: - fundamental --- -- 标签（Label）. -- 选择算符允许用户通过标签（Label）对一组资源对象进行筛选过滤。\n在查询资源列表时，选择算符可以通过标签对资源进行过滤筛选。\n","categories":"","description":"","excerpt":"Allows users to filter a list of resources based on labels. tags: - …","ref":"/zh/docs/glossary/selector/","tags":["fundamental"],"title":"选择算符（Selector）"},{"body":"Stored instance of a container that holds a set of software needed to run an application. tags: - fundamental --- -- 容器（Container） that holds a set of software needed to run an application. -- 镜像是保存的容器（Container）实例，它打包了应用运行所需的一组软件。\n镜像是软件打包的一种方式，可以将镜像存储在容器镜像仓库、拉取到本地系统并作为应用来运行。 镜像中包含的元数据指明了运行什么可执行程序、是由谁构建的以及其他信息。\n","categories":"","description":"","excerpt":"Stored instance of a container that holds a set of software needed to …","ref":"/zh/docs/glossary/image/","tags":["fundamental"],"title":"镜像（Image）"},{"body":"A person who configures, controls, and monitors clusters. tags: - user-type --- -- 配置、控制、监控集群的人。\n他们的主要责任是保持集群正常运行，可能需要进行周期性的维护和升级活动。\n注意： 集群操作者不同于操作者模式（Operator Pattern），操作者模式是用来扩展 Kubernetes API 的。\n","categories":"","description":"","excerpt":"A person who configures, controls, and monitors clusters. tags: - …","ref":"/zh/docs/glossary/cluster-operator/","tags":["user-type"],"title":"集群操作者（Cluster Operator）"},{"body":"A person who designs infrastructure that involves one or more Kubernetes clusters. tags: - user-type --- -- 集群架构师负责设计集群的基础设施，可能包含一个或多个 Kubernetes 集群。\n集群架构师要具备分布式系统的最佳实践经验，例如：高可用性和安全性。\n","categories":"","description":"","excerpt":"A person who designs infrastructure that involves one or more …","ref":"/zh/docs/glossary/cluster-architect/","tags":["user-type"],"title":"集群架构师（Cluster Architect）"},{"body":"  #td-cover-block-0 { background-image: url(/about/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/about/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  About KLTS KLTS (Kubernetes Long Term Support)        Kubernetes being an enterprise infrastructure, you should not use a version of Kubernetes that is no longer maintained. KLTS maintains the version that Kubernetes no longer maintains officially. You only need to upgrade to the KLTS patch version with minor fixes. To avoid bugs caused by upgrading your base to newer versions of Kubernetes, introducing features that are not currently available, Make Kubernetes more stable as your infrastructure.\n    The KLTS process is fully hosted on GitHub, and you can simply Fork the project and build your own version of Kubernetes. The build artifacts will all be stored on GitHub, the images will be stored in the GitHub Package, and the RPM and Deb packages will be stored in the repos branch of the same repository.      KLTS will maintain a release for at least 2 years after the official end of maintenance. Mainly to patch CVE vulnerabilities and more serious bugs.     ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/about/","tags":"","title":"About KLTS"},{"body":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。  漏洞影响 kubectl cp 命令允许用户在容器和用户机器之间拷贝文件，攻击者可能通过在镜像或运行容器中植入带有符号链接（symbolic links）头的恶意 tar 包，在 cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。\n官方修复的版本  1.14.1 1.13.6 1.12.8 1.11.10  KLTS 修复的版本  1.10.13-lts.1 CVE-2019-1002101.1.10.patch  ","categories":"","description":"","excerpt":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。 …","ref":"/zh/docs/patches/cve-2019-1002101/","tags":"","title":"CVE-2019-1002101"},{"body":"详细信息 这是一个提权漏洞，在通常情况下以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行  漏洞影响 所有未指定 mustRunAsNonRoot: true 的 Pod，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行。\n防范措施 为 Pod 指定 mustRunAsNonRoot: true\n官方修复的版本  1.14.3 1.13.7  KLTS 修复的版本  1.12.10-lts.1 kubernetes/kubernetes#78320 1.11.10-lts.1 kubernetes/kubernetes#78320 1.10.13-lts.1 kubernetes/kubernetes#78320  ","categories":"","description":"","excerpt":"详细信息 这是一个提权漏洞，在通常情况下以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点 …","ref":"/zh/docs/patches/cve-2019-11245/","tags":"","title":"CVE-2019-11245"},{"body":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。  漏洞影响 该漏洞与不久前的 CVE-2019-1002101 漏洞影响相似。\nkubectl cp 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，Kubernetes 会首先在容器中执行 tar 命令创建相应的归档文件，然后发送给客户端，kubectl 会在用户主机上进行相应解压操作。\n如果容器 tar 包中包含恶意文件，当攻击者具有 kubectl cp 命令的执行权限时，可以利用路径遍历(Path Traversal)。\n官方修复的版本  1.14.3 1.13.7 1.12.10  KLTS 修复的版本  1.11.10-lts.1 CVE-2019-11246.1.11.patch 1.10.13-lts.1 CVE-2019-11246.1.10.patch  ","categories":"","description":"","excerpt":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意 …","ref":"/zh/docs/patches/cve-2019-11246/","tags":"","title":"CVE-2019-11246"},{"body":"详细信息 API Server 允许通过错误的范围访问自定义的资源  漏洞影响 如果发出的请求与资源的名称空间相同，则此漏洞允许访问集群范围的自定义的资源。以这种方式访问的资源的授权是使用命名空间内的角色和角色绑定强制执行的，这意味着能访问一个命名空间中的资源，可以进行创建，查看更新或删除群集范围的资源（根据其命名空间角色权限）。\n官方修复的版本  1.12.12  KLTS 修复的版本  1.11.10-lts.1 CVE-2019-11247.1.11.patch 1.10.13-lts.1 TODO  ","categories":"","description":"","excerpt":"详细信息 API Server 允许通过错误的范围访问自定义的资源  漏洞影响 如果发出的请求与资源的名称空间相同，则此漏洞允许访问集群范围 …","ref":"/zh/docs/patches/cve-2019-11247/","tags":"","title":"CVE-2019-11247"},{"body":"详细信息 可以用过健康检查的端口访问 /debug/pprof  漏洞影响 该漏洞存在于 Kubelet 中，由于用于性能调试的 /debug/pprof 跟健康检查端口 /healthz 绑定在一起 /debug/pprof 会进行安全认证，但 /healthz接口是不认证鉴权的。所以，如果 Kubelet 的 healthz 地址不是使用 localhost，会存在泄露机器敏感信息的风险。\n官方修复的版本  1.14.4 1.13.8 1.12.10  KLTS 修复的版本  1.11.10-lts.1 CVE-2019-11248.1.11.patch 1.10.13-lts.1 CVE-2019-11248.1.11.patch  ","categories":"","description":"","excerpt":"详细信息 可以用过健康检查的端口访问 /debug/pprof  漏洞影响 该漏洞存在于 Kubelet 中， …","ref":"/zh/docs/patches/cve-2019-11248/","tags":"","title":"CVE-2019-11248"},{"body":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。  漏洞影响 该漏洞与不久前的 CVE-2019-1002101, CVE-2019-11246 漏洞影响相似。\nkubectl cp 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，Kubernetes 会首先在容器中执行 tar 命令创建相应的归档文件，然后发送给客户端，kubectl 会在用户主机上进行相应解压操作。\n如果容器 tar 包中包含恶意文件，当攻击者具有 kubectl cp 命令的执行权限时，可以利用路径遍历(Path Traversal)。\n官方修复的版本  1.15.2 1.14.5 1.13.9  KLTS 修复的版本  1.12.10-lts.1 CVE-2019-11249.1.12.patch 1.11.10-lts.1 CVE-2019-11249.1.12.patch 1.10.13-lts.1 CVE-2019-11249.1.10.patch  ","categories":"","description":"","excerpt":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意 …","ref":"/zh/docs/patches/cve-2019-11249/","tags":"","title":"CVE-2019-11249"},{"body":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。  漏洞影响 该漏洞与不久前的 CVE-2019-1002101, CVE-2019-11246, CVE-2019-11249 漏洞影响相似。\nkubectl cp 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，Kubernetes 会首先在容器中执行 tar 命令创建相应的归档文件，然后发送给客户端，kubectl 会在用户主机上进行相应解压操作。\n如果容器 tar 包中包含恶意文件，当攻击者具有 kubectl cp 命令的执行权限时，可以利用路径遍历(Path Traversal)。\n官方修复的版本  1.15.4 1.14.7 1.13.11  KLTS 修复的版本  1.12.10-lts.1 kubernetes/kubernetes#82503 1.11.10-lts.1 kubernetes/kubernetes#82503 1.10.13-lts.1 CVE-2019-11251.1.10.patch  ","categories":"","description":"","excerpt":"详细信息 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意 …","ref":"/zh/docs/patches/cve-2019-11251/","tags":"","title":"CVE-2019-11251"},{"body":"详细信息 此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。  漏洞影响 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。\n官方修复的版本  1.17.3 1.16.7 1.15.10  KLTS 修复的版本  1.14.10-lts.1 CVE-2020-8552.1.14.patch 1.13.12-lts.1 CVE-2020-8552.1.13.patch 1.12.10-lts.1 CVE-2020-8552.1.13.patch 1.11.10-lts.1 CVE-2020-8552.1.11.patch 1.10.13-lts.1 CVE-2020-8552.1.11.patch  ","categories":"","description":"","excerpt":"详细信息 此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。  漏洞影响 API Server  …","ref":"/zh/docs/patches/cve-2020-8552/","tags":"","title":"CVE-2020-8552"},{"body":"详细信息 kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。  漏洞影响 当攻击者拥有主机网络配置能力或运行在一个具备了 CAP_NET_RAW 能力的容器实例时，就可以获取在目标节点上监听了 127.0.0.1 的服务 socket 信息。如果在目标主机上存在 127.0.0.1 可以访问到且不需要任何认证鉴权的暴露服务，那么该服务信息就能被攻击者获取。\n漏洞评分  如果集群 API Server 开启了非认证端口（默认8080），那么攻击者可能获取到 API Server 接口相关信息，威胁等级为高危漏洞，评分为8.8分。 如果集群 API Server 默认关闭了非认证端口，威胁等级为中危漏洞，评分为5.4分。  防范措施 建议您采取以下安全防范措施：\n如果业务容器需使用主机网络模式且又监听在非安全端口上，可以通过在节点上手动添加 iptables 规则来缓解此漏洞。 执行以下命令，在集群中配置 iptables 规则，用于拒绝非本地对 127.0.0.1 的访问流量：\niptables -I INPUT --dst 127.0.0.0/8 ! --src 127.0.0.0/8 -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP 如果集群不需要开启API Server 不安全端口，可以将 –insecure-port=0 添加到 kubernetes API 服务器命令行来禁用端口。\n如集群内运行有不受信的容器，可以禁止 Container 开启 CAP_NET_RAW 能力，可以在 pod spec 中关闭 Container 的 CAP_NET_RAW 能力。\nsecurityContext:capabilities:drop:- \"NET_RAW\"通过 PodSecurityPolicy 策略限制部署特权或共享主机网络容器，另外可以通过在策略中配置 requiredDropCapabilities 强制容器部署关闭 CAP_NET_RAW 能力。\n官方修复的版本  1.18.4 1.17.7 1.16.11  KLTS 修复的版本  1.15.12-lts.1 kubernetes/kubernetes#92040 1.14.10-lts.1 kubernetes/kubernetes#92040 1.13.12-lts.1 kubernetes/kubernetes#92040 1.12.10-lts.1 CVE-2020-8558.1.12.patch 1.11.10-lts.1 CVE-2020-8558.1.12.patch 1.10.13-lts.1 TODO  ","categories":"","description":"","excerpt":"详细信息 kube-proxy 组件在 iptables 和 ipvs …","ref":"/zh/docs/patches/cve-2020-8558/","tags":"","title":"CVE-2020-8558"},{"body":"详细信息 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。  漏洞影响 由于 kube-apiserver 中在升级请求的代理后端中允许将请求传播回源客户端，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成被攻击节点的权限提升漏洞。\n漏洞评分 该漏洞为中危漏洞， CVSS 评分为6.4。 如果有多个集群共享使用了相同的 CA 和认证凭证，攻击者可以利用此漏洞攻击其他集群，这种情况下该漏洞为高危漏洞。\n防范措施 对于集群内跨节点的攻击，建议您采取以下安全防范措施：\n 及时吊销可能泄露的 kubeconfig 凭证，并且遵循权限最小化原则，收敛子账号不必要的 pods/exec、pods/attach、pods/portforward和 proxy 类型的资源模型 RBAC 权限。  官方修复的版本  1.18.6 1.17.9 1.16.13  KLTS 修复的版本  1.15.12-lts.1 kubernetes/kubernetes#92971 1.14.10-lts.1 kubernetes/kubernetes#92971 1.13.12-lts.1 TODO 1.12.10-lts.1 TODO 1.11.10-lts.1 TODO 1.10.13-lts.1 TODO  ","categories":"","description":"","excerpt":"详细信息 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭 …","ref":"/zh/docs/patches/cve-2020-8559/","tags":"","title":"CVE-2020-8559"},{"body":"详细信息 存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。  漏洞影响 Kubernetes 系统组件由于自身有应对崩溃的恢复机制，当遇到恶意提交的 Protobuf 消息时不会中断服务，所以不在该漏洞的影响范围内。\n在应用系统中程序接收处理 Protobuf 消息时，如果组件没有应对崩溃的恢复机制，那么这类程序都在该漏洞影响范围内，且被恶意攻击时服务可能会中断。\nKubernetes 社区经过测试验证 API Server 不受该漏洞的影响，但为了避免您受到该安全漏洞隐患的影响，社区对相关 Protobuf 文件进行了升级，具体修复版本如下:\n防范措施 如果在您的应用系统代码中使用了自动生成的 Protobuf 消息，并且发现相关组件因为以下异常退出，则可能存在该漏洞。\npanic: runtime error: index out of range [-9223372036854775804] goroutine 1 [running]: v1.(*MessageName).Unmarshal(0xc00006f1e8, 0xc0000281a8, 0xa, 0x10, 0xc00006f1b8, 0x1) .../protofile.pb.go:250 +0xb86 如果您使用了 Protobuf 消息的相关组件，推荐将 Gogo Protobuf 编译器升级到漏洞修复版本（v1.3.2或更高的版本），再基于升级后的Protobuf编译器重新生成相关的Protobuf` 消息。\n官方修复的版本  1.21: 1.21.1 1.20: 1.20.7 1.19: 1.19.11 1.18.19  KLTS 修复的版本  1.17.17-lts.1 kubernetes/kubernetes#101327 1.16.15-lts.1 kubernetes/kubernetes#101327 1.15.12-lts.1 kubernetes/kubernetes#101327 1.14.10-lts.1 kubernetes/kubernetes#101327 1.13.12-lts.1 kubernetes/kubernetes#101327 1.12.10-lts.1 kubernetes/kubernetes#101327 1.11.10-lts.1 kubernetes/kubernetes#101327 1.10.13-lts.1 kubernetes/kubernetes#101327  ","categories":"","description":"","excerpt":"详细信息 存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存 …","ref":"/zh/docs/patches/cve-2021-3121/","tags":"","title":"CVE-2021-3121"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/developer-guide/","tags":"","title":"Developer Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Document"},{"body":"  #td-cover-block-0 { background-image: url(/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_1920x1080_fill_q75_catmullrom_top.jpg); } }  Welcome to KLTS.io Lean More   Source Code   Long term support of Kubernetes is available here\n         KLTS offers a production Kubernetes distribution, which is a fully open source Kubernetes distribution that provides a complete Kubernetes environment and dependencies\n      New chair metrics!  The Goldydocs UI now shows chair size metrics by default.\nPlease follow this space for updates!\n   Contributions welcome!  We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more …\n   Follow us on Twitter!  For announcement of latest features etc.\nRead more …\n     This is the second Section        Download **from AppStore**  Get the Goldydocs app!\n   Contributions welcome!  We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more …\n   Follow us on Twitter!  For announcement of latest features etc.\nRead more …\n     This is another Section     ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"KLTS.io"},{"body":"  #td-cover-block-0 { background-image: url(/zh/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/zh/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_1920x1080_fill_q75_catmullrom_top.jpg); } }  欢迎来到 KLTS.io 阅读文档   查看源码   稳定、长期维护的 Kubernetes 早期版本都在这里\n         KLTS 持续维护 Kubernetes 早期发行的版本，定期修复常见的 CVE 漏洞和 bug，可直接用于生产，完全开源，包含了完整的 Kubernetes 运行时环境及其依赖\n      DaoCloud 开源社区  提供镜像验证、交互设计、运维套件和文档开发等实用的开源工具！\n更多 …\n   欢迎加入 KLTS  我们在 GitHub 上开放了 Pull Request 贡献工作流。欢迎开发者加入！\n更多 …\n   了解 DaoCloud  企业级云计算领域的创新领导者\n更多 …\n       安装准备工作  安装 Kubernetes 的环境准备工作\n更多 …\n   安装  Kubernetes 的安装步骤\n更多 …\n   安装之后  安装 Kubernetes 之后需要执行的操作\n更多 …\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/zh/","tags":"","title":"KLTS.io"},{"body":"详细信息 节点磁盘充足但是一直报磁盘不足无法创建 Pod  Bug 影响 节点长期使用的时候提示剩余空间不足的错误，具体如下所示：\nmkdir: cannot create directory '/sys/fs/cgroup/memory/8': No space left on device 节点磁盘充足但是一直报和这个错误, 并且创建 Pod 总是失败，这是一个潜在的“定时炸弹”。\n所有使用低版本内核的环境，k8s 1.22 之前的版本都受到影响, 在 runc 1.0.0-rc94 (opencontainers/runc#2840) 修复(直接移除了)\n防范措施  升级系统内核 k8s 1.14 及以上  重新构建 Kubelet 带上 -tags=nokmem   k8s 1.14 以下  硬编码, 可以参考 nokmem.1.13.patch    KLTS 修复的版本  1.18.20-lts.1 nokmem.1.18.patch 1.17.17-lts.1 nokmem.1.18.patch 1.16.15-lts.1 nokmem.1.18.patch 1.15.12-lts.1 nokmem.1.18.patch 1.14.10-lts.1 nokmem.1.18.patch 1.13.12-lts.1 nokmem.1.13.patch 1.12.10-lts.1 nokmem.1.13.patch 1.11.10-lts.1 nokmem.1.13.patch 1.10.13-lts.1 nokmem.1.13.patch  ","categories":"","description":"","excerpt":"详细信息 节点磁盘充足但是一直报磁盘不足无法创建 Pod  Bug 影响 节点长期使用的时候提示剩余空间不足的错误，具体如下所示： …","ref":"/zh/docs/patches/nokmem/","tags":"","title":"nokmem"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.10.13/","tags":"","title":"v1.10.13"},{"body":"补丁  CVE-2019-11245 CVE-2019-1002101 CVE-2019-11246 CVE-2019-11247 TODO CVE-2019-11248 CVE-2019-11249 CVE-2019-11251 CVE-2020-8552 CVE-2020-8558 TODO CVE-2020-8559 TODO CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2019-11245 CVE-2019-1002101 CVE-2019-11246 CVE-2019-11247 TODO …","ref":"/zh/docs/releases/v1.10.13/v1.10.13-lts.1/","tags":"","title":"v1.10.13-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.11.10/","tags":"","title":"v1.11.10"},{"body":"补丁  CVE-2019-11245 CVE-2019-11246 CVE-2019-11247 CVE-2019-11248 CVE-2019-11249 CVE-2019-11251 CVE-2020-8552 CVE-2020-8558 CVE-2020-8559 TODO CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2019-11245 CVE-2019-11246 CVE-2019-11247 CVE-2019-11248 …","ref":"/zh/docs/releases/v1.11.10/v1.11.10-lts.1/","tags":"","title":"v1.11.10-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.12.10/","tags":"","title":"v1.12.10"},{"body":"补丁  CVE-2019-11245 CVE-2019-11247 CVE-2019-11249 CVE-2019-11251 CVE-2020-8552 CVE-2020-8558 CVE-2020-8559 TODO CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2019-11245 CVE-2019-11247 CVE-2019-11249 CVE-2019-11251 …","ref":"/zh/docs/releases/v1.12.10/v1.12.10-lts.1/","tags":"","title":"v1.12.10-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.13.12/","tags":"","title":"v1.13.12"},{"body":"补丁  CVE-2020-8552 CVE-2020-8558 CVE-2020-8559 TODO CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2020-8552 CVE-2020-8558 CVE-2020-8559 TODO CVE-2021-3121 …","ref":"/zh/docs/releases/v1.13.12/v1.13.12-lts.1/","tags":"","title":"v1.13.12-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.14.10/","tags":"","title":"v1.14.10"},{"body":"补丁  CVE-2020-8552 CVE-2020-8558 CVE-2020-8559 CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2020-8552 CVE-2020-8558 CVE-2020-8559 CVE-2021-3121 nokmem  ","ref":"/zh/docs/releases/v1.14.10/v1.14.10-lts.1/","tags":"","title":"v1.14.10-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.15.12/","tags":"","title":"v1.15.12"},{"body":"补丁  CVE-2020-8558 CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2020-8558 CVE-2021-3121 nokmem  ","ref":"/zh/docs/releases/v1.15.12/v1.15.12-lts.1/","tags":"","title":"v1.15.12-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.16.15/","tags":"","title":"v1.16.15"},{"body":"补丁  CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2021-3121 nokmem  ","ref":"/zh/docs/releases/v1.16.15/v1.16.15-lts.1/","tags":"","title":"v1.16.15-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.17.17/","tags":"","title":"v1.17.17"},{"body":"补丁  CVE-2021-3121 nokmem  ","categories":"","description":"","excerpt":"补丁  CVE-2021-3121 nokmem  ","ref":"/zh/docs/releases/v1.17.17/v1.17.17-lts.1/","tags":"","title":"v1.17.17-lts.1"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.18.20/","tags":"","title":"v1.18.20"},{"body":"补丁  nokmem  ","categories":"","description":"","excerpt":"补丁  nokmem  ","ref":"/zh/docs/releases/v1.18.20/v1.18.20-lts.1/","tags":"","title":"v1.18.20-lts.1"},{"body":"  #td-cover-block-0 { background-image: url(/zh/about/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/zh/about/featured-background_hu376e1fbab6ce6c455a2b3aa5c258c0d9_496231_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  关于 KLTS KLTS (Kubernetes Long Term Support)        Kubernetes 是一个企业级容器集群管理系统，但目前社区仅维护最新的几个版本。 如果您使用的是较早的版本，该怎么办呢？不用担心，KLTS 帮助您维护社区不再维护的版本。 我们目前持续维护 1.10 到 1.18 近 10 个版本，您只需下载对应的版本，就能获得稳定运行的 Kubernetes 并享受持续维护的免费服务。\n    KLTS 所有流程完全托管在 GitHub 上，您可以直接 Fork 项目构建属于自己的 Kubernetes 版本。 所有镜像存放在 GitHub Package，而 rpm 和 deb 包存放在同仓库的 repos 分支。      Kubernetes 社区停止维护某个版本后，KLTS 将继续提供两年以上的维护，主要包括修补 CVE 漏洞和较为严重的 bug。      ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/zh/about/","tags":"","title":"关于 KLTS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/","tags":"","title":"文档"}]