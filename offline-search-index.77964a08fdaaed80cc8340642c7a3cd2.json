





















































[{"body":"漏洞详情 存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n漏洞影响 Kubernetes 系统组件由于自身有应对崩溃的恢复机制，当遇到恶意提交的 Protobuf 消息时不会中断服务，所以不在该漏洞的影响范围内。\n在应用系统中程序接收处理 Protobuf 消息时，如果组件没有应对崩溃的恢复机制，那么这类程序都在该漏洞影响范围内，且被恶意攻击时服务可能会中断。\nKubernetes 社区经过测试验证 API Server 不受该漏洞的影响，但为了避免您受到该安全漏洞隐患的影响，社区对相关 Protobuf 文件进行了升级，具体修复版本如下:\n防范措施 如果在您的应用系统代码中使用了自动生成的 Protobuf 消息，并且发现相关组件因为以下异常退出，则可能存在该漏洞。\npanic: runtime error: index out of range [-9223372036854775804] goroutine 1 [running]: v1.(*MessageName).Unmarshal(0xc00006f1e8, 0xc0000281a8, 0xa, 0x10, 0xc00006f1b8, 0x1) .../protofile.pb.go:250 +0xb86 如果您使用了 Protobuf 消息的相关组件，推荐将 Gogo Protobuf 编译器升级到漏洞修复版本（v1.3.2 或更高的版本），再基于升级后的 Protobuf 编译器重新生成相关的 Protobuf 消息。\n官方修复的版本  v1.21.1 v1.20.7 v1.19.11 v1.18.19  KLTS 修复的版本  v1.17.17-lts.1 kubernetes/kubernetes#101327 v1.16.15-lts.1 kubernetes/kubernetes#101327 v1.15.12-lts.1 kubernetes/kubernetes#101327 v1.14.10-lts.1 kubernetes/kubernetes#101327 v1.13.12-lts.1 kubernetes/kubernetes#101327 v1.12.10-lts.1 kubernetes/kubernetes#101327 v1.11.10-lts.1 kubernetes/kubernetes#101327 v1.10.13-lts.1 kubernetes/kubernetes#101327  ","categories":"","description":"","excerpt":"漏洞详情 存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存 …","ref":"/zh/docs/patches/cve-2021-3121/","tags":"","title":"CVE-2021-3121"},{"body":"漏洞详情 这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点权限提升的漏洞。\n漏洞影响 由于 kube-apiserver 在升级请求的代理后端中允许将请求传播回源客户端，所以攻击者可以通过截取某些发送至节点 kubelet 的升级请求，然后利用请求中原有的访问凭据转发请求至其他目标节点，从而造成被攻击节点出现权限提升的漏洞。\n漏洞评分 该漏洞为中危漏洞， CVSS 评分为 6.4。 如果有多个集群共享使用了相同的 CA 和认证凭证，攻击者可以利用此漏洞攻击其他集群，这种情况下该漏洞为高危漏洞。\n防范措施 对于集群内跨节点的攻击，建议您采取以下安全防范措施：\n 及时吊销可能泄露的 kubeconfig 凭证，并且遵循权限最小化原则，收敛子账号不必要的 pods/exec、pods/attach、pods/portforward 和 proxy 类型的资源模型 RBAC 权限。  官方修复的版本  v1.18.6 v1.17.9 v1.16.13  KLTS 修复的版本  v1.15.12-lts.1 kubernetes/kubernetes#92971 v1.14.10-lts.1 kubernetes/kubernetes#92971 v1.13.12-lts.1 TODO v1.12.10-lts.1 TODO v1.11.10-lts.1 TODO v1.10.13-lts.1 TODO  ","categories":"","description":"","excerpt":"漏洞详情 这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的 …","ref":"/zh/docs/patches/cve-2020-8559/","tags":"","title":"CVE-2020-8559"},{"body":"漏洞详情 kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n漏洞影响 当攻击者拥有主机网络配置能力或运行在一个具备了 CAP_NET_RAW 能力的容器实例时，就可以获取在目标节点上监听 127.0.0.1 的服务 socket 信息。如果在目标主机上存在 127.0.0.1 可以访问且不需要任何认证鉴权的暴露服务，那么该服务信息就能被攻击者获取。\n漏洞评分  如果集群 API Server 开启了非认证端口（默认 8080），那么攻击者可能获取到 API Server 接口相关信息，威胁等级为高危漏洞，评分为 8.8 分。 如果集群 API Server 默认关闭了非认证端口，威胁等级为中危漏洞，评分为 5.4 分。  防范措施 建议您采取以下安全防范措施：\n如果业务容器需使用主机网络模式且又在非安全端口上监听，则可以通过在节点上手动添加 iptables 规则来缓解此漏洞。 执行以下命令在集群中配置 iptables 规则，用于拒绝非本地对 127.0.0.1 的访问流量：\niptables -I INPUT --dst 127.0.0.0/8 ! --src 127.0.0.0/8 -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP 如果集群不需要开启 API Server 不安全端口，可以将 –insecure-port=0 添加到 kubernetes API 服务器命令行来禁用端口。\n如集群内运行不受信任的容器，可以禁止 Container 开启 CAP_NET_RAW 能力，在 pod spec 中关闭 Container 的 CAP_NET_RAW 能力。\nsecurityContext:capabilities:drop:- \"NET_RAW\"通过 PodSecurityPolicy 策略限制部署特权或共享主机网络容器，另外可以通过在策略中配置 requiredDropCapabilities 强制容器部署关闭 CAP_NET_RAW 能力。\n官方修复的版本  v1.18.4 v1.17.7 v1.16.11  KLTS 修复的版本  v1.15.12-lts.1 kubernetes/kubernetes#92040 v1.14.10-lts.1 kubernetes/kubernetes#92040 v1.13.12-lts.1 kubernetes/kubernetes#92040 v1.12.10-lts.1 CVE-2020-8558.1.12.patch v1.11.10-lts.1 CVE-2020-8558.1.12.patch v1.10.13-lts.1 TODO  ","categories":"","description":"","excerpt":"漏洞详情 kube-proxy 组件在 iptables 和 ipvs …","ref":"/zh/docs/patches/cve-2020-8558/","tags":"","title":"CVE-2020-8558"},{"body":"漏洞详情 此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n漏洞影响 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n官方修复的版本  v1.17.3 v1.16.7 v1.15.10  KLTS 修复的版本  v1.14.10-lts.1 CVE-2020-8552.1.14.patch v1.13.12-lts.1 CVE-2020-8552.1.13.patch v1.12.10-lts.1 CVE-2020-8552.1.13.patch v1.11.10-lts.1 CVE-2020-8552.1.11.patch v1.10.13-lts.1 CVE-2020-8552.1.11.patch  ","categories":"","description":"","excerpt":"漏洞详情 此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n漏洞影响 API Server 易 …","ref":"/zh/docs/patches/cve-2020-8552/","tags":"","title":"CVE-2020-8552"},{"body":"漏洞详情 此漏洞可能允许攻击者在 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件，从而造成破坏。\n漏洞影响 kubectl cp 命令允许用户在容器和用户机器之间拷贝文件，攻击者可能通过在镜像或运行容器中植入带有符号链接（symbolic links）头的恶意 tar 包，在 cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件，从而造成破坏。\n官方修复的版本  v1.14.1 v1.13.6 v1.12.8 v1.11.10  KLTS 修复的版本  v1.10.13-lts.1 CVE-2019-1002101.1.10.patch  ","categories":"","description":"","excerpt":"漏洞详情 此漏洞可能允许攻击者在 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件，从而造成破坏。 …","ref":"/zh/docs/patches/cve-2019-1002101/","tags":"","title":"CVE-2019-1002101"},{"body":"漏洞详情 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n漏洞影响 该漏洞与不久前的 CVE-2019-1002101、CVE-2019-11246、CVE-2019-11249 漏洞影响相似。\nkubectl cp 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，Kubernetes 首先会在容器中执行 tar 命令创建相应的归档文件，然后发送给客户端，然后 kubectl 会在用户主机上进行相应解压操作。\n如果容器 tar 包中包含恶意文件，当攻击者具有 kubectl cp 命令的执行权限时，可以利用路径遍历(Path Traversal)。\n官方修复的版本  v1.15.4 v1.14.7 v1.13.11  KLTS 修复的版本  v1.12.10-lts.1 kubernetes/kubernetes#82503 v1.11.10-lts.1 kubernetes/kubernetes#82503 v1.10.13-lts.1 CVE-2019-11251.1.10.patch  ","categories":"","description":"","excerpt":"漏洞详情 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意 …","ref":"/zh/docs/patches/cve-2019-11251/","tags":"","title":"CVE-2019-11251"},{"body":"漏洞详情 可以通过健康检查的端口访问 /debug/pprof。\n漏洞影响 该漏洞存在于 Kubelet 中，用于性能调试的 /debug/pprof 跟健康检查端口 /healthz 绑定在一起，其中 /debug/pprof 会进行安全认证，但 /healthz 接口并不进行认证鉴权。所以如果 Kubelet 的 healthz 地址未使用 localhost，则会存在泄露机器敏感信息的风险。\n官方修复的版本  v1.14.4 v1.13.8 v1.12.10  KLTS 修复的版本  v1.11.10-lts.1 CVE-2019-11248.1.11.patch v1.10.13-lts.1 CVE-2019-11248.1.11.patch  ","categories":"","description":"","excerpt":"漏洞详情 可以通过健康检查的端口访问 /debug/pprof。\n漏洞影响 该漏洞存在于 Kubelet 中， …","ref":"/zh/docs/patches/cve-2019-11248/","tags":"","title":"CVE-2019-11248"},{"body":"漏洞详情 API Server 允许通过错误的范围访问自定义的资源。\n漏洞影响 如果某个用户请求的资源已划分到命名空间，Kubernetes kube-apiserver 将错误地允许该用户访问集群范围内的自定义资源。\n以这种方式访问资源将等同于授予命名空间内所有角色及其权限，这意味着本来只能访问命名空间中一个资源的用户将能够创建、查看、更新或删除整个集群范围的资源（具体取决于其命名空间角色权限）。\n官方修复的版本  v1.12.12  KLTS 修复的版本  v1.11.10-lts.1 CVE-2019-11247.1.11.patch v1.10.13-lts.1 TODO  ","categories":"","description":"","excerpt":"漏洞详情 API Server 允许通过错误的范围访问自定义的资源。\n漏洞影响 如果某个用户请求的资源已划分到命名空间，Kubernetes …","ref":"/zh/docs/patches/cve-2019-11247/","tags":"","title":"CVE-2019-11247"},{"body":"漏洞详情 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历 (Path Traversal) 的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n漏洞影响 该漏洞与不久前的 CVE-2019-1002101 漏洞影响相似。\nkubectl cp 命令用于用户容器和主机之间的文件拷贝。当从容器中拷贝文件时，Kubernetes 首先会在容器中执行 tar 命令创建相应的归档文件，然后发送给客户端，kubectl 会在用户主机上进行相应解压操作。\n如果容器 tar 包中包含恶意文件，当攻击者具有 kubectl cp 命令的执行权限时，可以利用路径遍历 (Path Traversal) 方式将恶意文件写入任意路径。\n官方修复的版本  v1.14.3 v1.13.7 v1.12.10  KLTS 修复的版本  v1.11.10-lts.1 CVE-2019-11246.1.11.patch v1.10.13-lts.1 CVE-2019-11246.1.10.patch  ","categories":"","description":"","excerpt":"漏洞详情 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历 (Path Traversal) 的方式将容器 tar 包中的 …","ref":"/zh/docs/patches/cve-2019-11246/","tags":"","title":"CVE-2019-11246"},{"body":"漏洞详情 这是一个提权漏洞，通常以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行。\n漏洞影响 所有未指定 mustRunAsNonRoot: true 的 Pod，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行。\n防范措施 为 Pod 指定 mustRunAsNonRoot: true。\n官方修复的版本  v1.14.3 v1.13.7  KLTS 修复的版本  v1.12.10-lts.1 kubernetes/kubernetes#78320 v1.11.10-lts.1 kubernetes/kubernetes#78320 v1.10.13-lts.1 kubernetes/kubernetes#78320  ","categories":"","description":"","excerpt":"漏洞详情 这是一个提权漏洞，通常以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将 …","ref":"/zh/docs/patches/cve-2019-11245/","tags":"","title":"CVE-2019-11245"},{"body":"漏洞详情 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n漏洞影响 该漏洞与不久前的 CVE-2019-1002101、CVE-2019-11246 漏洞影响相似。\nkubectl cp 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，Kubernetes 首先会在容器中执行 tar 命令创建相应的归档文件，然后发送给客户端，然后 kubectl 会在用户主机上进行相应解压操作。\n如果容器 tar 包中包含恶意文件，当攻击者具有 kubectl cp 命令的执行权限时，可以利用路径遍历 (Path Traversal)。\n官方修复的版本  v1.15.2 v1.14.5 v1.13.9  KLTS 修复的版本  v1.12.10-lts.1 CVE-2019-11249.1.12.patch v1.11.10-lts.1 CVE-2019-11249.1.12.patch v1.10.13-lts.1 CVE-2019-11249.1.10.patch  ","categories":"","description":"","excerpt":"漏洞详情 此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意 …","ref":"/zh/docs/patches/cve-2019-11249/","tags":"","title":"CVE-2019-11249"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.18.20/","tags":"","title":"v1.18.20"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.17.17/","tags":"","title":"v1.17.17"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.16.15/","tags":"","title":"v1.16.15"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.15.12/","tags":"","title":"v1.15.12"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.14.10/","tags":"","title":"v1.14.10"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.13.12/","tags":"","title":"v1.13.12"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.12.10/","tags":"","title":"v1.12.10"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.11.10/","tags":"","title":"v1.11.10"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/v1.10.13/","tags":"","title":"v1.10.13"},{"body":"Bug 详情 节点磁盘充足但是一直报磁盘不足无法创建 Pod。\nBug 影响 节点长期使用的时候提示剩余空间不足的错误，报错信息如下所示：\nmkdir: cannot create directory '/sys/fs/cgroup/memory/8': No space left on device 节点磁盘充足但是一直报和这个错误, 并且创建 Pod 总是失败，这是一个潜在的“定时炸弹”。\n所有使用低版本内核的环境，Kubernetes 1.22 之前的版本都会受到影响, 在 runc 1.0.0-rc94 (opencontainers/runc#2840) 修复(直接移除了)\n防范措施  升级系统内核 Kubernetes 1.14 及以上  重新构建 Kubelet 带上 -tags=nokmem   Kubernetes 1.14 以下  硬编码, 请参考 nokmem.1.13.patch    KLTS 修复的版本  v1.18.20-lts.1 nokmem.1.18.patch v1.17.17-lts.1 nokmem.1.18.patch v1.16.15-lts.1 nokmem.1.18.patch v1.15.12-lts.1 nokmem.1.18.patch v1.14.10-lts.1 nokmem.1.18.patch v1.13.12-lts.1 nokmem.1.13.patch v1.12.10-lts.1 nokmem.1.13.patch v1.11.10-lts.1 nokmem.1.13.patch v1.10.13-lts.1 nokmem.1.13.patch  ","categories":"","description":"","excerpt":"Bug 详情 节点磁盘充足但是一直报磁盘不足无法创建 Pod。\nBug 影响 节点长期使用的时候提示剩余空间不足的错误，报错信息如下所示： …","ref":"/zh/docs/patches/nokmem/","tags":"","title":"nokmem"},{"body":"这是 KLTS 发布的第一个 v1.10.13 修复版本。\n补丁  CVE-2019-11245这是一个提权漏洞，通常以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行。\n CVE-2019-1002101此漏洞可能允许攻击者在 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件，从而造成破坏。\n CVE-2019-11246此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历 (Path Traversal) 的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n TODO CVE-2019-11247API Server 允许通过错误的范围访问自定义的资源。\n CVE-2019-11248可以通过健康检查的端口访问 /debug/pprof。\n CVE-2019-11249此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2019-11251此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2020-8552此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n TODO CVE-2020-8558kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n TODO CVE-2020-8559这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点权限提升的漏洞。\n CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.10.13 修复版本。\n补丁  CVE-2019-11245这是一个提权漏洞， …","ref":"/zh/docs/releases/v1.10.13/v1.10.13-lts.1/","tags":"","title":"v1.10.13-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.11.10 修复版本。\n补丁  CVE-2019-11245这是一个提权漏洞，通常以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行。\n CVE-2019-11246此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历 (Path Traversal) 的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2019-11247API Server 允许通过错误的范围访问自定义的资源。\n CVE-2019-11248可以通过健康检查的端口访问 /debug/pprof。\n CVE-2019-11249此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2019-11251此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2020-8552此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n CVE-2020-8558kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n TODO CVE-2020-8559这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点权限提升的漏洞。\n CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.11.10 修复版本。\n补丁  CVE-2019-11245这是一个提权漏洞， …","ref":"/zh/docs/releases/v1.11.10/v1.11.10-lts.1/","tags":"","title":"v1.11.10-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.12.10 修复版本。\n补丁  CVE-2019-11245这是一个提权漏洞，通常以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行。\n CVE-2019-11247API Server 允许通过错误的范围访问自定义的资源。\n CVE-2019-11249此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2019-11251此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。\n CVE-2020-8552此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n CVE-2020-8558kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n TODO CVE-2020-8559这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点权限提升的漏洞。\n CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.12.10 修复版本。\n补丁  CVE-2019-11245这是一个提权漏洞， …","ref":"/zh/docs/releases/v1.12.10/v1.12.10-lts.1/","tags":"","title":"v1.12.10-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.13.12 修复版本。\n补丁  CVE-2020-8552此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n CVE-2020-8558kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n TODO CVE-2020-8559这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点权限提升的漏洞。\n CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.13.12 修复版本。\n补丁  CVE-2020-8552此漏洞可能使 API Server …","ref":"/zh/docs/releases/v1.13.12/v1.13.12-lts.1/","tags":"","title":"v1.13.12-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.14.10 修复版本。\n补丁  CVE-2020-8552此漏洞可能使 API Server 易于遭受 API 请求成功造成的 DoS（拒绝服务攻击）。\n CVE-2020-8558kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n CVE-2020-8559这是 kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点权限提升的漏洞。\n CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.14.10 修复版本。\n补丁  CVE-2020-8552此漏洞可能使 API Server …","ref":"/zh/docs/releases/v1.14.10/v1.14.10-lts.1/","tags":"","title":"v1.14.10-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.15.12 修复版本。\n补丁  CVE-2020-8558kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个 LAN 或二层网络下的相邻节点上绑定监听本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果您的服务没有设置必要的安全认证，可能会造成信息泄露风险。\n CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.15.12 修复版本。\n补丁  CVE-2020-8558kube-proxy 组件在 iptables …","ref":"/zh/docs/releases/v1.15.12/v1.15.12-lts.1/","tags":"","title":"v1.15.12-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.16.15 修复版本。\n补丁  CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.16.15 修复版本。\n补丁  CVE-2021-3121 …","ref":"/zh/docs/releases/v1.16.15/v1.16.15-lts.1/","tags":"","title":"v1.16.15-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.17.17 修复版本。\n补丁  CVE-2021-3121存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。\n nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.17.17 修复版本。\n补丁  CVE-2021-3121 …","ref":"/zh/docs/releases/v1.17.17/v1.17.17-lts.1/","tags":"","title":"v1.17.17-lts.1"},{"body":"这是 KLTS 发布的第一个 v1.18.20 修复版本。\n补丁  nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","categories":"","description":"","excerpt":"这是 KLTS 发布的第一个 v1.18.20 修复版本。\n补丁  nokmem节点磁盘充足但是一直报磁盘不足无法创建 Pod。\n  ","ref":"/zh/docs/releases/v1.18.20/v1.18.20-lts.1/","tags":"","title":"v1.18.20-lts.1"},{"body":"Versions This section describes the meaning of a version provided by KLTS.\nAs shown in the figure above, V1.16.15 is the complete version number of a kubernetes release, where 1.16 is the major version and 15 is a patch from the community. The final part, such as lts.0, is the patch version provided by KLTS.\nWhat does KLTS maintain for Kubernetes? This section describes the kubernetes versions that KLTS can support.\nThe figure above shows the latest version of kubernetes as of August 31, 2021 was 1.22. In a normal case, the Kubernetes community only maintains four recent versions such as 1.19 to 1.22.\nHow and where can you get the earlier versions that the Kubernetes community does not maintain but your company is still using in a production or equivalent environment? This is one of the main reasons why KLTS is set up here.\nAs of August 31, 2021, KLTS maintains those earlier versions from 1.10 to 1.18. We hereby promise to maintain each earlier version at least two years. Especially, Kubernetes 1.10 is the production kernel built in DaoCloud Enterprise 3.0, a PaaS platform developed by daocloud.io, and may be maintained for a relatively longer period.\nThe Kubernetes community generally releases a major version every four months or so, and the Kubernetes versions maintained by KLTS will change accordingly. Typically, if the Kubernetes community stops to maintain a version, KLTS will take over to maintain it in a month.\nIf some bugs or critical vulnerables are fixed by the KLTS team, we will upload the fixed version here for the community members to download and use it freely.\nFor example, if the community officially releases version 1.23, the highest version maintained by KLTS will be increased by a patch number to 1.19, and so on. In general, KLTS patches will be released as often as the bugs are actually resolved.\n","categories":"","description":"","excerpt":"Versions This section describes the meaning of a version provided by …","ref":"/docs/intro/","tags":"","title":"Overview"},{"body":"KLTS 全称为 Kubernetes Long Term Support，主要为 Kubernetes 早期版本提供长期维护支持。\n这是因为在实际生产环境中，最新的版本不一定是最好的，也不是最稳定的。如下表所示，Kubernetes 的某个版本在初次发布后一年，才能提供稳定运行版。\n以 1.19 为例，其稳定运行版预计在 2021 年 10 月 28 日提供，但稳定运行的 1.19 并不能完全兼容 1.10 到 1.18 的诸多功能，中间有无数次的版本迭代开发，如果企业贸然升级到 1.19，很可能会引发生产事故。其他新版本也有类似的问题。\n现在大多数企业的选择是沿用早期版本，不会贸然升级。但 Kubernetes 社区只维护最新的 4 个版本，如何才能保证早期版本免受社区不定时发现的 CVE 漏洞和 bug 的袭扰呢？这就是 KLTS 的价值所在！我们对早期版本提供长达 3 年的维护支持。\n   K8s 版本 K8s 社区 备注       初次发布日期 EOL 稳定版本日期    1.10 2018-03-27 2019-02-13 这是 KLTS 维护的版本。Kubernetes 社区已放弃维护，具体请参阅社区版本维护声明   1.11 2018-07-28 2019-05-01    1.12 2018-09-28 2019-07-08    1.13 2018-12-04 2019-10-15    1.14 2019-03-25 2019-12-11    1.15 2019-07-20 2020-05-06    1.16 2019-09-18 2020-09-02    1.17 2019-12-08 2021-01-13    1.18 2020-03-25 2021-06-18    1.19 2020-08-26 2021-10-28 这是 Kubernetes 社区目前正在维护的最低版本   1.20 2020-12-08 2022-02-28    1.21 2021-04-08 2022-06-28    1.22 2021-08-04 2022-10-28     初次发布：指的是 Kubernetes 初次发布的 1 号版本，即 1.10.1、1.11.1 … 1.22.1 等。\nEOL 稳定版本：通常是初次发布 1 年后的最后一个 bug fix 版本，然后这个版本 End Of Life (EOL)。\nKLTS 维护周期 KLTS 目前维护了 9 个稳定版本：1.10.13, 1.11.10, 1.12.10. 1.13.12, 1.14.10, 1.15.12, 1.16.15, 1.17.17, 1.18.20。\n如果 Kubernetes 社区发现可能影响生产的 CVE 新漏洞或 bug，KLTS 团队将接手社区放弃维护的这些版本，使其处于持续维护状态。目前这 9 个版本的维护周期如下：\n从上图可看出，Kubernetes 社区对某个版本的维护周期通常在一年左右，而 KLTS 可以在接下来的三年内提供长期维护，直至代码无法兼容，才会将相应版本淘汰。\n漏洞修复 以 2021 年 1 月发现的 CVE-2021-3121 安全漏洞为例，CVSS 危急分数高达 7.5。但截止 2021 年 9 月 Kubernetes 社区：\n 仅修复了 4 个版本：18、1.19、1.20、1.21 宣称“所有早期版本均有这个安全漏洞，建议用户立即停止使用早期版本” 拒绝修复早期版本漏洞的要求  KLTS 针对这一现状，默默修复了深受 CVE-2021-3121 安全漏洞影响的 8 个早期版本：\n v1.17.17 v1.16.15 v1.15.12 v1.14.10 v1.13.12 v1.12.10 v1.11.10 v1.10.13  如果您觉得 KLTS 团队的付出有价值，让您值得信赖，欢迎任何开发者加入 KLTS 社区交流并做出贡献。\n版本说明 KLTS 提供的 Kubernetes 常见版本号如下：\n其中 V1.16.15 是 Kubernetes 的完整发行版本号，1.16 是大版本号，15 是社区补丁版本，而 lts.0 是 KLTS 提供的补丁版本号。\n","categories":"","description":"","excerpt":"KLTS 全称为 Kubernetes Long Term Support，主要为 Kubernetes 早期版本提供长期维护支持。\n这是因 …","ref":"/zh/docs/intro/","tags":"","title":"简介"},{"body":"This page introduces some preparations before installation. For example, it is required to install the kubeadm toolbox to get started. For information on how to create a cluster with kubeadm, see the Install page.\nBefore you begin  A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Good network connectivity between all nodes in the cluster (either public or on-premise network). The hostname, MAC address, and product_uuid shall be unique for every node. See here for more details. Open the required ports on the host. See Check required ports for more details. Disable the swap partition. You MUST disable the swap partition to keep the kubelet working properly.  Verify the MAC address and product_uuid are unique for every node  Get the MAC address of the network interfaces using the command ip link or ifconfig -a Check the product_uuid using the command sudo cat /sys/class/dmi/id/product_uuid  It is very likely that hardware devices have unique addresses although some virtual machines may use identical addresses. Kubernetes uses these addresses to uniquely identify the nodes in the cluster. If these addresses are not unique to each node, the installation process may fail.\nCheck network adapters If you have more than one network adapter and your Kubernetes components are not reachable via the default route, it is recommended to add IP route(s) so the Kubernetes cluster can set up proper connections via the appropriate adapter.\nLetting iptables see bridged traffic Make sure that the br_netfilter module is loaded. This can be done by running lsmod | grep br_netfilter. To load it explicitly, you can run the command sudo modprobe br_netfilter.\nTo enable the iptables on your Linux node to correctly see bridged traffic, you should ensure net.bridge.bridge-nf-call-iptables is set to 1 in your sysctl config, e.g.\ncat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system For more details see the Network Plugin Requirements page.\nCheck required ports This section lists all ports that you may use on your nodes.\nControl-plane node(s)    Protocol Direction Port Range Purpose Used By     TCP Inbound 6443* Kubernetes API server All   TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd   TCP Inbound 10250 kubelet API Self, Control plane   TCP Inbound 10251 kube-scheduler Self   TCP Inbound 10252 kube-controller-manager Self    Worker node(s)    Protocol Direction Port Range Purpose Used By     TCP Inbound 10250 kubelet API Self, Control plane   TCP Inbound 30000-32767 NodePort Services† All    Above is the default port range for NodePort Services.\nAny port numbers marked with * are overridable, so you will need to ensure any custom ports you provide are also open.\nAlthough etcd ports are included in control-plane nodes, you can also host your own etcd cluster externally or on custom ports.\nThe pod network plugin you use (see below) may also require certain ports to be open. Since this differs with each pod network plugin, see the documentation for the plugins about what port(s) those need.\nSetting a host name Set a hostname for your host by using the following command:\nhostnamectl set-hostname your-new-host-name echo \"127.0.0.1 $(hostname)\" \u003e\u003e /etc/hosts echo \"::1 $(hostname)\" \u003e\u003e /etc/hosts Disable Swap Run the following command to disable the partition swap:\nswapoff -a If you want to disable swap permanently, edit the /etc/fstab file to comment out the swap mount.\nDisable Selinux Run the following command to disable the selinux:\nsetenforce 0 If you want to disable selinux permanently, edit /etc/sysconfig/selinux and replace SELINUX=enforcing with SELINUX=disabled.\nInstall Runtime To run containers in Pods, Kubernetes uses a Container Runtime Interface (CRI).\nLinux Node Other OS By default, Kubernetes uses a CRI to interface with your chosen container runtime.\nIf you don’t specify a runtime, kubeadm automatically tries to detect an installed container runtime by scanning through a list of well-known Unix domain sockets. The following table lists container runtimes and their associated socket paths:\n   Runtime Path to Unix domain socket     Docker /var/run/dockershim.sock   Containerd /run/containerd/containerd.sock   CRI-O /var/run/crio/crio.sock     If both Docker and Containerd are detected, Docker takes precedence. This is inevitable because Docker 18.09 ships with Containerd and both are detectable even if you only installed Docker. If any other two or more runtimes are detected, kubeadm exits with an error. The kubelet integrates with Docker through the built-in dockershim CRI implementation.\n By default, kubeadm uses Docker as the container runtime. The kubelet integrates with Docker through the built-in dockershim CRI implementation.\n Docker Containerd  Red Hat-based distributions Debian-based distributions Run the following command to install a Red Hat-based distribution:\nyum install docker  Run the following command to install a Debian-based distribution:\napt-get install docker.io   By default, Containerd only provides download packages for the amd64 architecture. If you are using a different architecture, you can install the containerd.io package from the official Docker repository. Instructions for setting up the Docker repository and installing the containerd.io package for your respective Linux distribution can be found in Installing the Docker Engine.\nYou can also use the following source code to build.\nVERSION=1.5.4 wget -c https://github.com/containerd/containerd/releases/download/v${VERSION}/containerd-${VERSION}-linux-amd64.tar.gz tar xvf containerd-${VERSION}-linux-amd64.tar.gz -C /usr/local/ mkdir /etc/containerd/ \u0026\u0026 containerd config default \u003e /etc/containerd/config.toml wget -c -O /etc/systemd/system/containerd.service https://raw.githubusercontent.com/containerd/containerd/main/containerd.service systemctl start containerd \u0026\u0026 systemctl enable containerd  See container runtimes for more information.\n","categories":"","description":"","excerpt":"This page introduces some preparations before installation. For …","ref":"/docs/pre-install/","tags":"","title":"Preparation"},{"body":"本页介绍安装 Kubernetes 之前需要做好的一些准备工作，例如先要安装 kubeadm 工具箱。有关在安装此工具箱后如何用其创建集群，请参阅安装步骤。\n准备工作  准备一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令。 每台主机至少 2 GB 或更多的内存（如果内存太少将影响应用的运行） CPU 2 核或更多 集群中所有主机的网络连通（公网和内网） 单个节点上不能有重复的主机名、MAC 地址或 product_uuid，请参阅确保每个节点上 MAC 地址和 product_uuid 的唯一性。 开启主机上的某些端口，请参阅检查所需端口。 禁用交换分区。为了保证 kubelet 正常工作，您必须禁用交换分区。  确保每个节点上 MAC 地址和 product_uuid 的唯一性   使用命令 ip link 或 ifconfig -a 来获取网络接口的 MAC 地址 使用 sudo cat /sys/class/dmi/id/product_uuid 命令来校验 product_uuid  一般来讲，硬件设备拥有唯一的地址，但是有些虚拟机的地址可能会重复。 Kubernetes 使用 MAC 地址和 product_uuid 来确定集群中的唯一节点。 如果这些值在每个节点上不唯一，可能会导致安装失败。\n检查网络适配器 如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。\n允许 iptables 检查桥接流量 确保 br_netfilter 模块被加载。这一操作可以通过运行 lsmod | grep br_netfilter 来完成。若要显式加载该模块，可执行命令 sudo modprobe br_netfilter。\n为了让您的 Linux 节点上的 iptables 能够正确地查看桥接流量，您需要确保在 sysctl 配置中将 net.bridge.bridge-nf-call-iptables 设置为 1。例如：\ncat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 更多细节请查阅网络插件需求页面。\n检查所需端口 控制平面节点    协议 方向 端口范围 作用 使用者     TCP 入站 6443 Kubernetes API 服务器 所有组件   TCP 入站 2379-2380 etcd 服务器客户端 API kube-apiserver、etcd   TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件   TCP 入站 10251 kube-scheduler kube-scheduler 自身   TCP 入站 10252 kube-controller-manager kube-controller-manager 自身    工作节点    协议 方向 端口范围 作用 使用者     TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件   TCP 入站 30000-32767 NodePort 服务 所有组件    以上是 NodePort 服务的默认端口范围。\n使用 * 标记的任意端口号都可以被覆盖，所以您需要保证定制的端口是开放的。\n虽然控制平面节点已经包含了 etcd 的端口，您也可以使用自定义的外部 etcd 集群，或指定自定义端口。\n您使用的 Pod 网络插件 (见下) 也可能需要某些特定端口开启。由于各个 Pod 网络插件都有所不同，请参阅相应文档中的端口要求。\n设置节点名字 命令的语法格式如下：\nhostnamectl set-hostname your-new-host-name echo \"127.0.0.1 $(hostname)\" \u003e\u003e /etc/hosts echo \"::1 $(hostname)\" \u003e\u003e /etc/hosts 关闭 Swap 执行以下命令关闭 Swap：\nswapoff -a 如果需要永久关闭，请编辑 /etc/fstab 文件，将 swap 的挂载路径改为注释。\n关闭 Selinux 执行以下命令关闭 Selinux：\nsetenforce 0 如果需要永久关闭，请编辑 /etc/sysconfig/selinux 将 SELINUX=enforcing 替换为 SELINUX=disabled。\n安装 runtime 为了在 Pod 中运行容器，Kubernetes 使用容器运行时（Container Runtime）。\nLinux 节点 其它操作系统 默认情况下，Kubernetes 使用容器运行时接口（Container Runtime Interface，CRI）来与您所选择的容器运行时交互。\n如果您不指定运行时，则 kubeadm 会自动尝试检测系统上已经安装的运行时，方法是扫描一组众所周知的 Unix 域套接字。\n下面的表格列举了一些容器运行时及其对应的套接字路径：\n   运行时 域套接字     Docker /var/run/dockershim.sock   Containerd /run/containerd/containerd.sock   CRI-O /var/run/crio/crio.sock     如果同时检测到 Docker 和 Containerd，则优先选择 Docker。 这是必然的，即使您仅安装了 Docker，因为 Docker 18.09 附带了 Containerd，所以两者都是可以检测到的。 如果检测到其他两个或多个运行时，则 kubeadm 输出错误信息并退出。 kubelet 通过内置的 dockershim CRI 实现与 Docker 集成。\n 默认情况下， kubeadm 使用 docker 作为容器运行时。kubelet 通过内置的 dockershim CRI 实现与 Docker 集成。\n Docker Containerd  基于 Red Hat 的发行版 基于 Debian 的发行版 执行以下命令安装基于 Red Hat 发行版的 Docker：\nyum install docker  执行以下命令安装基于 Debian 发行版的 Docker：\napt-get install docker.io   Containerd 官方默认只提供 amd64 架构的下载包，如果您采用的是其他基础架构， 可以从 Docker 官方仓库安装 containerd.io 软件包。在安装 Docker 引擎中 找到为各自的 Linux 发行版设置 Docker 存储库和安装 containerd.io 软件包的有关说明。\n也可以使用以下源代码构建。\nVERSION=1.5.4 wget -c https://github.com/containerd/containerd/releases/download/v${VERSION}/containerd-${VERSION}-linux-amd64.tar.gz tar xvf containerd-${VERSION}-linux-amd64.tar.gz -C /usr/local/ mkdir /etc/containerd/ \u0026\u0026 containerd config default \u003e /etc/containerd/config.toml wget -c -O /etc/systemd/system/containerd.service https://raw.githubusercontent.com/containerd/containerd/main/containerd.service systemctl start containerd \u0026\u0026 systemctl enable containerd  参阅容器运行时以了解更多信息。\n","categories":"","description":"","excerpt":"本页介绍安装 Kubernetes 之前需要做好的一些准备工作，例如先要安装 kubeadm 工具箱。有关在安装此工具箱后如何用其创建集群， …","ref":"/zh/docs/pre-install/","tags":"","title":"准备"},{"body":"Clone single branch Since the repos branch is used as a software source for RPM and DEB, direct cloning is very large So try cloning only the single branch\ngit clone --single-branch -b master https://github.com/klts-io/kubernetes-lts ","categories":"","description":"","excerpt":"Clone single branch Since the repos branch is used as a software …","ref":"/docs/developer-guide/clone/","tags":"","title":"Clone"},{"body":"Install dependencies MacOS Red Hat-based distributions Debian-based distributions brew install jq git python@3 # Install brew, See https://brew.sh/ pip3 install yq  yum install -y epel-release yum install -y jq git python3 pip3 install yq  apt-get install -y jq git python3 python3-pip pip3 install yq  ","categories":"","description":"","excerpt":"Install dependencies MacOS Red Hat-based distributions Debian-based …","ref":"/docs/developer-guide/dependent/","tags":"","title":"Dependent"},{"body":"KLTS provides a way to install software sources based on Deb and RPM. You can choose the installation method that suits your system.\nBefore installation, ensure that your Preparation is good enough.\nSet the KLTS software source Red Hat-based distributions Debian-based distributions Run the following code to set the source of downloading a proper distribution:\ncat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://dl.klts.io/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  Run the following code to set the source of downloading a proper distribution:\ncat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://dl.klts.io/deb stable main EOF apt-get update  Install Install Install the specified releases  Red Hat-based distributions Debian-based distributions Run the following code to install a proper distribution:\nyum install kubeadm kubelet kubectl  Run the following code to install a proper distribution:\napt-get install kubeadm kubelet kubectl    Red Hat-based distributions Debian-based distributions Run the following code to install a proper distribution:\n# Search for supported releases yum search kubeadm --showduplicates | grep kubeadm- # Install VERSION=1.18.20-lts.0 yum install kubeadm-v${VERSION} kubelet-v${VERSION} kubectl-v${VERSION}  Run the following code to install a proper distribution:\n# Search for supported releases apt-cache show kubeadm | grep Version # Install VERSION=1.18.20-lts.0 apt-get install kubeadm=${VERSION} kubelet=${VERSION} kubectl=${VERSION}   Auto-start Kubelet on boot Run the following code to start Kubelet on boot:\nsystemctl enable kubelet Pull the dependency image Run the following code to pull the dependency image:\nVERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm config images pull --image-repository ${REPOS} --kubernetes-version v${VERSION} All subsequent operations on Kubeadm need to include --image-repository, --kubernetes-version actively specifying the image\nInitialize the control plane node Run the following code to initialize the control plane node:\nVERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm init --image-repository ${REPOS} --kubernetes-version v${VERSION} For details see Create a cluster with kubeadm.\n","categories":"","description":"","excerpt":"KLTS provides a way to install software sources based on Deb and RPM. …","ref":"/docs/install/","tags":"","title":"Install"},{"body":"安装依赖 MacOS 基于 Red Hat 的发行版 基于 Debian 的发行版 brew install jq git python@3 # 安装 brew, 请看 https://brew.sh/ pip3 install yq  yum install -y epel-release yum install -y jq git python3 pip3 install yq  apt-get install -y jq git python3 python3-pip pip3 install yq  ","categories":"","description":"","excerpt":"安装依赖 MacOS 基于 Red Hat 的发行版 基于 Debian 的发行版 brew install jq git python@3 …","ref":"/zh/docs/developer-guide/dependent/","tags":"","title":"依赖"},{"body":"克隆主分支 请尝试只克隆主分支，由于 repos 仓库作为 rpm 和 deb 的软件源, 直接克隆全部会非常大。\n可执行以下命令克隆主分支：\ngit clone --single-branch -b master https://github.com/klts-io/kubernetes-lts ","categories":"","description":"","excerpt":"克隆主分支 请尝试只克隆主分支，由于 repos 仓库作为 rpm 和 deb 的软件源, 直接克隆全部会非常大。\n可执行以下命令克隆主分 …","ref":"/zh/docs/developer-guide/clone/","tags":"","title":"克隆"},{"body":"KLTS 提供了基于 deb 和 rpm 软件源的安装方式，您可以选择适合的安装方式。\n安装前请确认已经完成了准备工作。\n设置 KLTS 软件源 基于 Red Hat 的发行版 基于 Debian 的发行版 基于 Red Hat 的发行版, 国内加速 🚀 基于 Debian 的发行版, 国内加速 🚀 执行以下代码设置下载 KLTS 的软件源：\ncat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://dl.klts.io/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  执行以下代码设置下载 KLTS 的软件源：\ncat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://dl.klts.io/deb stable main EOF apt-get update   说明：以下加速均来自第三方, 安全和稳定性不做保障, 仅建议测试环境使用 ❗️❗️❗️ 执行以下代码设置下载 KLTS 的软件源： /etc/hosts hub.fastgit.org ghproxy.com raw.githubusercontents.com raw.staticdn.net curl https://raw.githubusercontent.com/wzshiming/github-hosts/master/hosts \u003e\u003e/etc/hosts cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://dl.klts.io/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://hub.fastgit.org/klts-io/kubernetes-lts/raw/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://ghproxy.com/https://raw.githubusercontent.com/klts-io/kubernetes-lts/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://raw.githubusercontents.com/klts-io/kubernetes-lts/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache  cat \u003c\u003c \\EOF \u003e /etc/yum.repos.d/klts.repo [klts] name=klts baseurl=https://raw.staticdn.net/klts-io/kubernetes-lts/repos/rpm/$basearch/ enabled=1 gpgcheck=0 EOF yum makecache    说明：以下加速均来自第三方, 安全和稳定性不做保障, 仅建议测试环境使用 ❗️❗️❗️\n执行以下代码设置下载 KLTS 的软件源： /etc/hosts hub.fastgit.org ghproxy.com raw.githubusercontents.com raw.staticdn.net curl https://raw.githubusercontent.com/wzshiming/github-hosts/master/hosts \u003e\u003e/etc/hosts cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://dl.klts.io/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://hub.fastgit.org/klts-io/kubernetes-lts/raw/repos/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://ghproxy.com/https://raw.githubusercontent.com/klts-io/kubernetes-lts/repos/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://raw.githubusercontents.com/klts-io/kubernetes-lts/repos/deb stable main EOF apt-get update  cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/klts.list deb [trusted=yes] https://raw.staticdn.net/klts-io/kubernetes-lts/repos/deb stable main EOF apt-get update   安装 安装最高版本 安装指定版本  这里的最高版本指的是 KLTS 维护的最高版本。 基于 Red Hat 的发行版 基于 Debian 的发行版 执行以下命令安装 KLTS 当前维护的最高版本的 Kubernetes：\nyum install kubeadm kubelet kubectl  执行以下命令安装 KLTS 当前维护的最高版本的 Kubernetes：\napt-get install kubeadm kubelet kubectl    基于 Red Hat 的发行版 基于 Debian 的发行版 执行以下命令安装指定版本的 Kubernetes：\n# 搜索支持的版本 yum search kubeadm --showduplicates | grep kubeadm- # 安装 VERSION=1.18.20-lts.0 yum install kubeadm-v${VERSION} kubelet-v${VERSION} kubectl-v${VERSION}  执行以下命令安装指定版本的 Kubernetes：\n# 搜索支持的版本 apt-cache show kubeadm | grep Version # 安装 VERSION=1.18.20-lts.0 apt-get install kubeadm=${VERSION} kubelet=${VERSION} kubectl=${VERSION}   开机自动启动 Kubelet 执行以下命令开机自动启动 Kubelet：\nsystemctl enable kubelet 拉取依赖镜像 默认 国内加速 🚀 执行以下命令 pull 依赖的镜像：\nVERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm config images pull --image-repository ${REPOS} --kubernetes-version v${VERSION}  执行以下命令 pull 依赖的镜像：\nVERSION=1.18.20-lts.0 REPOS=ghcr.m.daocloud.io/klts-io/kubernetes-lts kubeadm config images pull --image-repository ${REPOS} --kubernetes-version v${VERSION}  后续对 kubeadm 的操作都需要加上 --image-repository，--kubernetes-version 主动指定镜像。\n初始化控制面节点 默认 国内加速 🚀 执行以下命令初始化控制面的节点：\nVERSION=1.18.20-lts.0 REPOS=ghcr.io/klts-io/kubernetes-lts kubeadm init --image-repository ${REPOS} --kubernetes-version v${VERSION}  执行以下命令初始化控制面的节点：\nVERSION=1.18.20-lts.0 REPOS=ghcr.m.daocloud.io/klts-io/kubernetes-lts kubeadm init --image-repository ${REPOS} --kubernetes-version v${VERSION}  有关更多安装说明，请参阅 Kubernetes 操作指南。\n","categories":"","description":"","excerpt":"KLTS 提供了基于 deb 和 rpm 软件源的安装方式，您可以选择适合的安装方式。\n安装前请确认已经完成了准备工作。\n设置 KLTS 软 …","ref":"/zh/docs/install/","tags":"","title":"安装步骤"},{"body":"TODO\n","categories":"","description":"","excerpt":"TODO\n","ref":"/docs/post-install/","tags":"","title":"Post Install"},{"body":"TODO\n","categories":"","description":"","excerpt":"TODO\n","ref":"/zh/docs/post-install/","tags":"","title":"后续工作"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/patches/","tags":"","title":"修复的漏洞"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/releases/","tags":"","title":"版本日志"},{"body":"  #td-cover-block-0 { background-image: url(/about/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/about/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  About KLTS KLTS (Kubernetes Long Term Support)        Kubernetes being an enterprise infrastructure, you should not use a version that is no longer maintained. KLTS maintains the versions that Kubernetes community drops officially. Simply upgrading to the KLTS patch version can enable you avoid bugs caused by newer official versions of Kubernetes, no worry about introducing features that are not currently available, and your infrastructure based on Kubernetes will be more stable.\n    The KLTS process is fully hosted on GitHub, and you can simply Fork the project and build your own version of Kubernetes. The build artifacts are all stored on GitHub, the images in the GitHub Package, and the RPM and Deb packages in the repos branch of the same repository.      KLTS will maintain a release for at least two years after the official end of maintenance, to mainly patch CVE vulnerabilities and more serious bugs.     ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/about/","tags":"","title":"About KLTS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/developer-guide/","tags":"","title":"Developer Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Document"},{"body":"  #td-cover-block-0 { background-image: url(/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_1920x1080_fill_q75_catmullrom_top.jpg); } }  Welcome to KLTS.IO Lean More   Source Code   Long term support of Kubernetes is available here          KLTS offers production distributions for earlier versions of Kubernetes, which are fully open source distributions that include complete Kubernetes environment and dependencies\n      DaoCloud Community  We provide open source toolkits for image verification, interactive UI design, document management, and more.\nRead more …\n   Welcome to join KLTS!  We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more …\n   Learn more about DaoCloud  A innovative leader of enterprise-level PaaS provider\nRead more …\n       Preparation  Prepare your environment for installation.\nRead more …\n   Installation  Describes the procedure to install a Kubernetes version.\nRead more …\n   After your installation  Describes those jobs you need perform after installation.\nRead more …\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"KLTS.io"},{"body":"  #td-cover-block-0 { background-image: url(/zh/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/zh/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_1920x1080_fill_q75_catmullrom_top.jpg); } }  欢迎来到 KLTS.IO 阅读文档   查看源码   稳定、长期维护的 Kubernetes 早期版本都在这里\n         KLTS 持续维护 Kubernetes 早期发行的版本，定期修复常见的 CVE 漏洞和 bug，可直接用于生产，完全开源，包含了完整的 Kubernetes 运行时环境及其依赖\n      DaoCloud 开源社区  提供镜像验证、交互设计、运维套件和文档开发等实用的开源工具！\n更多 …\n   欢迎加入 KLTS  我们在 GitHub 上开放了 Pull Request 贡献工作流。欢迎开发者加入！\n更多 …\n   了解 DaoCloud  企业级云计算领域的创新领导者\n更多 …\n       准备工作  Kubernetes 的安装环境准备工作\n更多 …\n   安装  Kubernetes 的安装步骤\n更多 …\n   后续工作  安装 Kubernetes 之后需要执行的操作\n更多 …\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/zh/","tags":"","title":"KLTS.io"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/search/","tags":"","title":"Search Results"},{"body":"  #td-cover-block-0 { background-image: url(/zh/about/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/zh/about/featured-background_hucee3cb3223e1b5244391c4cde6cfd3d7_469584_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  关于 KLTS KLTS (Kubernetes Long Term Support)        Kubernetes 是一个企业级容器集群管理系统，但目前社区仅维护最新的几个版本。 如果您使用的是较早的版本，该怎么办呢？不用担心，KLTS 帮助您维护社区不再维护的版本。 我们目前持续维护 1.10 到 1.18 近 10 个版本，您只需下载对应的版本，就能获得稳定运行的 Kubernetes 并享受持续维护的免费服务。\n    KLTS 所有流程完全托管在 GitHub 上，您可以直接 Fork 项目构建属于自己的 Kubernetes 版本。 所有镜像存放在 GitHub Package，而 rpm 和 deb 包存放在同仓库的 repos 分支。      Kubernetes 社区停止维护某个版本后，KLTS 将继续提供两年以上的维护，主要包括修补 CVE 漏洞和较为严重的 bug。      ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/zh/about/","tags":"","title":"关于 KLTS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/developer-guide/","tags":"","title":"开发指南"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh/docs/","tags":"","title":"文档"}]