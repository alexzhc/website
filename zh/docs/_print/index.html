<!doctype html><html lang=zh class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0"><link rel=canonical type=text/html href=/zh/docs/>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel="shortcut icon" href=/favicons/favicon.ico>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16>
<link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36>
<link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48>
<link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72>
<link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96>
<link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144>
<link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192>
<title>文档 | KLTS.io</title>
<meta name=description content="KLTS 的官网"><meta property="og:title" content="文档">
<meta property="og:description" content="KLTS 的官网">
<meta property="og:type" content="website">
<meta property="og:url" content="/zh/docs/"><meta property="og:site_name" content="KLTS.io">
<meta itemprop=name content="文档">
<meta itemprop=description content="KLTS 的官网"><meta name=twitter:card content="summary">
<meta name=twitter:title content="文档">
<meta name=twitter:description content="KLTS 的官网">
<link rel=preload href=/scss/main.min.650bdee92aa16b3ae39822dd8dfd62356c714a590c397f4abe76572440c62901.css as=style>
<link href=/scss/main.min.650bdee92aa16b3ae39822dd8dfd62356c714a590c397f4abe76572440c62901.css rel=stylesheet integrity>
<script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script src=https://unpkg.com/lunr@2.3.8/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/zh/>
<span class=navbar-logo><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="text-uppercase font-weight-bold">KLTS.io</span>
</a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/zh/about/><span>关于</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/><span class=active>文档</span></a>
</li>
<li class="nav-item dropdown mr-4 d-none d-lg-block">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/>English</a>
</div>
</li>
</ul>
</div>
<div class="navbar-nav d-none d-lg-block">
<input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off data-offline-search-index-json-src=/offline-search-index.29031c7f9741dfb249b993c77ae09e22.json data-offline-search-base-href=/ data-offline-search-max-results=10>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>文档</h1>
<ul>
<li>1: <a href=#pg-18d58d2666f9af2b2086e0baa55f315d>简介</a></li>
<li>2: <a href=#pg-50ddcb3cdb08fbe2ad5d04311c273b4c>安装准备</a></li>
<li>3: <a href=#pg-64407d3e6d5ef382426bdfbcae040c6a>安装步骤</a></li>
<li>4: <a href=#pg-c258a50dfe331dfdf852330040bd8f14>安装之后</a></li>
<li>5: <a href=#pg-cf1a7e96c5bc452942429f7b1a8d0306>补丁</a></li>
<ul>
<li>5.1: <a href=#pg-fa6c26ffb59581078942a7046be853db>CVE-2019-1002101</a></li>
<li>5.2: <a href=#pg-678704d1c81cba20ab7f9af62e484052>CVE-2019-11245</a></li>
<li>5.3: <a href=#pg-17adf9e532c044f0bc96bf2fe6fabb70>CVE-2019-11246</a></li>
<li>5.4: <a href=#pg-d902d3ffd5b3d43bf94a51814ab569c7>CVE-2019-11247</a></li>
<li>5.5: <a href=#pg-da5de8654ce647927106ce1dae3b6382>CVE-2019-11248</a></li>
<li>5.6: <a href=#pg-9677918ea7ce2b1d4116bfb9d4d31512>CVE-2019-11249</a></li>
<li>5.7: <a href=#pg-3bb42a6493fbd1d3d06aad85c3d8d1e7>CVE-2019-11251</a></li>
<li>5.8: <a href=#pg-c1ec3633b18a80bee04f17816082420b>CVE-2020-8552</a></li>
<li>5.9: <a href=#pg-5aa68ad2e414f83fec8b9beb2250fdd3>CVE-2020-8558</a></li>
<li>5.10: <a href=#pg-ce240d314dc85c8ab698d26f1466e5a2>CVE-2020-8559</a></li>
<li>5.11: <a href=#pg-d4317cf8912bca37373fe5558d2d6285>CVE-2021-3121</a></li>
<li>5.12: <a href=#pg-66481705776642cc7da302c2a84c2907>nokmem</a></li>
</ul>
<li>6: <a href=#pg-9662232d61bca04520940eafdc2967e8>版本日志</a></li>
<ul>
<li>6.1: <a href=#pg-392cbea6b384069ecbb7f7287567796b>v1.10.13</a></li>
<ul>
<li>6.1.1: <a href=#pg-11f4f5c9a4be3821c253586ecc555cbb>v1.10.13-lts.1</a></li>
</ul>
<li>6.2: <a href=#pg-f3da15966c8c4439fb741e2ef8c78204>v1.11.10</a></li>
<ul>
<li>6.2.1: <a href=#pg-9eec5b25731b7e0b81f9b917fe1bce0c>v1.11.10-lts.1</a></li>
</ul>
<li>6.3: <a href=#pg-b3690dbf3b7f69b33c1619edd3bb04ca>v1.12.10</a></li>
<ul>
<li>6.3.1: <a href=#pg-27786078bb9f8ad064a60ea6903bb0fd>v1.12.10-lts.1</a></li>
</ul>
<li>6.4: <a href=#pg-7900b7f9f88a4a74990fe03111a2da05>v1.13.12</a></li>
<ul>
<li>6.4.1: <a href=#pg-d881df1610b2ecdebb624461d03f23c9>v1.13.12-lts.1</a></li>
</ul>
<li>6.5: <a href=#pg-51d890621bb8c9944add326b0a8b37a9>v1.14.10</a></li>
<ul>
<li>6.5.1: <a href=#pg-a0f1f487ff86a6e928f7e5c357ff4b08>v1.14.10-lts.1</a></li>
</ul>
<li>6.6: <a href=#pg-e68cc5fb088f6d1ae33afaf415fddee9>v1.15.12</a></li>
<ul>
<li>6.6.1: <a href=#pg-0de2d52a18da527606a4cafd2f9c2964>v1.15.12-lts.1</a></li>
</ul>
<li>6.7: <a href=#pg-5f38f1e7b6171717787aed14f462ea87>v1.16.15</a></li>
<ul>
<li>6.7.1: <a href=#pg-291fa7036c16b7b6fec50788d3fbd23e>v1.16.15-lts.1</a></li>
</ul>
<li>6.8: <a href=#pg-2115cd3345664b75db988898787bd6c2>v1.17.17</a></li>
<ul>
<li>6.8.1: <a href=#pg-97b8bcc4b64573fbff060a24764ae889>v1.17.17-lts.1</a></li>
</ul>
<li>6.9: <a href=#pg-5c45d9bdb98f73d4ba804be5543aa913>v1.18.20</a></li>
<ul>
<li>6.9.1: <a href=#pg-f30dfdd74c807ee349c09b44ea91b5fa>v1.18.20-lts.1</a></li>
</ul>
</ul>
<li>7: <a href=#pg-a7c9e10a31abdecaec5a338462a220a8>开发指南</a></li>
<ul>
<li>7.1: <a href=#pg-8da562538e76378aaf2ff1c50166f299>依赖</a></li>
<li>7.2: <a href=#pg-79fcc7e024580df9da30cdb10805eada>克隆</a></li>
</ul>
<li>8: <a href=#pg-f4d763992e363d6113dea2a2ad1ec491>术语</a></li>
<ul>
<li>8.1: <a href=#pg-ea088dea53bf4324a475e5d395955d13>节点压力驱逐</a></li>
<li>8.2: <a href=#pg-85c3146e7a708d6559c4c51f7810b6f6>API 发起的驱逐</a></li>
<li>8.3: <a href=#pg-b2a9181259ac47c88dd4b846e14dc40d>对象（Object）</a></li>
<li>8.4: <a href=#pg-a5d2a630698933fd93614dbd1dba885b>端点（Endpoints）</a></li>
<li>8.5: <a href=#pg-af7fefbfc2a45796c3ca375511518e5c>Master</a></li>
<li>8.6: <a href=#pg-fa8a8b341bb097a7c0abb12c819f5aa7>混排切片（Shuffle Sharding）</a></li>
<li>8.7: <a href=#pg-ed4a8f9fd1c875ccae329d3f53d2feb0>附加组件（Add-ons）</a></li>
<li>8.8: <a href=#pg-24bc15f976745350a4056d3966d1ee9f>CIDR</a></li>
<li>8.9: <a href=#pg-7dc22669aa066727108036b6f115ec92>代理（Proxy）</a></li>
<li>8.10: <a href=#pg-ff4dd9b75202eafce20f231fe58bcea1>干扰（Disruption）</a></li>
<li>8.11: <a href=#pg-810644a00d411940f449bf6d150eb0df>API Group</a></li>
<li>8.12: <a href=#pg-7bb1a1bafadec6fcba480d2c0adda0cf>临时容器（Ephemeral Container）</a></li>
<li>8.13: <a href=#pg-aeafca9c7103f386be3348e8dd2d0a84>镜像 Pod（Mirror Pod）</a></li>
<li>8.14: <a href=#pg-170f5162598390413252cb3da4690390>准入控制器（Admission Controller）</a></li>
<li>8.15: <a href=#pg-b457493b432beb09ec280345c294db59>清单（Manifest）</a></li>
<li>8.16: <a href=#pg-0eb2c302a98ca11c35c182ef446b373d>控制组（cgroup）</a></li>
<li>8.17: <a href=#pg-86faf68210349366fa6a0ef030efbb61>集群（Cluster）</a></li>
<li>8.18: <a href=#pg-391f68a5984a544c18ec35cf2dca6d81>容器运行时（Container Runtime）</a></li>
<li>8.19: <a href=#pg-c1bb2dc7a968fbe5d7ad067be267b884>云原生计算基金会（CNCF）</a></li>
<li>8.20: <a href=#pg-95258abd5e7f088e9cc655eee2c25e88>Operator 模式</a></li>
<li>8.21: <a href=#pg-c9a4b9caaf3b3f726d23ec46b4f2fa38>containerd</a></li>
<li>8.22: <a href=#pg-3728cfb317c9907dfa60d8a3bac9cd7c>CRI-O</a></li>
<li>8.23: <a href=#pg-0159519399ab9be7d9e9c91b2c2a7e41>应用（Applications）</a></li>
<li>8.24: <a href=#pg-66f58cd125d2e0e6e2458478e7d4485f>控制平面（Control Plane）</a></li>
<li>8.25: <a href=#pg-ffbb95a734b8498c055480abd89f9357>数据平面（Data Plane）</a></li>
<li>8.26: <a href=#pg-e790a73a470e32df4a4b645ebcd0e738>集群基础设施（Cluster Infrastructure）</a></li>
<li>8.27: <a href=#pg-7f09f5ca01acaaeeedcb241875015d35>集群操作（Cluster Operations）</a></li>
<li>8.28: <a href=#pg-e06cda065bbef96599747ee7312b999f>LimitRange</a></li>
<li>8.29: <a href=#pg-50360f60cb4b630b53166bc1646e2739>QoS 类（QoS Class）</a></li>
<li>8.30: <a href=#pg-b03c6a3edccc411341039200ac8a6604>日志（Logging）</a></li>
<li>8.31: <a href=#pg-8857dfac09cbd90c874f4d1092ae83a9>容器运行时接口（CRI）</a></li>
<li>8.32: <a href=#pg-60425ea7053ba19b82f5c227adc76827>Pod 生命周期</a></li>
<li>8.33: <a href=#pg-0378b06e0d319f6e1e1583e457d2d057>工作负载（Workload）</a></li>
<li>8.34: <a href=#pg-0d7383e751cf4e80eb87f886b793e246>Pod Disruption Budget</a></li>
<li>8.35: <a href=#pg-929cc0b93db2184d1dff350227923245>sysctl</a></li>
<li>8.36: <a href=#pg-e23b307c1d8faa5574a7c86fc5505aef>应用程序容器（App Container）</a></li>
<li>8.37: <a href=#pg-7758f072a62f56ecadfd99b5cac9d59b>静态 Pod（Static Pod）</a></li>
<li>8.38: <a href=#pg-3b9accbfed89a2ffeac8c8d98f69911a>设备插件（Device Plugin）</a></li>
<li>8.39: <a href=#pg-2c705d3f377f7af95796724ed73f6804>扩展组件（Extensions）</a></li>
<li>8.40: <a href=#pg-eef24989f21f3b4c3b26383f03e86a84>HostAliases</a></li>
<li>8.41: <a href=#pg-8ff6088bce30e4ffc06bbcdedd09e0c5>Pod 优先级（Pod Priority）</a></li>
<li>8.42: <a href=#pg-5cfed246d3d9c9d4e36821a3b9f80a75>抢占（Preemption）</a></li>
<li>8.43: <a href=#pg-692d90d2f87028f929f9d15fe552dad7>容忍度（Toleration）</a></li>
<li>8.44: <a href=#pg-4931865ca1d0f7f9f6098354b0a091c4>污点（Taint）</a></li>
<li>8.45: <a href=#pg-de020b9f85b8766b04b8c9742d123d5a>容器生命周期钩子（Container Lifecycle Hooks）</a></li>
<li>8.46: <a href=#pg-0958b182eae3c951db0eb0e94d7f1bbd>聚合层（Aggregation Layer）</a></li>
<li>8.47: <a href=#pg-e7395f528d0587206ca14b4af250647a>量纲（Quantity）</a></li>
<li>8.48: <a href=#pg-7c76e8692d489ae67869b0213d5b9316>FlexVolume</a></li>
<li>8.49: <a href=#pg-0a2ee2d47d0ffb66a24ce3d2646f7c13>容器存储接口（Container Storage Interface，CSI）</a></li>
<li>8.50: <a href=#pg-cf72883fae6049bb588f4e2e294daba5>容器网络接口（CNI）</a></li>
<li>8.51: <a href=#pg-fdb7558ef19f95a1a756fcc17e48fbdc>ConfigMap</a></li>
<li>8.52: <a href=#pg-183f94cc1dfce9f6b913269790034e7a>CustomResourceDefinition</a></li>
<li>8.53: <a href=#pg-8676d1007b3be13d8efae8fe4ad081b1>DaemonSet</a></li>
<li>8.54: <a href=#pg-40e2823dc04a7ea6948c6c13eb9580ad>Deployment</a></li>
<li>8.55: <a href=#pg-be1e0a8cf9619ea16f8183ada08b4482>Docker</a></li>
<li>8.56: <a href=#pg-6ebc75f521516b9a368c873181715ca0>EndpointSlice</a></li>
<li>8.57: <a href=#pg-a4ad6a0f27e847c8fbe882d49bf8437a>etcd</a></li>
<li>8.58: <a href=#pg-8d334712ca67f6f138195b60018a0b6b>Helm Chart</a></li>
<li>8.59: <a href=#pg-395693d4e82c66a4f10056a09b8aa236>Ingress</a></li>
<li>8.60: <a href=#pg-c9a26032fd4c884eb5e731d92cfbbb50>Istio</a></li>
<li>8.61: <a href=#pg-bfc166010ce186953b96bc5f81b2006a>Job</a></li>
<li>8.62: <a href=#pg-d15b6100b062fdecd019adb24d1e3f34>Kops</a></li>
<li>8.63: <a href=#pg-9a5b920a0a750150154840d32360318b>kube-apiserver</a></li>
<li>8.64: <a href=#pg-4187f407e5bee751c9765710a2a5d25a>kube-controller-manager</a></li>
<li>8.65: <a href=#pg-ce957898ebfd87795c3086298f227a21>kube-proxy</a></li>
<li>8.66: <a href=#pg-e4313ba87227f104d15401e5bf459a15>kube-scheduler</a></li>
<li>8.67: <a href=#pg-e758828688e74bfe2e8106f519da981c>Kubeadm</a></li>
<li>8.68: <a href=#pg-534631ac084a6a05b80b74ccda7b29fd>Kubectl</a></li>
<li>8.69: <a href=#pg-9f6db6f1d6533ac11b51bd825e1be62e>Kubelet</a></li>
<li>8.70: <a href=#pg-6e971b5fddbc5b8e0cdb9a69368c7083>Kubernetes API</a></li>
<li>8.71: <a href=#pg-0fa467227ecce48e3e883303bd2b4005>Minikube</a></li>
<li>8.72: <a href=#pg-80b9cbe70574069fc9d473270758937d>Pod</a></li>
<li>8.73: <a href=#pg-c10a0e9fe6b2de73d4a15c380271f772>Pod 安全策略</a></li>
<li>8.74: <a href=#pg-4a4f0f9e529711cbdb049801f494c748>Pod 水平自动扩缩器（Horizontal Pod Autoscaler）</a></li>
<li>8.75: <a href=#pg-2a9824dad7ad96757a3c71cfb00833d0>ReplicaSet</a></li>
<li>8.76: <a href=#pg-021c1f4865a3852aa3544b78aec45d31>Secret</a></li>
<li>8.77: <a href=#pg-bb9ede0a335784b94951926f1102b805>ServiceAccount</a></li>
<li>8.78: <a href=#pg-e741e799da64cc349e110ec1db42573d>StatefulSet</a></li>
<li>8.79: <a href=#pg-b1937d67fd85a24f8674799b2a1dc9fb>StorageClass</a></li>
<li>8.80: <a href=#pg-fe62cb4c48d83dcbf90bcacf80117421>UID</a></li>
<li>8.81: <a href=#pg-74e212a8b337e50e8de05ba51f71e504>上游（Uptream）</a></li>
<li>8.82: <a href=#pg-f41885f16367636b904b2b0927921c1f>下游（Downstream）</a></li>
<li>8.83: <a href=#pg-cda915385837093852ddd2c06e148a24>云供应商（Cloud Provider）</a></li>
<li>8.84: <a href=#pg-66c12ebc789eac3487b595c037607155>云控制器管理器（Cloud Controller Manager）</a></li>
<li>8.85: <a href=#pg-30381eda196d48d1e5a45b654c75293d>代码贡献者（Code Contributor）</a></li>
<li>8.86: <a href=#pg-ebb1e8c2889455c952d370cac3cd0a27>初始化容器（Init Container）</a></li>
<li>8.87: <a href=#pg-04e79c3afe3f30f5d8fe0b28308fb1ee>副本控制器（Replication Controller）</a></li>
<li>8.88: <a href=#pg-0c8032e77dd004415eb1a1e325441378>动态卷供应（Dynamic Volume Provisioning）</a></li>
<li>8.89: <a href=#pg-2f808ec7c92adb4e59947569223aa522>卷插件（Volume Plugin）</a></li>
<li>8.90: <a href=#pg-15ca85091fc8c2d69131be0f17e74019>卷（Volume）</a></li>
<li>8.91: <a href=#pg-ca9e31c41b1c901c2778067b5ceab269>名字空间（Namespace）</a></li>
<li>8.92: <a href=#pg-8a24389d4844af7a5756df688cb928c0>名称（Name）</a></li>
<li>8.93: <a href=#pg-fc098dfd608da29022cd66a83a2cef1f>周期调度任务（CronJob）</a></li>
<li>8.94: <a href=#pg-722af529138120fa4a972487c534417e>基于角色的访问控制（RBAC）</a></li>
<li>8.95: <a href=#pg-fa8762f5ea277f2db3d11f9c814d3449>安全上下文（Security Context）</a></li>
<li>8.96: <a href=#pg-6e01ab45bd20c0c9fb89a30734f1dd81>容器环境变量（Container Environment Variables）</a></li>
<li>8.97: <a href=#pg-469e9bf3a6e2144d4d785d7e372180f7>容器（Container）</a></li>
<li>8.98: <a href=#pg-84e954e0f04e64ed39ee82a1cb081e6f>工作组（Working Group，WG）</a></li>
<li>8.99: <a href=#pg-7d314c50ed2a11d1ec451dd074a7c9d2>平台开发人员（Platform Developer）</a></li>
<li>8.100: <a href=#pg-6f86f5c1145b928427953057f06efe7e>应用开发者（Application Developer）</a></li>
<li>8.101: <a href=#pg-910283b40d8346d8f9742728a6cf64b5>应用架构师（Application Architect）</a></li>
<li>8.102: <a href=#pg-51228bcff4c2e9508f49024e7399c5ef>开发者（Developer）</a></li>
<li>8.103: <a href=#pg-b4e55b971b739aefdf0f3398cf4cbd05>成员（Member）</a></li>
<li>8.104: <a href=#pg-d7206a4063f74f85bff402fb2905e66d>托管服务</a></li>
<li>8.105: <a href=#pg-a7518a3ffe530f1bb40490e1869bab74>批准者（Approver）</a></li>
<li>8.106: <a href=#pg-e49264feb3ad250f4280b7ac3c78c8ef>持久卷申领（Persistent Volume Claim）</a></li>
<li>8.107: <a href=#pg-7b33702ae376d8e7de5839456f8f3575>持久卷（Persistent Volume）</a></li>
<li>8.108: <a href=#pg-029c2d22105ac3f6911d74fc7d5b538b>控制器（Controller）</a></li>
<li>8.109: <a href=#pg-125cc2f883615d755ddda13bdbe1fdac>服务代理（Service Broker）</a></li>
<li>8.110: <a href=#pg-702df2603337611e5fd35b37bca45e10>服务目录（Service Catalog）</a></li>
<li>8.111: <a href=#pg-76a15461212f4c6a93025e68202b15fd>服务（Service）</a></li>
<li>8.112: <a href=#pg-901e4c5de2ba8dfaf9632f200c599537>标签（Label）</a></li>
<li>8.113: <a href=#pg-c0942b17e9469578411bbc091a0c8125>注解（Annotation）</a></li>
<li>8.114: <a href=#pg-04b892fa7f5902cbd3afa5da2a3b81e6>特别兴趣小组（SIG）</a></li>
<li>8.115: <a href=#pg-efa6404aa61ca93003cb14e37eef16f6>网络策略</a></li>
<li>8.116: <a href=#pg-8e6bdba5cb373983f4072e87b9e6daad>节点（Node）</a></li>
<li>8.117: <a href=#pg-405b9576a57a9cc2f9c4d3a0d0f38c91>证书（Certificate）</a></li>
<li>8.118: <a href=#pg-560a73dd2bb9cec8bbd1da18399af319>评审者（Reviewer）</a></li>
<li>8.119: <a href=#pg-4e8d4277f3d1f9b8b1f739d5d3788758>贡献者许可协议（CLA）</a></li>
<li>8.120: <a href=#pg-7994a3fa8dacca85f27af907c6a8a8b4>贡献者（Contributor）</a></li>
<li>8.121: <a href=#pg-5fe3da5ce19c797ae34184b232e0f489>资源配额（Resource Quotas）</a></li>
<li>8.122: <a href=#pg-2455ffd7c42eab100b5ee18f8dfc45f2>选择算符（Selector）</a></li>
<li>8.123: <a href=#pg-fc02e65a1d95fac4d4bab5d69409a40a>镜像（Image）</a></li>
<li>8.124: <a href=#pg-aab941ab9aac7f6e34392580f667d906>集群操作者（Cluster Operator）</a></li>
<li>8.125: <a href=#pg-e637e8ec6c787aae6de7eaa601478b7b>集群架构师（Cluster Architect）</a></li>
</ul>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-18d58d2666f9af2b2086e0baa55f315d>1 - 简介</h1>
<p>本页为您介绍 KLTS 的 Kubernetes 版本支持机制。<br>
<img src=../klts_ver.png width=300></p>
<p>如图所示，V1.16.15 是 Kubernetes 的完整发行版本号，其中 1.16 是大版本号，15 是社区补丁版本，而 lts.0 是 KLTS 的补丁版本号。</p>
<img src=../klts_job.png width=750>
<p>上图以 2021 年 8 月 31 日为例，当时的最新版本为 1.22，Kubernetes 社区仅维护 1.19 – 1.22 四个版本。而 KLTS 则提供从 1.10 到 1.18 的版本维护，每个版本的支持周期至少两年。其中 Kubernetes 1.10 是 DaoCloud Enterprise 3.0 的生产内核，其维护周期会相对更长。我们会将修复 bug 后的稳定版本上传至 KLTS，供社区下载使用。</p>
<p>Kubernetes 社区一般每隔 4 个月左右发布一个大版本，KLTS 维护的 Kubernetes 版本也会随之变化。通常在 Kubernetes 社区停止维护某个版本后的一个月内，KLTS 将开始维护刚被社区停止维护的版本。</p>
<p>例如，如果社区正式发布 1.23 版本，KLTS 维护的版本也会加一，达到 1.19，以此类推。KLTS 的补丁更新频率将根据实际解决的 bug 情况发布。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-50ddcb3cdb08fbe2ad5d04311c273b4c>2 - 安装准备</h1>
<p><img src=https://raw.githubusercontent.com/kubernetes/kubeadm/master/logos/stacked/color/kubeadm-stacked-color.png align=right width=150px>本页介绍如何安装 <code>kubeadm</code> 工具箱。
有关在执行此安装过程后如何使用 kubeadm 创建集群的信息，请参见<a href=/zh/docs/install target>安装步骤</a>。</p>
<h2 id=准备工作>准备工作</h2>
<ul>
<li>准备一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux
发行版以及一些不提供包管理器的发行版提供通用的指令。</li>
<li>每台主机至少 2 GB 或更多的内存（如果内存太少将影响应用的运行）</li>
<li>CPU 2 核或更多</li>
<li>集群中所有主机的网络连通（公网和内网）</li>
<li>单个节点上不能有重复的主机名、MAC 地址或 product_uuid，请参阅<a href=#verify-mac-address target>确保每个节点上 MAC 地址和 product_uuid 的唯一性</a>。</li>
<li>开启主机上的某些端口，请参阅<a href=#check-required-ports target>检查所需端口</a>。</li>
<li>禁用交换分区。为了保证 kubelet 正常工作，您<strong>必须</strong>禁用交换分区。</li>
</ul>
<h2 id=verify-mac-address>确保每个节点上 MAC 地址和 product_uuid 的唯一性 </h2>
<ul>
<li>使用命令 <code>ip link</code> 或 <code>ifconfig -a</code> 来获取网络接口的 MAC 地址</li>
<li>使用 <code>sudo cat /sys/class/dmi/id/product_uuid</code> 命令来校验 product_uuid</li>
</ul>
<p>一般来讲，硬件设备拥有唯一的地址，但是有些虚拟机的地址可能会重复。
Kubernetes 使用 MAC 地址和 product_uuid 来确定集群中的唯一节点。
如果这些值在每个节点上不唯一，可能会导致安装<a href=https://github.com/kubernetes/kubeadm/issues/31 target>失败</a>。</p>
<h2 id=检查网络适配器>检查网络适配器</h2>
<p>如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。</p>
<h2 id=允许-iptables-检查桥接流量>允许 iptables 检查桥接流量</h2>
<p>确保 <code>br_netfilter</code> 模块被加载。这一操作可以通过运行 <code>lsmod | grep br_netfilter</code>
来完成。若要显式加载该模块，可执行命令 <code>sudo modprobe br_netfilter</code>。</p>
<p>为了让您的 Linux 节点上的 iptables 能够正确地查看桥接流量，您需要确保在
<code>sysctl</code> 配置中将 <code>net.bridge.bridge-nf-call-iptables</code> 设置为 1。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
</span><span style=color:#4e9a06>br_netfilter
</span><span style=color:#4e9a06>EOF</span>

cat <span style=color:#4e9a06>&lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
</span><span style=color:#4e9a06>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#4e9a06>net.bridge.bridge-nf-call-iptables = 1
</span><span style=color:#4e9a06>EOF</span>
sudo sysctl --system
</code></pre></div><p>更多细节请查阅<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#network-plugin-requirements target>网络插件需求</a>页面。</p>
<h2 id=check-required-ports>检查所需端口</h2>
<h3 id=控制平面节点>控制平面节点</h3>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>作用</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>入站</td>
<td>6443</td>
<td>Kubernetes API 服务器</td>
<td>所有组件</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>2379-2380</td>
<td>etcd 服务器客户端 API</td>
<td>kube-apiserver、etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10250</td>
<td>Kubelet API</td>
<td>kubelet 自身、控制平面组件</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10251</td>
<td>kube-scheduler</td>
<td>kube-scheduler 自身</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10252</td>
<td>kube-controller-manager</td>
<td>kube-controller-manager 自身</td>
</tr>
</tbody>
</table>
<h3 id=工作节点>工作节点</h3>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>作用</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10250</td>
<td>Kubelet API</td>
<td>kubelet 自身、控制平面组件</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>30000-32767</td>
<td>NodePort 服务</td>
<td>所有组件</td>
</tr>
</tbody>
</table>
<p>以上是 <a href=https://kubernetes.io/zh/docs/concepts/services-networking/service/ target>NodePort 服务</a>的默认端口范围。</p>
<p>使用 * 标记的任意端口号都可以被覆盖，所以您需要保证定制的端口是开放的。</p>
<p>虽然控制平面节点已经包含了 etcd 的端口，您也可以使用自定义的外部 etcd 集群，或指定自定义端口。</p>
<p>您使用的 Pod 网络插件 (见下) 也可能需要某些特定端口开启。由于各个 Pod 网络插件都有所不同，请参阅相应文档中的端口要求。</p>
<h2 id=设置节点名字>设置节点名字</h2>
<p>命令的语法格式如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>hostnamectl set-hostname your-new-host-name
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;127.0.0.1 </span><span style=color:#204a87;font-weight:700>$(</span>hostname<span style=color:#204a87;font-weight:700>)</span><span style=color:#4e9a06>&#34;</span> &gt;&gt; /etc/hosts
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;::1       </span><span style=color:#204a87;font-weight:700>$(</span>hostname<span style=color:#204a87;font-weight:700>)</span><span style=color:#4e9a06>&#34;</span> &gt;&gt; /etc/hosts
</code></pre></div><h2 id=关闭-swap>关闭 Swap</h2>
<p>执行以下命令关闭 Swap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>swapoff -a
</code></pre></div><p>如果需要永久关闭，请编辑 <code>/etc/fstab</code> 文件，将 swap 的挂载路径改为注释。</p>
<h2 id=关闭-selinux>关闭 Selinux</h2>
<p>执行以下命令关闭 Selinux：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>setenforce <span style=color:#0000cf;font-weight:700>0</span>
</code></pre></div><p>如果需要永久关闭，请编辑 <code>/etc/sysconfig/selinux</code> 将 <code>SELINUX=enforcing</code> 替换为 <code>SELINUX=disabled</code>。</p>
<h2 id=installing-runtime>安装 runtime</h2>
<p>为了在 Pod 中运行容器，Kubernetes 使用容器运行时（Container Runtime）。</p>
<ul class="nav nav-tabs" id=container-runtimes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtimes-0 role=tab aria-controls=container-runtimes-0 aria-selected=true>Linux 节点</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtimes-1 role=tab aria-controls=container-runtimes-1>其它操作系统</a></li></ul>
<div class=tab-content id=container-runtimes><div id=container-runtimes-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtimes-0>
<p><p>默认情况下，Kubernetes 使用容器运行时接口（Container Runtime Interface，CRI）来与您所选择的容器运行时交互。</p>
<p>如果您不指定运行时，则 kubeadm 会自动尝试检测系统上已经安装的运行时，方法是扫描一组众所周知的 Unix 域套接字。</p>
<p>下面的表格列举了一些容器运行时及其对应的套接字路径：</p>
<table>
<thead>
<tr>
<th>运行时</th>
<th>域套接字</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker</td>
<td>/var/run/dockershim.sock</td>
</tr>
<tr>
<td>Containerd</td>
<td>/run/containerd/containerd.sock</td>
</tr>
<tr>
<td>CRI-O</td>
<td>/var/run/crio/crio.sock</td>
</tr>
</tbody>
</table>
<br>
如果同时检测到 Docker 和 Containerd，则优先选择 Docker。
这是必然的，即使您仅安装了 Docker，因为 Docker 18.09 附带了 Containerd，所以两者都是可以检测到的。
如果检测到其他两个或多个运行时，则 kubeadm 输出错误信息并退出。
<p>kubelet 通过内置的 <code>dockershim</code> CRI 实现与 Docker 集成。</p>
</div>
<div id=container-runtimes-1 class=tab-pane role=tabpanel aria-labelledby=container-runtimes-1>
<p><p>默认情况下， kubeadm 使用 docker 作为容器运行时。kubelet 通过内置的 <code>dockershim</code> CRI 实现与 Docker 集成。</p>
</div></div>
<ul class="nav nav-tabs" id=tabset-zhdocspre-install-3 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocspre-install-3-0 role=tab aria-controls=tabset-zhdocspre-install-3-0 aria-selected=true>Docker</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocspre-install-3-1 role=tab aria-controls=tabset-zhdocspre-install-3-1>Containerd</a></li></ul>
<div class=tab-content id=tabset-zhdocspre-install-3><div id=tabset-zhdocspre-install-3-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocspre-install-3-0>
<p>
<ul class="nav nav-tabs" id=tabset-zhdocspre-install-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocspre-install-2-0 role=tab aria-controls=tabset-zhdocspre-install-2-0 aria-selected=true>基于 Red Hat 的发行版</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocspre-install-2-1 role=tab aria-controls=tabset-zhdocspre-install-2-1>基于 Debian 的发行版</a></li></ul>
<div class=tab-content id=tabset-zhdocspre-install-2><div id=tabset-zhdocspre-install-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocspre-install-2-0>
<p><p>执行以下命令安装基于 Red Hat 发行版的 Docker：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>yum install docker
</code></pre></div></div>
<div id=tabset-zhdocspre-install-2-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocspre-install-2-1>
<p><p>执行以下命令安装基于 Debian 发行版的 Docker：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>apt-get install docker.io
</code></pre></div></div></div>
</div>
<div id=tabset-zhdocspre-install-3-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocspre-install-3-1>
<p><p>Containerd 官方默认只提供 amd64 架构的下载包，如果您采用的是其他基础架构，
可以从 Docker 官方仓库安装 <code>containerd.io</code> 软件包。在<a href=https://docs.docker.com/engine/install/#server target>安装 Docker 引擎</a>中
找到为各自的 Linux 发行版设置 Docker 存储库和安装 containerd.io 软件包的有关说明。</p>
<p>也可以使用以下源代码构建。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#000>VERSION</span><span style=color:#ce5c00;font-weight:700>=</span>1.5.4
wget -c https://github.com/containerd/containerd/releases/download/v<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>/containerd-<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>-linux-amd64.tar.gz
tar xvf containerd-<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>-linux-amd64.tar.gz -C /usr/local/
mkdir /etc/containerd/ <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> containerd config default &gt; /etc/containerd/config.toml
wget -c -O /etc/systemd/system/containerd.service https://raw.githubusercontent.com/containerd/containerd/main/containerd.service
systemctl start containerd <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> systemctl <span style=color:#204a87>enable</span> containerd
</code></pre></div></div></div>
<p>参阅<a href=https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/ target>容器运行时</a>以了解更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-64407d3e6d5ef382426bdfbcae040c6a>3 - 安装步骤</h1>
<p>KLTS 提供了基于 deb 和 rpm 软件源的安装方式，您可以选择适合的安装方式。</p>
<p>安装前请确认已经完成了<a href=/zh/docs/pre-install target>安装准备</a>的安装。</p>
<h2 id=设置-klts-软件源>设置 KLTS 软件源</h2>
<ul class="nav nav-tabs" id=tabset-zhdocsinstall-3 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsinstall-3-0 role=tab aria-controls=tabset-zhdocsinstall-3-0 aria-selected=true>基于 Red Hat 的发行版</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-3-1 role=tab aria-controls=tabset-zhdocsinstall-3-1>基于 Debian 的发行版</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-3-2 role=tab aria-controls=tabset-zhdocsinstall-3-2>基于 Red Hat 的发行版, 国内加速 🚀</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-3-3 role=tab aria-controls=tabset-zhdocsinstall-3-3>基于 Debian 的发行版, 国内加速 🚀</a></li></ul>
<div class=tab-content id=tabset-zhdocsinstall-3><div id=tabset-zhdocsinstall-3-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsinstall-3-0>
<p><p>执行以下代码设置下载 KLTS 的软件源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; \EOF &gt; /etc/yum.repos.d/klts.repo
</span><span style=color:#4e9a06>[klts]
</span><span style=color:#4e9a06>name=klts
</span><span style=color:#4e9a06>baseurl=https://dl.klts.io/rpm/$basearch/
</span><span style=color:#4e9a06>enabled=1
</span><span style=color:#4e9a06>gpgcheck=0
</span><span style=color:#4e9a06>EOF</span>

yum makecache
</code></pre></div></div>
<div id=tabset-zhdocsinstall-3-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-3-1>
<p><p>执行以下代码设置下载 KLTS 的软件源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; EOF &gt; /etc/apt/sources.list.d/klts.list
</span><span style=color:#4e9a06>deb [trusted=yes] https://dl.klts.io/deb stable main
</span><span style=color:#4e9a06>EOF</span>

apt-get update
</code></pre></div></div>
<div id=tabset-zhdocsinstall-3-2 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-3-2>
<p>
<strong>说明：</strong>以下加速均来自第三方, 安全和稳定性不做保障, 仅建议测试环境使用 ❗️❗️❗️ <br><br>
执行以下代码设置下载 KLTS 的软件源：
<ul class="nav nav-tabs" id=tabset-zhdocsinstall-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsinstall-1-0 role=tab aria-controls=tabset-zhdocsinstall-1-0 aria-selected=true>/etc/hosts</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-1-1 role=tab aria-controls=tabset-zhdocsinstall-1-1>hub.fastgit.org</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-1-2 role=tab aria-controls=tabset-zhdocsinstall-1-2>ghproxy.com</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-1-3 role=tab aria-controls=tabset-zhdocsinstall-1-3>raw.githubusercontents.com</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-1-4 role=tab aria-controls=tabset-zhdocsinstall-1-4>raw.staticdn.net</a></li></ul>
<div class=tab-content id=tabset-zhdocsinstall-1><div id=tabset-zhdocsinstall-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsinstall-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl https://raw.githubusercontent.com/wzshiming/github-hosts/master/hosts &gt;&gt;/etc/hosts

cat <span style=color:#4e9a06>&lt;&lt; \EOF &gt; /etc/yum.repos.d/klts.repo
</span><span style=color:#4e9a06>[klts]
</span><span style=color:#4e9a06>name=klts
</span><span style=color:#4e9a06>baseurl=https://dl.klts.io/rpm/$basearch/
</span><span style=color:#4e9a06>enabled=1
</span><span style=color:#4e9a06>gpgcheck=0
</span><span style=color:#4e9a06>EOF</span>

yum makecache
</code></pre></div></div>
<div id=tabset-zhdocsinstall-1-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; \EOF &gt; /etc/yum.repos.d/klts.repo
</span><span style=color:#4e9a06>[klts]
</span><span style=color:#4e9a06>name=klts
</span><span style=color:#4e9a06>baseurl=https://hub.fastgit.org/klts-io/kubernetes-lts/raw/repos/rpm/$basearch/
</span><span style=color:#4e9a06>enabled=1
</span><span style=color:#4e9a06>gpgcheck=0
</span><span style=color:#4e9a06>EOF</span>

yum makecache
</code></pre></div></div>
<div id=tabset-zhdocsinstall-1-2 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-1-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; \EOF &gt; /etc/yum.repos.d/klts.repo
</span><span style=color:#4e9a06>[klts]
</span><span style=color:#4e9a06>name=klts
</span><span style=color:#4e9a06>baseurl=https://ghproxy.com/https://raw.githubusercontent.com/klts-io/kubernetes-lts/repos/rpm/$basearch/
</span><span style=color:#4e9a06>enabled=1
</span><span style=color:#4e9a06>gpgcheck=0
</span><span style=color:#4e9a06>EOF</span>

yum makecache
</code></pre></div></div>
<div id=tabset-zhdocsinstall-1-3 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-1-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; \EOF &gt; /etc/yum.repos.d/klts.repo
</span><span style=color:#4e9a06>[klts]
</span><span style=color:#4e9a06>name=klts
</span><span style=color:#4e9a06>baseurl=https://raw.githubusercontents.com/klts-io/kubernetes-lts/repos/rpm/$basearch/
</span><span style=color:#4e9a06>enabled=1
</span><span style=color:#4e9a06>gpgcheck=0
</span><span style=color:#4e9a06>EOF</span>

yum makecache
</code></pre></div></div>
<div id=tabset-zhdocsinstall-1-4 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-1-4>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; \EOF &gt; /etc/yum.repos.d/klts.repo
</span><span style=color:#4e9a06>[klts]
</span><span style=color:#4e9a06>name=klts
</span><span style=color:#4e9a06>baseurl=https://raw.staticdn.net/klts-io/kubernetes-lts/repos/rpm/$basearch/
</span><span style=color:#4e9a06>enabled=1
</span><span style=color:#4e9a06>gpgcheck=0
</span><span style=color:#4e9a06>EOF</span>

yum makecache
</code></pre></div></div></div>
</div>
<div id=tabset-zhdocsinstall-3-3 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-3-3>
<p>
<strong>说明：</strong>以下加速均来自第三方, 安全和稳定性不做保障, 仅建议测试环境使用 ❗️❗️❗️<br><br>
执行以下代码设置下载 KLTS 的软件源：
<ul class="nav nav-tabs" id=tabset-zhdocsinstall-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsinstall-2-0 role=tab aria-controls=tabset-zhdocsinstall-2-0 aria-selected=true>/etc/hosts</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-2-1 role=tab aria-controls=tabset-zhdocsinstall-2-1>hub.fastgit.org</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-2-2 role=tab aria-controls=tabset-zhdocsinstall-2-2>ghproxy.com</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-2-3 role=tab aria-controls=tabset-zhdocsinstall-2-3>raw.githubusercontents.com</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-2-4 role=tab aria-controls=tabset-zhdocsinstall-2-4>raw.staticdn.net</a></li></ul>
<div class=tab-content id=tabset-zhdocsinstall-2><div id=tabset-zhdocsinstall-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsinstall-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl https://raw.githubusercontent.com/wzshiming/github-hosts/master/hosts &gt;&gt;/etc/hosts

cat <span style=color:#4e9a06>&lt;&lt; EOF &gt; /etc/apt/sources.list.d/klts.list
</span><span style=color:#4e9a06>deb [trusted=yes] https://dl.klts.io/deb stable main
</span><span style=color:#4e9a06>EOF</span>

apt-get update
</code></pre></div></div>
<div id=tabset-zhdocsinstall-2-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; EOF &gt; /etc/apt/sources.list.d/klts.list
</span><span style=color:#4e9a06>deb [trusted=yes] https://hub.fastgit.org/klts-io/kubernetes-lts/raw/repos/deb stable main
</span><span style=color:#4e9a06>EOF</span>

apt-get update
</code></pre></div></div>
<div id=tabset-zhdocsinstall-2-2 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-2-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; EOF &gt; /etc/apt/sources.list.d/klts.list
</span><span style=color:#4e9a06>deb [trusted=yes] https://ghproxy.com/https://raw.githubusercontent.com/klts-io/kubernetes-lts/repos/deb stable main
</span><span style=color:#4e9a06>EOF</span>

apt-get update
</code></pre></div></div>
<div id=tabset-zhdocsinstall-2-3 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-2-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; EOF &gt; /etc/apt/sources.list.d/klts.list
</span><span style=color:#4e9a06>deb [trusted=yes] https://raw.githubusercontents.com/klts-io/kubernetes-lts/repos/deb stable main
</span><span style=color:#4e9a06>EOF</span>

apt-get update
</code></pre></div></div>
<div id=tabset-zhdocsinstall-2-4 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-2-4>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#4e9a06>&lt;&lt; EOF &gt; /etc/apt/sources.list.d/klts.list
</span><span style=color:#4e9a06>deb [trusted=yes] https://raw.staticdn.net/klts-io/kubernetes-lts/repos/deb stable main
</span><span style=color:#4e9a06>EOF</span>

apt-get update
</code></pre></div></div></div>
</div></div>
<h2 id=安装>安装</h2>
<ul class="nav nav-tabs" id=tabset-zhdocsinstall-6 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsinstall-6-0 role=tab aria-controls=tabset-zhdocsinstall-6-0 aria-selected=true>安装最高版本</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-6-1 role=tab aria-controls=tabset-zhdocsinstall-6-1>安装指定版本</a></li></ul>
<div class=tab-content id=tabset-zhdocsinstall-6><div id=tabset-zhdocsinstall-6-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsinstall-6-0>
<p>
<br>这里的最高版本指的是 KLTS 维护的最高版本。
<ul class="nav nav-tabs" id=tabset-zhdocsinstall-4 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsinstall-4-0 role=tab aria-controls=tabset-zhdocsinstall-4-0 aria-selected=true>基于 Red Hat 的发行版</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-4-1 role=tab aria-controls=tabset-zhdocsinstall-4-1>基于 Debian 的发行版</a></li></ul>
<div class=tab-content id=tabset-zhdocsinstall-4><div id=tabset-zhdocsinstall-4-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsinstall-4-0>
<p><p>执行以下命令开始安装：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>yum install kubeadm kubelet kubectl
</code></pre></div></div>
<div id=tabset-zhdocsinstall-4-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-4-1>
<p><p>执行以下命令开始安装：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>apt-get install kubeadm kubelet kubectl
</code></pre></div></div></div>
</div>
<div id=tabset-zhdocsinstall-6-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-6-1>
<p>
<ul class="nav nav-tabs" id=tabset-zhdocsinstall-5 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsinstall-5-0 role=tab aria-controls=tabset-zhdocsinstall-5-0 aria-selected=true>基于 Red Hat 的发行版</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsinstall-5-1 role=tab aria-controls=tabset-zhdocsinstall-5-1>基于 Debian 的发行版</a></li></ul>
<div class=tab-content id=tabset-zhdocsinstall-5><div id=tabset-zhdocsinstall-5-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsinstall-5-0>
<p><p>执行以下命令进行安装：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 搜索支持的版本</span>
yum search kubeadm --showduplicates <span style=color:#000;font-weight:700>|</span> grep kubeadm-

<span style=color:#8f5902;font-style:italic># 安装</span>
<span style=color:#000>VERSION</span><span style=color:#ce5c00;font-weight:700>=</span>1.18.20-lts.0
yum install kubeadm-v<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span> kubelet-v<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span> kubectl-v<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>
</code></pre></div></div>
<div id=tabset-zhdocsinstall-5-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsinstall-5-1>
<p><p>执行以下命令进行安装：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic># 搜索支持的版本</span>
apt-cache show kubeadm <span style=color:#000;font-weight:700>|</span> grep Version

<span style=color:#8f5902;font-style:italic># 安装</span>
<span style=color:#000>VERSION</span><span style=color:#ce5c00;font-weight:700>=</span>1.18.20-lts.0
apt-get install <span style=color:#000>kubeadm</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span> <span style=color:#000>kubelet</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span> <span style=color:#000>kubectl</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>
</code></pre></div></div></div>
</div></div>
<h2 id=开机自动启动-kubelet>开机自动启动 Kubelet</h2>
<p>执行以下命令开机自动启动 Kubelet：</p>
<pre><code>systemctl enable kubelet
</code></pre><h2 id=拉取依赖镜像>拉取依赖镜像</h2>
<p>执行以下命令 pull 依赖的镜像：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#000>VERSION</span><span style=color:#ce5c00;font-weight:700>=</span>1.18.20-lts.0
<span style=color:#000>REPOS</span><span style=color:#ce5c00;font-weight:700>=</span>ghcr.io/klts-io/kubernetes-lts
kubeadm config images pull --image-repository <span style=color:#4e9a06>${</span><span style=color:#000>REPOS</span><span style=color:#4e9a06>}</span> --kubernetes-version v<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>
</code></pre></div><p>后续对 kubeadm 的操作都需要加上 <code>--image-repository</code>，<code>--kubernetes-version</code> 主动指定镜像。</p>
<h2 id=初始化控制面节点>初始化控制面节点</h2>
<p>执行以下命令初始化控制面的节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#000>VERSION</span><span style=color:#ce5c00;font-weight:700>=</span>1.18.20-lts.0
<span style=color:#000>REPOS</span><span style=color:#ce5c00;font-weight:700>=</span>ghcr.io/klts-io/kubernetes-lts
kubeadm init --image-repository <span style=color:#4e9a06>${</span><span style=color:#000>REPOS</span><span style=color:#4e9a06>}</span> --kubernetes-version v<span style=color:#4e9a06>${</span><span style=color:#000>VERSION</span><span style=color:#4e9a06>}</span>
</code></pre></div><p>有关更多安装说明，请参阅<a href=https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/ target>Kubernetes 操作指南</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c258a50dfe331dfdf852330040bd8f14>4 - 安装之后</h1>
<p>TODO</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cf1a7e96c5bc452942429f7b1a8d0306>5 - 补丁</h1>
</div>
<div class=td-content>
<h1 id=pg-fa6c26ffb59581078942a7046be853db>5.1 - CVE-2019-1002101</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-1002101 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
此漏洞可能允许攻击者利用 <code>kubectl cp</code> 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。
</div>
<h2 id=scope>漏洞影响</h2>
<p><code>kubectl cp</code> 命令允许用户在容器和用户机器之间拷贝文件，攻击者可能通过在镜像或运行容器中植入带有符号链接（symbolic links）头的恶意 <code>tar</code> 包，在 <code>cp</code> 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.14.1</li>
<li>1.13.6</li>
<li>1.12.8</li>
<li>1.11.10</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-1002101.1.10.patch target>CVE-2019-1002101.1.10.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-678704d1c81cba20ab7f9af62e484052>5.2 - CVE-2019-11245</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-11245 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
这是一个提权漏洞，在通常情况下以容器 <code>Dockerfile</code> 中指定的 <code>USER</code> 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 <code>root</code>(uid 0) 身份运行
</div>
<h2 id=scope>漏洞影响</h2>
<p>所有未指定 <code>mustRunAsNonRoot: true</code> 的 <code>Pod</code>，在容器重启时或者如果镜像先前被拉到节点时，都将以 <code>root</code>(uid 0) 身份运行。</p>
<h2 id=prevention>防范措施</h2>
<p>为 <code>Pod</code> 指定 <code>mustRunAsNonRoot: true</code></p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.14.3</li>
<li>1.13.7</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.12.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/78320.patch target>kubernetes/kubernetes#78320</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/78320.patch target>kubernetes/kubernetes#78320</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/78320.patch target>kubernetes/kubernetes#78320</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-17adf9e532c044f0bc96bf2fe6fabb70>5.3 - CVE-2019-11246</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-11246 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
此漏洞可能允许攻击者利用 <code>kubectl cp</code> 命令，采用路径遍历(Path Traversal)的方式将容器 <code>tar</code> 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。
</div>
<h2 id=scope>漏洞影响</h2>
<p>该漏洞与不久前的 <a href=/zh/docs/patches/cve-2019-1002101 title="此漏洞可能允许攻击者利用 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。" data-toggle=tooltip data-placement=top target>CVE-2019-1002101</a> 漏洞影响相似。</p>
<p><code>kubectl cp</code> 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，<code>Kubernetes</code> 会首先在容器中执行 <code>tar</code> 命令创建相应的归档文件，然后发送给客户端，<code>kubectl</code> 会在用户主机上进行相应解压操作。</p>
<p>如果容器 <code>tar</code> 包中包含恶意文件，当攻击者具有 <code>kubectl cp</code> 命令的执行权限时，可以利用路径遍历(Path Traversal)。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.14.3</li>
<li>1.13.7</li>
<li>1.12.10</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11246.1.11.patch target>CVE-2019-11246.1.11.patch</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11246.1.10.patch target>CVE-2019-11246.1.10.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d902d3ffd5b3d43bf94a51814ab569c7>5.4 - CVE-2019-11247</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-11247 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
<code>API Server</code> 允许通过错误的范围访问自定义的资源
</div>
<h2 id=scope>漏洞影响</h2>
<p>如果发出的请求与资源的名称空间相同，则此漏洞允许访问集群范围的自定义的资源。以这种方式访问的资源的授权是使用命名空间内的角色和角色绑定强制执行的，这意味着能访问一个命名空间中的资源，可以进行创建，查看更新或删除群集范围的资源（根据其命名空间角色权限）。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.12.12</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11247.1.11.patch target>CVE-2019-11247.1.11.patch</a></li>
<li>1.10.13-lts.1 TODO</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-da5de8654ce647927106ce1dae3b6382>5.5 - CVE-2019-11248</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-11248 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
可以用过健康检查的端口访问 <code>/debug/pprof</code>
</div>
<h2 id=scope>漏洞影响</h2>
<p>该漏洞存在于 <code>Kubelet</code> 中，由于用于性能调试的 <code>/debug/pprof</code> 跟健康检查端口 <code>/healthz</code> 绑定在一起 <code>/debug/pprof</code> 会进行安全认证，但 <code>/healthz</code>接口是不认证鉴权的。所以，如果 <code>Kubelet</code> 的 <code>healthz</code> 地址不是使用 <code>localhost</code>，会存在泄露机器敏感信息的风险。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.14.4</li>
<li>1.13.8</li>
<li>1.12.10</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11248.1.11.patch target>CVE-2019-11248.1.11.patch</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11248.1.11.patch target>CVE-2019-11248.1.11.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9677918ea7ce2b1d4116bfb9d4d31512>5.6 - CVE-2019-11249</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-11249 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
此漏洞可能允许攻击者利用 <code>kubectl cp</code> 命令，采用路径遍历(Path Traversal)的方式将容器 <code>tar</code> 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。
</div>
<h2 id=scope>漏洞影响</h2>
<p>该漏洞与不久前的 <a href=/zh/docs/patches/cve-2019-1002101 title="此漏洞可能允许攻击者利用 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。" data-toggle=tooltip data-placement=top target>CVE-2019-1002101</a>, <a href=/zh/docs/patches/cve-2019-11246 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11246</a> 漏洞影响相似。</p>
<p><code>kubectl cp</code> 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，<code>Kubernetes</code> 会首先在容器中执行 <code>tar</code> 命令创建相应的归档文件，然后发送给客户端，<code>kubectl</code> 会在用户主机上进行相应解压操作。</p>
<p>如果容器 <code>tar</code> 包中包含恶意文件，当攻击者具有 <code>kubectl cp</code> 命令的执行权限时，可以利用路径遍历(Path Traversal)。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.15.2</li>
<li>1.14.5</li>
<li>1.13.9</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.12.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11249.1.12.patch target>CVE-2019-11249.1.12.patch</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11249.1.12.patch target>CVE-2019-11249.1.12.patch</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11249.1.10.patch target>CVE-2019-11249.1.10.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3bb42a6493fbd1d3d06aad85c3d8d1e7>5.7 - CVE-2019-11251</h1>
<a href=https://www.cvedetails.com/cve/CVE-2019-11251 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
此漏洞可能允许攻击者利用 <code>kubectl cp</code> 命令，采用路径遍历(Path Traversal)的方式将容器 <code>tar</code> 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。
</div>
<h2 id=scope>漏洞影响</h2>
<p>该漏洞与不久前的 <a href=/zh/docs/patches/cve-2019-1002101 title="此漏洞可能允许攻击者利用 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。" data-toggle=tooltip data-placement=top target>CVE-2019-1002101</a>, <a href=/zh/docs/patches/cve-2019-11246 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11246</a>, <a href=/zh/docs/patches/cve-2019-11249 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11249</a> 漏洞影响相似。</p>
<p><code>kubectl cp</code> 命令用于用户容器和主机之间的文件拷贝，当从容器中拷贝文件时，<code>Kubernetes</code> 会首先在容器中执行 <code>tar</code> 命令创建相应的归档文件，然后发送给客户端，<code>kubectl</code> 会在用户主机上进行相应解压操作。</p>
<p>如果容器 <code>tar</code> 包中包含恶意文件，当攻击者具有 <code>kubectl cp</code> 命令的执行权限时，可以利用路径遍历(Path Traversal)。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.15.4</li>
<li>1.14.7</li>
<li>1.13.11</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.12.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/82503.patch target>kubernetes/kubernetes#82503</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/82503.patch target>kubernetes/kubernetes#82503</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2019-11251.1.10.patch target>CVE-2019-11251.1.10.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c1ec3633b18a80bee04f17816082420b>5.8 - CVE-2020-8552</h1>
<a href=https://www.cvedetails.com/cve/CVE-2020-8552 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
此漏洞可能使 <code>API Server</code> 容易受到来自成功 <code>API</code> 请求的 <code>DoS</code>(拒绝服务攻击)。
</div>
<h2 id=scope>漏洞影响</h2>
<p><code>API Server</code> 容易受到来自成功 <code>API</code> 请求的 <code>DoS</code>(拒绝服务攻击)。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.17.3</li>
<li>1.16.7</li>
<li>1.15.10</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.14.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8552.1.14.patch target>CVE-2020-8552.1.14.patch</a></li>
<li>1.13.12-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8552.1.13.patch target>CVE-2020-8552.1.13.patch</a></li>
<li>1.12.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8552.1.13.patch target>CVE-2020-8552.1.13.patch</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8552.1.11.patch target>CVE-2020-8552.1.11.patch</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8552.1.11.patch target>CVE-2020-8552.1.11.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5aa68ad2e414f83fec8b9beb2250fdd3>5.9 - CVE-2020-8558</h1>
<a href=https://www.cvedetails.com/cve/CVE-2020-8558 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
<code>kube-proxy</code> 组件在 <code>iptables</code> 和 <code>ipvs</code> 模式下均需要设置内核参数 <code>net.ipv4.conf.all.route_localnet=1</code>， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 <code>127.0.0.1</code> 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。
</div>
<h2 id=scope>漏洞影响</h2>
<p>当攻击者拥有主机网络配置能力或运行在一个具备了 <code>CAP_NET_RAW</code> 能力的容器实例时，就可以获取在目标节点上监听了 <code>127.0.0.1</code> 的服务 <code>socket</code> 信息。如果在目标主机上存在 <code>127.0.0.1</code> 可以访问到且不需要任何认证鉴权的暴露服务，那么该服务信息就能被攻击者获取。</p>
<h3 id=cvss>漏洞评分</h3>
<ul>
<li>如果集群 <code>API Server</code> 开启了非认证端口（默认8080），那么攻击者可能获取到 <code>API Server</code> 接口相关信息，威胁等级为高危漏洞，评分为8.8分。</li>
<li>如果集群 <code>API Server</code> 默认关闭了非认证端口，威胁等级为中危漏洞，评分为5.4分。</li>
</ul>
<h2 id=prevention>防范措施</h2>
<p>建议您采取以下安全防范措施：</p>
<p>如果业务容器需使用主机网络模式且又监听在非安全端口上，可以通过在节点上手动添加 <code>iptables</code> 规则来缓解此漏洞。
执行以下命令，在集群中配置 <code>iptables</code> 规则，用于拒绝非本地对 <code>127.0.0.1</code> 的访问流量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>iptables -I INPUT --dst 127.0.0.0/8 ! --src 127.0.0.0/8 -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP
</code></pre></div><p>如果集群不需要开启API Server 不安全端口，可以将 &ndash;insecure-port=0 添加到 kubernetes API 服务器命令行来禁用端口。</p>
<p>如集群内运行有不受信的容器，可以禁止 <code>Container</code> 开启 <code>CAP_NET_RAW</code> 能力，可以在 <code>pod spec</code> 中关闭 <code>Container</code> 的 <code>CAP_NET_RAW</code> 能力。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>securityContext</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>capabilities</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>drop</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> 
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#4e9a06>&#34;NET_RAW&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>通过 <code>PodSecurityPolicy</code> 策略限制部署特权或共享主机网络容器，另外可以通过在策略中配置 <code>requiredDropCapabilities</code> 强制容器部署关闭 <code>CAP_NET_RAW</code> 能力。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.18.4</li>
<li>1.17.7</li>
<li>1.16.11</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.15.12-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/92040.patch target>kubernetes/kubernetes#92040</a></li>
<li>1.14.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/92040.patch target>kubernetes/kubernetes#92040</a></li>
<li>1.13.12-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/92040.patch target>kubernetes/kubernetes#92040</a></li>
<li>1.12.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8558.1.12.patch target>CVE-2020-8558.1.12.patch</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/CVE-2020-8558.1.12.patch target>CVE-2020-8558.1.12.patch</a></li>
<li>1.10.13-lts.1 TODO</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ce240d314dc85c8ab698d26f1466e5a2>5.10 - CVE-2020-8559</h1>
<a href=https://www.cvedetails.com/cve/CVE-2020-8559 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
<code>kube-apiserver</code> 组件的安全漏洞，攻击者可以通过截取某些发送至节点 <code>kubelet</code> 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。
</div>
<h2 id=scope>漏洞影响</h2>
<p>由于 <code>kube-apiserver</code> 中在升级请求的代理后端中允许将请求传播回源客户端，攻击者可以通过截取某些发送至节点 <code>kubelet</code> 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成被攻击节点的权限提升漏洞。</p>
<h3 id=cvss>漏洞评分</h3>
<p>该漏洞为中危漏洞， <code>CVSS</code> 评分为6.4。
如果有多个集群共享使用了相同的 <code>CA</code> 和认证凭证，攻击者可以利用此漏洞攻击其他集群，这种情况下该漏洞为高危漏洞。</p>
<h2 id=prevention>防范措施</h2>
<p>对于集群内跨节点的攻击，建议您采取以下安全防范措施：</p>
<ul>
<li>及时吊销可能泄露的 <code>kubeconfig</code> 凭证，并且遵循权限最小化原则，收敛子账号不必要的 <code>pods/exec</code>、<code>pods/attach</code>、<code>pods/portforward</code>和 <code>proxy</code> 类型的资源模型 <code>RBAC</code> 权限。</li>
</ul>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.18.6</li>
<li>1.17.9</li>
<li>1.16.13</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.15.12-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/92971.patch target>kubernetes/kubernetes#92971</a></li>
<li>1.14.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/92971.patch target>kubernetes/kubernetes#92971</a></li>
<li>1.13.12-lts.1 TODO</li>
<li>1.12.10-lts.1 TODO</li>
<li>1.11.10-lts.1 TODO</li>
<li>1.10.13-lts.1 TODO</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d4317cf8912bca37373fe5558d2d6285>5.11 - CVE-2021-3121</h1>
<a href=https://www.cvedetails.com/cve/CVE-2021-3121 target>详细信息</a>
<div class="pageinfo pageinfo-primary">
存在该漏洞的程序可能会因为处理了包含恶意 <code>Protobuf</code> 消息而崩溃。如果您使用的 <code>Gogo Protobuf</code> 版本过低，可能存在该漏洞。
</div>
<h2 id=scope>漏洞影响</h2>
<p><code>Kubernetes</code> 系统组件由于自身有应对崩溃的恢复机制，当遇到恶意提交的 <code>Protobuf</code> 消息时不会中断服务，所以不在该漏洞的影响范围内。</p>
<p>在应用系统中程序接收处理 <code>Protobuf</code> 消息时，如果组件没有应对崩溃的恢复机制，那么这类程序都在该漏洞影响范围内，且被恶意攻击时服务可能会中断。</p>
<p><code>Kubernetes</code> 社区经过测试验证 <code>API Server</code> 不受该漏洞的影响，但为了避免您受到该安全漏洞隐患的影响，社区对相关 <code>Protobuf</code> 文件进行了升级，具体修复版本如下:</p>
<h2 id=prevention>防范措施</h2>
<p>如果在您的应用系统代码中使用了自动生成的 <code>Protobuf</code> 消息，并且发现相关组件因为以下异常退出，则可能存在该漏洞。</p>
<pre><code>panic: runtime error: index out of range [-9223372036854775804]

goroutine 1 [running]:

v1.(*MessageName).Unmarshal(0xc00006f1e8, 0xc0000281a8, 0xa, 0x10, 0xc00006f1b8, 0x1)

        .../protofile.pb.go:250 +0xb86
</code></pre><p>如果您使用了 <code>Protobuf</code> 消息的相关组件，推荐将 <code>Gogo Protobuf</code> 编译器升级到漏洞修复版本（v1.3.2或更高的版本），再基于升级后的Protobuf<code>编译器重新生成相关的</code>Protobuf` 消息。</p>
<h2 id=official-fixed>官方修复的版本</h2>
<ul>
<li>1.21: 1.21.1</li>
<li>1.20: 1.20.7</li>
<li>1.19: 1.19.11</li>
<li>1.18.19</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.17.17-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.16.15-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.15.12-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.14.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.13.12-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.12.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/kubernetes/kubernetes/pull/101327.patch target>kubernetes/kubernetes#101327</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66481705776642cc7da302c2a84c2907>5.12 - nokmem</h1>
<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1507149" target>详细信息</a>
<div class="pageinfo pageinfo-primary">
节点磁盘充足但是一直报磁盘不足无法创建 <code>Pod</code>
</div>
<h2 id=scope>Bug 影响</h2>
<p>节点长期使用的时候提示剩余空间不足的错误，具体如下所示：</p>
<pre><code>mkdir: cannot create directory '/sys/fs/cgroup/memory/8': No space left on device
</code></pre><p>节点磁盘充足但是一直报和这个错误, 并且创建 <code>Pod</code> 总是失败，这是一个潜在的“定时炸弹”。</p>
<p>所有使用低版本内核的环境，k8s 1.22 之前的版本都受到影响, 在 runc 1.0.0-rc94 (<a href=https://github.com/opencontainers/runc/pull/2840 target>opencontainers/runc#2840</a>) 修复(直接移除了)</p>
<h2 id=prevention>防范措施</h2>
<ul>
<li>升级系统内核</li>
<li>k8s 1.14 及以上
<ul>
<li>重新构建 Kubelet 带上 <code>-tags=nokmem</code></li>
</ul>
</li>
<li>k8s 1.14 以下
<ul>
<li>硬编码, 可以参考 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.13.patch target>nokmem.1.13.patch</a></li>
</ul>
</li>
</ul>
<h2 id=klts-fixed>KLTS 修复的版本</h2>
<ul>
<li>1.18.20-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.18.patch target>nokmem.1.18.patch</a></li>
<li>1.17.17-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.18.patch target>nokmem.1.18.patch</a></li>
<li>1.16.15-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.18.patch target>nokmem.1.18.patch</a></li>
<li>1.15.12-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.18.patch target>nokmem.1.18.patch</a></li>
<li>1.14.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.18.patch target>nokmem.1.18.patch</a></li>
<li>1.13.12-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.13.patch target>nokmem.1.13.patch</a></li>
<li>1.12.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.13.patch target>nokmem.1.13.patch</a></li>
<li>1.11.10-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.13.patch target>nokmem.1.13.patch</a></li>
<li>1.10.13-lts.1 <a href=https://github.com/klts-io/kubernetes-lts/raw/master/patches/nokmem.1.13.patch target>nokmem.1.13.patch</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9662232d61bca04520940eafdc2967e8>6 - 版本日志</h1>
</div>
<div class=td-content>
<h1 id=pg-392cbea6b384069ecbb7f7287567796b>6.1 - v1.10.13</h1>
</div>
<div class=td-content>
<h1 id=pg-11f4f5c9a4be3821c253586ecc555cbb>6.1.1 - v1.10.13-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2019-11245 title="这是一个提权漏洞，在通常情况下以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行" data-toggle=tooltip data-placement=top target>CVE-2019-11245</a></li>
<li><a href=/zh/docs/patches/cve-2019-1002101 title="此漏洞可能允许攻击者利用 kubectl cp 命令执行解压过程中修改或监控符号链接头同名目录下的任意文件造成破坏。" data-toggle=tooltip data-placement=top target>CVE-2019-1002101</a></li>
<li><a href=/zh/docs/patches/cve-2019-11246 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11246</a></li>
<li><a href=/zh/docs/patches/cve-2019-11247 title="API Server 允许通过错误的范围访问自定义的资源" data-toggle=tooltip data-placement=top target>CVE-2019-11247</a> TODO</li>
<li><a href=/zh/docs/patches/cve-2019-11248 title="可以用过健康检查的端口访问 /debug/pprof" data-toggle=tooltip data-placement=top target>CVE-2019-11248</a></li>
<li><a href=/zh/docs/patches/cve-2019-11249 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11249</a></li>
<li><a href=/zh/docs/patches/cve-2019-11251 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11251</a></li>
<li><a href=/zh/docs/patches/cve-2020-8552 title="此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。" data-toggle=tooltip data-placement=top target>CVE-2020-8552</a></li>
<li><a href=/zh/docs/patches/cve-2020-8558 title="kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。" data-toggle=tooltip data-placement=top target>CVE-2020-8558</a> TODO</li>
<li><a href=/zh/docs/patches/cve-2020-8559 title="kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。" data-toggle=tooltip data-placement=top target>CVE-2020-8559</a> TODO</li>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f3da15966c8c4439fb741e2ef8c78204>6.2 - v1.11.10</h1>
</div>
<div class=td-content>
<h1 id=pg-9eec5b25731b7e0b81f9b917fe1bce0c>6.2.1 - v1.11.10-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2019-11245 title="这是一个提权漏洞，在通常情况下以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行" data-toggle=tooltip data-placement=top target>CVE-2019-11245</a></li>
<li><a href=/zh/docs/patches/cve-2019-11246 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11246</a></li>
<li><a href=/zh/docs/patches/cve-2019-11247 title="API Server 允许通过错误的范围访问自定义的资源" data-toggle=tooltip data-placement=top target>CVE-2019-11247</a></li>
<li><a href=/zh/docs/patches/cve-2019-11248 title="可以用过健康检查的端口访问 /debug/pprof" data-toggle=tooltip data-placement=top target>CVE-2019-11248</a></li>
<li><a href=/zh/docs/patches/cve-2019-11249 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11249</a></li>
<li><a href=/zh/docs/patches/cve-2019-11251 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11251</a></li>
<li><a href=/zh/docs/patches/cve-2020-8552 title="此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。" data-toggle=tooltip data-placement=top target>CVE-2020-8552</a></li>
<li><a href=/zh/docs/patches/cve-2020-8558 title="kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。" data-toggle=tooltip data-placement=top target>CVE-2020-8558</a></li>
<li><a href=/zh/docs/patches/cve-2020-8559 title="kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。" data-toggle=tooltip data-placement=top target>CVE-2020-8559</a> TODO</li>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b3690dbf3b7f69b33c1619edd3bb04ca>6.3 - v1.12.10</h1>
</div>
<div class=td-content>
<h1 id=pg-27786078bb9f8ad064a60ea6903bb0fd>6.3.1 - v1.12.10-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2019-11245 title="这是一个提权漏洞，在通常情况下以容器 Dockerfile 中指定的 USER 运行的容器，在容器重启时或者如果镜像先前被拉到节点时，都将以 root(uid 0) 身份运行" data-toggle=tooltip data-placement=top target>CVE-2019-11245</a></li>
<li><a href=/zh/docs/patches/cve-2019-11247 title="API Server 允许通过错误的范围访问自定义的资源" data-toggle=tooltip data-placement=top target>CVE-2019-11247</a></li>
<li><a href=/zh/docs/patches/cve-2019-11249 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11249</a></li>
<li><a href=/zh/docs/patches/cve-2019-11251 title="此漏洞可能允许攻击者利用 kubectl cp 命令，采用路径遍历(Path Traversal)的方式将容器 tar 包中的恶意文件写入所在主机上的任何路径，该过程仅受本地用户的系统权限限制。" data-toggle=tooltip data-placement=top target>CVE-2019-11251</a></li>
<li><a href=/zh/docs/patches/cve-2020-8552 title="此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。" data-toggle=tooltip data-placement=top target>CVE-2020-8552</a></li>
<li><a href=/zh/docs/patches/cve-2020-8558 title="kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。" data-toggle=tooltip data-placement=top target>CVE-2020-8558</a></li>
<li><a href=/zh/docs/patches/cve-2020-8559 title="kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。" data-toggle=tooltip data-placement=top target>CVE-2020-8559</a> TODO</li>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7900b7f9f88a4a74990fe03111a2da05>6.4 - v1.13.12</h1>
</div>
<div class=td-content>
<h1 id=pg-d881df1610b2ecdebb624461d03f23c9>6.4.1 - v1.13.12-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2020-8552 title="此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。" data-toggle=tooltip data-placement=top target>CVE-2020-8552</a></li>
<li><a href=/zh/docs/patches/cve-2020-8558 title="kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。" data-toggle=tooltip data-placement=top target>CVE-2020-8558</a></li>
<li><a href=/zh/docs/patches/cve-2020-8559 title="kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。" data-toggle=tooltip data-placement=top target>CVE-2020-8559</a> TODO</li>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-51d890621bb8c9944add326b0a8b37a9>6.5 - v1.14.10</h1>
</div>
<div class=td-content>
<h1 id=pg-a0f1f487ff86a6e928f7e5c357ff4b08>6.5.1 - v1.14.10-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2020-8552 title="此漏洞可能使 API Server 容易受到来自成功 API 请求的 DoS(拒绝服务攻击)。" data-toggle=tooltip data-placement=top target>CVE-2020-8552</a></li>
<li><a href=/zh/docs/patches/cve-2020-8558 title="kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。" data-toggle=tooltip data-placement=top target>CVE-2020-8558</a></li>
<li><a href=/zh/docs/patches/cve-2020-8559 title="kube-apiserver 组件的安全漏洞，攻击者可以通过截取某些发送至节点 kubelet 的升级请求，通过请求中原有的访问凭据转发请求至其他目标节点，从而造成节点的权限提升漏洞。" data-toggle=tooltip data-placement=top target>CVE-2020-8559</a></li>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e68cc5fb088f6d1ae33afaf415fddee9>6.6 - v1.15.12</h1>
</div>
<div class=td-content>
<h1 id=pg-0de2d52a18da527606a4cafd2f9c2964>6.6.1 - v1.15.12-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2020-8558 title="kube-proxy 组件在 iptables 和 ipvs 模式下均需要设置内核参数 net.ipv4.conf.all.route_localnet=1， 从而允许本地回环访问。攻击者可能通过共享主机网络的容器，或在集群节点访问同一个LAN或二层网络下的相邻节点上绑定监听了本地 127.0.0.1 端口的 TCP/UDP 服务，从而获取接口信息。如果服务没有设置必要的安全认证，可能会造成信息泄露风险。" data-toggle=tooltip data-placement=top target>CVE-2020-8558</a></li>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5f38f1e7b6171717787aed14f462ea87>6.7 - v1.16.15</h1>
</div>
<div class=td-content>
<h1 id=pg-291fa7036c16b7b6fec50788d3fbd23e>6.7.1 - v1.16.15-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2115cd3345664b75db988898787bd6c2>6.8 - v1.17.17</h1>
</div>
<div class=td-content>
<h1 id=pg-97b8bcc4b64573fbff060a24764ae889>6.8.1 - v1.17.17-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/cve-2021-3121 title="存在该漏洞的程序可能会因为处理了包含恶意 Protobuf 消息而崩溃。如果您使用的 Gogo Protobuf 版本过低，可能存在该漏洞。" data-toggle=tooltip data-placement=top target>CVE-2021-3121</a></li>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5c45d9bdb98f73d4ba804be5543aa913>6.9 - v1.18.20</h1>
</div>
<div class=td-content>
<h1 id=pg-f30dfdd74c807ee349c09b44ea91b5fa>6.9.1 - v1.18.20-lts.1</h1>
<h2 id=补丁>补丁</h2>
<ul>
<li><a href=/zh/docs/patches/nokmem title="节点磁盘充足但是一直报磁盘不足无法创建 Pod" data-toggle=tooltip data-placement=top target>nokmem</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a7c9e10a31abdecaec5a338462a220a8>7 - 开发指南</h1>
</div>
<div class=td-content>
<h1 id=pg-8da562538e76378aaf2ff1c50166f299>7.1 - 依赖</h1>
<h2 id=安装-yq>安装 yq</h2>
<ul class="nav nav-tabs" id=tabset-zhdocsdeveloper-guidedependent-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabset-zhdocsdeveloper-guidedependent-1-0 role=tab aria-controls=tabset-zhdocsdeveloper-guidedependent-1-0 aria-selected=true>MacOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsdeveloper-guidedependent-1-1 role=tab aria-controls=tabset-zhdocsdeveloper-guidedependent-1-1>基于 Red Hat 的发行版</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabset-zhdocsdeveloper-guidedependent-1-2 role=tab aria-controls=tabset-zhdocsdeveloper-guidedependent-1-2>基于 Debian 的发行版</a></li></ul>
<div class=tab-content id=tabset-zhdocsdeveloper-guidedependent-1><div id=tabset-zhdocsdeveloper-guidedependent-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabset-zhdocsdeveloper-guidedependent-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install jq python@3 <span style=color:#8f5902;font-style:italic># 安装 brew, 请看 https://brew.sh/</span>
pip3 install yq
</code></pre></div></div>
<div id=tabset-zhdocsdeveloper-guidedependent-1-1 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsdeveloper-guidedependent-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>yum install -y epel-release
yum install -y jq python3
pip3 install yq
</code></pre></div></div>
<div id=tabset-zhdocsdeveloper-guidedependent-1-2 class=tab-pane role=tabpanel aria-labelledby=tabset-zhdocsdeveloper-guidedependent-1-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>apt-get install -y jq python3 python3-pip
pip3 install yq
</code></pre></div></div></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-79fcc7e024580df9da30cdb10805eada>7.2 - 克隆</h1>
<h2 id=克隆主分支>克隆主分支</h2>
<p>请尝试只克隆主分支, 由于 repos 仓库是作为 rpm 和 deb 的软件源的, 直接克隆全部的话会非常大</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone --single-branch -b master https://github.com/klts-io/kubernetes-lts
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f4d763992e363d6113dea2a2ad1ec491>8 - 术语</h1>
</div>
<div class=td-content>
<h1 id=pg-ea088dea53bf4324a475e5d395955d13>8.1 - 节点压力驱逐</h1>
<p>节点压力驱逐是 <a href=/zh/docs/glossary/kubelet title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top target>Kubelet</a> 主动终止 Pod 以回收节点上资源的过程。</p>
<p>kubelet 监控集群节点上的 CPU、内存、磁盘空间和文件系统 inode 等资源。
当这些资源中的一个或多个达到特定消耗水平时，
kubelet 可以主动使节点上的一个或多个 Pod 失效，以回收资源并防止饥饿。</p>
<p>节点压力驱逐不用于 <a href=https://kubernetes.io/zh/docs/concepts/scheduling-eviction/api-eviction/>API 发起的驱逐</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-85c3146e7a708d6559c4c51f7810b6f6>8.2 - API 发起的驱逐</h1>
<p>API 发起的驱逐是一个先调用
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/0.0/create-eviction-pod-v1-core>Eviction API</a>
创建驱逐对象，再由该对象体面地中止 Pod 的过程。</p>
<p>你可以通过 kube-apiserver 的客户端，比如 <code>kubectl drain</code> 这样的命令，直接调用 Eviction API 发起驱逐。
当 <code>Eviction</code> 对象创建出来之后，该对象将驱动 API 服务器终止选定的Pod。</p>
<p>API 发起的驱逐不同于
<a href=https://kubernetes.io/zh/docs/concepts/scheduling-eviction/eviction/#kubelet-eviction>节点压力引发的驱逐</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b2a9181259ac47c88dd4b846e14dc40d>8.3 - 对象（Object）</h1>
<p>Kubernetes 系统中的实体。Kubernetes API 用这些实体表示集群的状态。</p>
<p>Kubernetes 对象通常是一个“目标记录”-一旦你创建了一个对象，Kubernetes
<a href=/zh/docs/glossary/control-plane title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top target>控制平面（Control Plane）</a>
不断工作，以确保它代表的项目确实存在。
创建一个对象相当于告知 Kubernetes 系统：你期望这部分集群负载看起来像什么；这也就是你集群的期望状态。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a5d2a630698933fd93614dbd1dba885b>8.4 - 端点（Endpoints）</h1>
<p>端点负责记录与服务的<a href=/zh/docs/glossary/selector title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top target>选择算符（Selector）</a>相匹配的 Pods 的 IP 地址。</p>
<p>端点可以手动配置到<a href=/zh/docs/glossary/service title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top target>服务（Service）</a>上，而不必指定选择器标识。</p>
<p><a href=/zh/docs/glossary/endpoint-slice title="一种将网络端点与 Kubernetes 资源组合在一起的方法。" data-toggle=tooltip data-placement=top target>EndpointSlice</a>提供了一种可伸缩、可扩展的替代方案。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-af7fefbfc2a45796c3ca375511518e5c>8.5 - Master</h1>
<p>遗留术语，作为运行 <a href=/zh/docs/glossary/control-plane title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top target>控制平面（Control Plane）</a> 的 <a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a> 的同义词使用。</p>
<p>该术语仍被一些配置工具使用，如 <a href=/zh/docs/glossary/kubeadm title="用来快速安装 Kubernetes 并搭建安全稳定的集群的工具。" data-toggle=tooltip data-placement=top target>Kubeadm</a> 以及托管的服务，为 <a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a> 添加 <code>kubernetes.io/role</code> 的 <a href=/zh/docs/glossary/label title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top target>标签（Label）</a>，以及管理控制平面 Pod 的调度。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fa8a8b341bb097a7c0abb12c819f5aa7>8.6 - 混排切片（Shuffle Sharding）</h1>
<p>混排切片（Shuffle Sharding）是指一种将请求指派给队列的技术，其隔离性好过对队列个数哈希取模的方式。</p>
<p>我们通常会关心不同的请求序列间的相互隔离问题，目的是为了确保密度较高的
请求序列不会湮没密度较低的序列。
将请求放入不同队列的一种简单方法是对请求的某些特征值执行哈希函数，
将结果对队列的个数取模，从而得到要使用的队列的索引。
这一哈希函数使用请求的与其序列相对应的特征作为其输入。例如，在因特网上，
这一特征通常指的是由源地址、目标地址、协议、源端口和目标端口所组成的
五元组。</p>
<p>这种简单的基于哈希的模式有一种特性，高密度的请求序列（流）会湮没那些被
哈希到同一队列的其他低密度请求序列（流）。
为大量的序列提供较好的隔离性需要提供大量的队列，因此是有问题的。
混排切片是一种更为灵活的机制，能够更好地将低密度序列与高密度序列隔离。
混排切片的术语采用了对一叠扑克牌进行洗牌的类比，每个队列可类比成一张牌。
混排切片技术首先对请求的特定于所在序列的特征执行哈希计算，生成一个长度
为十几个二进制位或更长的哈希值。
接下来，用该哈希值作为信息熵的来源，对一叠牌来混排，并对整个一手牌（队列）来洗牌。
最后，对所有处理过的队列进行检查，选择长度最短的已检查队列作为请求的目标队列。
在队列数量适中的时候，检查所有已处理的牌的计算量并不大，对于任一给定的
低密度的请求序列而言，有相当的概率能够消除给定高密度序列的湮没效应。
当队列数量较大时，检查所有已处理队列的操作会比较耗时，低密度请求序列
消除一组高密度请求序列的湮没效应的机会也随之降低。因此，选择队列数目
时要颇为谨慎。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed4a8f9fd1c875ccae329d3f53d2feb0>8.7 - 附加组件（Add-ons）</h1>
<p>扩展 Kubernetes 功能的资源。</p>
<p><a href=https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/>安装附加组件</a> 阐释了更多关于如何在集群内使用附加组件，并列出了一些流行的附加组件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-24bc15f976745350a4056d3966d1ee9f>8.8 - CIDR</h1>
<p>CIDR (无类域间路由) 是一种描述 IP 地址块的符号，被广泛使用于各种网络配置中。</p>
<p>在 Kubernetes 的上下文中，每个<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>
以 CIDR 形式（含起始地址和子网掩码）获得一个 IP 地址段，
从而能够为每个 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 分配一个独一无二的 IP 地址。
虽然其概念最初源自 IPv4，CIDR 已经被扩展为涵盖 IPv6。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7dc22669aa066727108036b6f115ec92>8.9 - 代理（Proxy）</h1>
<p>在计算机领域，代理指的是充当远程服务中介的服务器。</p>
<p>客户端与代理进行交互；代理将客户端的数据复制到实际服务器；实际服务器回复代理；代理将实际服务器的回复发送给客户端。</p>
<p><a href=https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> 是集群中每个节点上运行的网络代理，实现了部分 Kubernetes <a href=/zh/docs/glossary/service title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top target>服务（Service）</a> 概念。</p>
<p>你可以将 kube-proxy 作为普通的用户态代理服务运行。
如果你的操作系统支持，则可以在混合模式下运行 kube-proxy；该模式使用较少的系统资源即可达到相同的总体效果。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ff4dd9b75202eafce20f231fe58bcea1>8.10 - 干扰（Disruption）</h1>
<p>干扰是指导致一个或者多个 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 服务停止的事件。
干扰会影响工作负载资源，比如 <a href=/zh/docs/glossary/deployment title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top target>Deployment</a> 这种依赖于受影响 Pod 的资源。</p>
<p>如果您作为一个集群操作人员，销毁了一个从属于某个应用的 Pod, Kubernetes 视之为 <em>自愿干扰（Voluntary Disruption）</em>。如果由于节点故障
或者影响更大区域故障的断电导致 Pod 离线，kubernetes 视之为 <em>非愿干扰（Involuntary Disruption）</em>。</p>
<p>更多信息请查阅<a href=https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/>Disruptions</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-810644a00d411940f449bf6d150eb0df>8.11 - API Group</h1>
<p>Kubernetes API 中的一组相关路径。</p>
<p>通过更改 API server 的配置，可以启用或禁用每个 API Group。
你还可以禁用或启用指向特定资源的路径。
API group 使扩展 Kubernetes API 更加的容易。
API group 在 REST 路径和序列化对象的 <code>apiVersion</code> 字段中指定。</p>
<ul>
<li>阅读 <a href=https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning>API Group</a> 了解更多信息。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7bb1a1bafadec6fcba480d2c0adda0cf>8.12 - 临时容器（Ephemeral Container）</h1>
<p>您可以在 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中临时运行的一种 <a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a> 类型。</p>
<p>如果想要调查运行中有问题的 Pod，可以向该 Pod 添加一个临时容器并进行诊断。
临时容器没有资源或调度保证，因此不应该使用它们来运行任何部分的工作负荷本身。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aeafca9c7103f386be3348e8dd2d0a84>8.13 - 镜像 Pod（Mirror Pod）</h1>
<p>镜像 Pod（Mirror Pod）是被 kubelet 用来代表<a href=/zh/docs/glossary/static-pod title="静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。" data-toggle=tooltip data-placement=top target>静态 Pod（Static Pod）</a> 的
<a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 对象。</p>
<p>当 kubelet 在其配置中发现一个静态容器时，
它会自动地尝试在 Kubernetes API 服务器上为它创建 Pod 对象。
这意味着 pod 在 API 服务器上将是可见的，但不能在其上进行控制。</p>
<p>（例如，删除镜像 Pod 也不会阻止 kubelet 守护进程继续运行它）。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-170f5162598390413252cb3da4690390>8.14 - 准入控制器（Admission Controller）</h1>
<p>在对象持久化之前拦截 Kubernetes Api 服务器请求的一段代码</p>
<p>准入控制器可针对 Kubernetes Api 服务器进行配置，可以执行验证，变更或两者都执行。任何准入控制器都可以拒绝访问请求。
变更（mutating）控制器可以修改其允许的对象，验证（validating）控制器则不可以。</p>
<ul>
<li><a href=https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/>Kubernetes 文档中的准入控制器</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b457493b432beb09ec280345c294db59>8.15 - 清单（Manifest）</h1>
<p>JSON 或 YAML 格式的 Kubernetes API 对象规范。</p>
<p>清单指定了在应用该清单时 kubernetes 将维护的对象的期望状态。每个配置文件可包含多个清单。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0eb2c302a98ca11c35c182ef446b373d>8.16 - 控制组（cgroup）</h1>
<p>一组具有可选资源隔离、审计和限制的 Linux 进程。</p>
<p>Cgroup 是一个 Linux 内核特性，对一组进程的资源使用（CPU、内存、磁盘 I/O 和网络等）进行限制、审计和隔离。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-86faf68210349366fa6a0ef030efbb61>8.17 - 集群（Cluster）</h1>
<p>集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p>
<p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。
为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-391f68a5984a544c18ec35cf2dca6d81>8.18 - 容器运行时（Container Runtime）</h1>
<p>容器运行环境是负责运行容器的软件。</p>
<p>Kubernetes 支持多个容器运行环境: <a href=/zh/docs/glossary/docker title="Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。" data-toggle=tooltip data-placement=top target>Docker</a>、
<a href=/zh/docs/glossary/containerd title=强调简单性、健壮性和可移植性的一种容器运行时 data-toggle=tooltip data-placement=top target>containerd</a>、<a href=/zh/docs/glossary/cri-o title="专用于 Kubernetes 的轻量级容器运行时软件" data-toggle=tooltip data-placement=top target>CRI-O</a>
以及任何实现 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (容器运行环境接口)</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c1bb2dc7a968fbe5d7ad067be267b884>8.19 - 云原生计算基金会（CNCF）</h1>
<p>云原生计算基金会（CNCF）建立了可持续的生态系统，并在围绕着 <a href=https://www.cncf.io/projects/>项目</a> 建立一个社区，将容器编排微服务架构的一部分。</p>
<p>Kubernetes 是一个云原生计算基金会项目.</p>
<p>云原生计算基金会（CNCF）是 <a href=https://www.linuxfoundation.org/>Linux 基金会</a> 的下属基金会。它的使命是让云原生计算无处不在。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-95258abd5e7f088e9cc655eee2c25e88>8.20 - Operator 模式</h1>
<p><a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/>operator 模式</a> 是一种系统设计,
将 <a href=/zh/docs/glossary/controller title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top target>控制器（Controller）</a> 关联到一个或多个自定义资源。</p>
<p>除了使用作为 Kubernetes 自身一部分的内置控制器之外，你还可以通过
将控制器添加到集群中来扩展 Kubernetes。</p>
<p>如果正在运行的应用程序能够充当控制器并通过 API 访问的方式来执行任务操控
那些在控制平面中定义的自定义资源，这就是一个 operator 模式的示例。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c9a4b9caaf3b3f726d23ec46b4f2fa38>8.21 - containerd</h1>
<p>强调简单性、健壮性和可移植性的一种容器运行时</p>
<p>containerd 是一种<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>运行时，能在 Linux 或者 Windows 后台运行。
containerd 能取回、存储容器镜像，执行容器实例，提供网络访问等。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3728cfb317c9907dfa60d8a3bac9cd7c>8.22 - CRI-O</h1>
<p>该工具可让你通过 Kubernetes CRI 使用 OCI 容器运行时。</p>
<p>CRI-O 是 <a href=/zh/docs/glossary/cri title="一组与 kubelet 集成的容器运行时 API" data-toggle=tooltip data-placement=top target>容器运行时接口（CRI）</a> 的一种实现，
使得你可以使用与开放容器倡议（Open Container Initiative，OCI）
<a href=https://www.github.com/opencontainers/runtime-spec>运行时规范</a>
兼容的<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>。</p>
<p>部署 CRI-O 允许 Kubernetes 使用任何符合 OCI 要求的运行时作为容器运行时
去运行 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>，
并从远程容器仓库获取 OCI 容器镜像。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0159519399ab9be7d9e9c91b2c2a7e41>8.23 - 应用（Applications）</h1>
<p>各种容器化应用运行所在的层。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66f58cd125d2e0e6e2458478e7d4485f>8.24 - 控制平面（Control Plane）</h1>
<p>控制平面（Control Plane）是指容器编排层，它暴露 API 和接口来定义、
部署容器和管理容器的生命周期。</p>
<p>这个编排层是由多个不同的组件组成，例如以下（但不限于）几种：</p>
<ul>
<li><a href=/zh/docs/glossary/etcd title="etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。" data-toggle=tooltip data-placement=top target>etcd</a></li>
<li><a href=/zh/docs/glossary/kube-apiserver title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top target>kube-apiserver</a></li>
<li><a href=/zh/docs/glossary/kube-scheduler title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top target>kube-scheduler</a></li>
<li><a href=/zh/docs/glossary/kube-controller-manager title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top target>kube-controller-manager</a></li>
<li><a href=/zh/docs/glossary/cloud-controller-manager title="将 Kubernetes 与第三方云提供商进行集成的控制面组件。" data-toggle=tooltip data-placement=top target>云控制器管理器（Cloud Controller Manager）</a></li>
</ul>
<p>这些组件可以以传统的系统服务运行也可以以容器的形式运行.运行这些组件的主机过去称为 master 节点。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ffbb95a734b8498c055480abd89f9357>8.25 - 数据平面（Data Plane）</h1>
<p>提供诸如 CPU，内存，网络和存储的能力，以便容器可以运行并连接到网络。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e790a73a470e32df4a4b645ebcd0e738>8.26 - 集群基础设施（Cluster Infrastructure）</h1>
<p>基础设施层提供并维护虚拟机、网络、安全组及其他资源。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7f09f5ca01acaaeeedcb241875015d35>8.27 - 集群操作（Cluster Operations）</h1>
<p>Kubernetes 管理相关工作包括：日常管理操作和协调升级。</p>
<p>群集操作工作的示例包括：部署新节点来扩容集群；执行软件升级；实施安全控制；
添加或删除存储；配置集群网络；管理集群范围的可观测性；响应集群事件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e06cda065bbef96599747ee7312b999f>8.28 - LimitRange</h1>
<p>提供约束来限制命名空间中每个 <a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a> 或 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 的资源消耗。</p>
<p>LimitRange 按照类型来限制命名空间中对象能够创建的数量，以及单个 <a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a> 或 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 可以请求/使用的计算资源量。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-50360f60cb4b630b53166bc1646e2739>8.29 - QoS 类（QoS Class）</h1>
<p>QoS Class（Quality of Service Class）为 Kubernetes 提供了一种将集群中的 Pod 分为几个类型并做出有关调度和驱逐决策的方法。</p>
<p>Pod 的 QoS 类是基于 Pod 在创建时配置的计算资源请求和限制。QoS 类用于制定有关 Pod 调度和逐出的决策。
Kubernetes 可以为 Pod 分配以下 QoS 类：<code>Guaranteed</code>，<code>Burstable</code> 或者 <code>BestEffort</code>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b03c6a3edccc411341039200ac8a6604>8.30 - 日志（Logging）</h1>
<p>日志是 <a href=/zh/docs/glossary/cluster title="集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。" data-toggle=tooltip data-placement=top target>集群（Cluster）</a> 或应用程序记录的事件列表。</p>
<p>应用程序和系统日志可以帮助您了解集群内部发生的情况。日志对于调试问题和监视集群活动非常有用。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8857dfac09cbd90c874f4d1092ae83a9>8.31 - 容器运行时接口（CRI）</h1>
<p>容器运行时接口 (CRI) 是一组与节点上 kubelet 集成的容器运行时 API</p>
<p>更多信息， 请参考 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>容器运行时接口</a> API 与规格。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60425ea7053ba19b82f5c227adc76827>8.32 - Pod 生命周期</h1>
<p>关于 Pod 在其生命周期中处于哪个阶段的更高层次概述。</p>
<p><a href=https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/>Pod 生命周期</a> 是关于 Pod
处于哪个阶段的概述。包含了下面5种可能的的阶段: Running、Pending、Succeeded、
Failed、Unknown。关于 Pod 的阶段的更高级描述请查阅
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/0.0/#podstatus-v1-core>PodStatus</a> <code>phase</code> 字段。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0378b06e0d319f6e1e1583e457d2d057>8.33 - 工作负载（Workload）</h1>
<p>工作负载是在 Kubernetes 上运行的应用程序。</p>
<p>代表不同类型或部分工作负载的各种核心对象包括 DaemonSet， Deployment， Job， ReplicaSet， and StatefulSet。</p>
<p>例如，具有 Web 服务器和数据库的工作负载可能在一个 <a href=/zh/docs/glossary/StatefulSet title="StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。" data-toggle=tooltip data-placement=top target>StatefulSet</a> 中运行数据库，
而 Web 服务器运行在 <a href=/zh/docs/glossary/Deployment title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top target>Deployment</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0d7383e751cf4e80eb87f886b793e246>8.34 - Pod Disruption Budget</h1>
<p><a href=https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/>Pod Disruption Budget</a> 使应用所有者能够为多实例应用创建一个对象，来确保一定数量的具有指定标签的 Pod 在任何时候都不会被主动驱逐。 PDB 无法防止非主动的中断，但是会计入预算（budget）。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-929cc0b93db2184d1dff350227923245>8.35 - sysctl</h1>
<p><code>sysctl</code> 是一个半标准化的接口，用于读取或更改正在运行的 Unix 内核的属性。</p>
<p>在类 Unix 系统上， <code>sysctl</code> 既是管理员用于查看和修改这些设置的工具的名称，也是该工具所调用的系统调用的名称。</p>
<p><a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>运行时和网络插件可能对 <code>sysctl</code> 的取值有一定的要求。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e23b307c1d8faa5574a7c86fc5505aef>8.36 - 应用程序容器（App Container）</h1>
<p>应用程序 <a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a> （或 app 容器）在 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中，在 <a href=/zh/docs/glossary/init-container title=应用容器运行前必须先运行完成的一个或多个初始化容器。 data-toggle=tooltip data-placement=top target>初始化容器（Init Container）</a> 启动完毕后才开始启动。</p>
<p>初始化容器使您可以分离对于<a href=/zh/docs/glossary/workload title="工作负载是在 Kubernetes 上运行的应用程序。" data-toggle=tooltip data-placement=top target>工作负载（Workload）</a>
整体而言很重要的初始化细节，并且一旦应用容器启动，它不需要继续运行。
如果 pod 没有配置任何初始化容器，则该 pod 中的所有容器都是应用程序容器。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7758f072a62f56ecadfd99b5cac9d59b>8.37 - 静态 Pod（Static Pod）</h1>
<p>由特定节点上的 kubelet 守护进程直接管理的 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>，</p>
<p>API 服务器不了解它的存在。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3b9accbfed89a2ffeac8c8d98f69911a>8.38 - 设备插件（Device Plugin）</h1>
<p>设备插件工作在节点主机上，给 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 提供访问资源的权限，比如特定厂商初始化或者安装的本地硬件。</p>
<p>设备插件将资源告知 <a href=/zh/docs/glossary/kubelet title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top target>Kubelet</a> ，以便相关节点上运行的工作负载Pod可以访问硬件功能。</p>
<p>更多信息请查阅<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c705d3f377f7af95796724ed73f6804>8.39 - 扩展组件（Extensions）</h1>
<p>扩展组件是扩展并与 Kubernetes 深度集成以支持新型硬件的软件组件。</p>
<p>大多数集群管理员会使用托管的 Kubernetes 或其某种发行包。因此，大多数 Kubernetes 用户将需要
安装<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/extend-cluster/#extensions>扩展组件</a>，
较少用户会需要编写新的扩展组件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eef24989f21f3b4c3b26383f03e86a84>8.40 - HostAliases</h1>
<p>主机别名 (HostAliases) 是一组 IP 地址和主机名的映射，用于注入到 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 内的 hosts 文件。</p>
<p><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/0.0/#hostalias-v1-core>HostAliases</a>
是一个包含主机名和 IP 地址的可选列表，配置后将被注入到 Pod 内的 hosts 文件中。
该选项仅适用于没有配置 hostNetwork 的 Pod.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8ff6088bce30e4ffc06bbcdedd09e0c5>8.41 - Pod 优先级（Pod Priority）</h1>
<p>Pod 优先级表示一个 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 相对于其他 Pod 的重要性。</p>
<p><a href=https://kubernetes.io/zh/docs/concepts/configuration/pod-priority-preemption/#pod-priority>Pod 优先级</a>
允许用户为 Pod 设置高于或低于其他 Pod 的优先级 &ndash; 这对于生产集群
工作负载而言是一个重要的特性。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5cfed246d3d9c9d4e36821a3b9f80a75>8.42 - 抢占（Preemption）</h1>
<p>Kubernetes 中的抢占逻辑通过驱逐<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>
上的低优先级<a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>
来帮助悬决的 Pod 找到合适的节点。</p>
<p>如果一个 Pod 无法调度，调度器会尝试
<a href=https://kubernetes.io/zh/docs/concepts/configuration/pod-priority-preemption/#preemption>抢占</a>
较低优先级的 Pod，以使得悬决的 Pod 有可能被调度。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-692d90d2f87028f929f9d15fe552dad7>8.43 - 容忍度（Toleration）</h1>
<p>一个核心对象，由三个必需的属性组成：key、value 和 effect。
容忍度允许将 Pod 调度到具有对应<a href=/zh/docs/glossary/taint title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top target>污点（Taint）</a>
的节点或节点组上。</p>
<p>容忍度和<a href=/zh/docs/glossary/taint title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top target>污点（Taint）</a>共同作用可以
确保不会将 Pod 调度在不适合的节点上。
在同一 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 上可以设置一个
或者多个容忍度。
容忍度表示在包含对应<a href=/zh/docs/glossary/taint title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top target>污点（Taint）</a>
的节点或节点组上调度 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>
是允许的（但不必要）。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4931865ca1d0f7f9f6098354b0a091c4>8.44 - 污点（Taint）</h1>
<p>污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。
污点会阻止在<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>
或节点组上调度 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>。</p>
<p>污点和<a href=/zh/docs/glossary/toleration title="一个核心对象，由三个必需的属性组成：key、value 和 effect。 容忍度允许将 Pod 调度到具有对应污点的节点或节点组上。" data-toggle=tooltip data-placement=top target>容忍度（Toleration）</a>一起工作，
以确保不会将 Pod 调度到不适合的节点上。
同一<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>上可标记一个或多个污点。
节点应该仅调度那些带着能与污点相匹配容忍度的 Pod。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-de020b9f85b8766b04b8c9742d123d5a>8.45 - 容器生命周期钩子（Container Lifecycle Hooks）</h1>
<p>生命周期钩子暴露<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>管理生命周期中的事件，允许用户在事件发生时运行代码。</p>
<p>针对容器暴露了两个钩子：PostStart 在容器创建之后立即执行，PreStop 在容器停止之前立即阻塞并被调用。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0958b182eae3c951db0eb0e94d7f1bbd>8.46 - 聚合层（Aggregation Layer）</h1>
<p>聚合层允许您在自己的集群上安装额外的 Kubernetes 风格的 API。</p>
<p>当您配置了 <a href=/zh/docs/glossary/kube-apiserver title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top target>kube-apiserver</a> 来 <a href=https://kubernetes.io/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/>支持额外的 API</a>，您就可以在 Kubernetes API 中增加 <code>APIService</code> 对象来 &ldquo;申领（Claim）&rdquo; 一个 URL 路径。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7395f528d0587206ca14b4af250647a>8.47 - 量纲（Quantity）</h1>
<p>使用全数字来表示较小数值或使用 SI 后缀表示较大数值的表示法。</p>
<p>量纲是使用紧凑的全数字表示法来表示小数值或带有国际计量单位制（SI）
的大数值的表示法。
小数用 milli 单位表示，而大数用 kilo、mega 或 giga 单位表示。</p>
<p>例如，数字 <code>1.5</code> 表示为 <code>1500m</code>，
而数字 <code>1000</code> 表示为 <code>1k</code>，<code>1000000</code> 表示为 <code>1M</code>。
你还可以指定二进制表示法后缀；数字 2048 可以写成 <code>2Ki</code>。</p>
<p>公认的十进制（10 的幂数）单位是 <code>m</code>（milli）、<code>k</code>（kilo，有意小写）、
<code>M</code>（mega）、<code>G</code>（giga）、<code>T</code>（terra）、<code>P</code>（peta）、<code>E</code>（exa）。</p>
<p>公认的二进制（2 的幂数）单位是 <code>Ki</code> (kibi)、<code>Mi</code> (mebi)、<code>Gi</code> (gibi)、
<code>Ti</code> (tebi)、 <code>Pi</code> (pebi)、 <code>Ei</code> (exbi)。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7c76e8692d489ae67869b0213d5b9316>8.48 - FlexVolume</h1>
<p>Flexvolume 是创建树外卷插件的一种接口。
<a href=/zh/docs/glossary/csi title="容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。" data-toggle=tooltip data-placement=top target>容器存储接口（Container Storage Interface，CSI）</a>
是比 Flexvolume 更新的接口，它解决了 Flexvolume 的一些问题。</p>
<p>Flexvolume 允许用户编写自己的驱动程序，并在 Kubernetes 中加入对用户自己的数据卷的支持。
FlexVolume 驱动程序的二进制文件和依赖项必须安装在主机上。
这需要 root 权限。如果可能的话，SIG Storage 建议实现
<a href=/zh/docs/glossary/csi title="容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。" data-toggle=tooltip data-placement=top target>容器存储接口（Container Storage Interface，CSI）</a> 驱动程序，
因为它解决了 Flexvolumes 的限制。</p>
<ul>
<li><a href=https://kubernetes.io/zh/docs/concepts/storage/volumes/#flexvolume>Kubernetes 文档中的 Flexvolume</a></li>
<li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md>更多关于 Flexvolumes 的信息</a></li>
<li><a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>存储供应商的卷插件 FAQ</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0a2ee2d47d0ffb66a24ce3d2646f7c13>8.49 - 容器存储接口（Container Storage Interface，CSI）</h1>
<p>容器存储接口 （CSI） 定义了存储系统暴露给容器的标准接口。</p>
<p>CSI 允许存储驱动提供商为 Kubernetes 创建定制化的存储插件，
而无需将这些插件的代码添加到 Kubernetes 代码仓库（外部插件）。
要使用某个存储提供商的 CSI 驱动，你首先要
<a href=https://kubernetes-csi.github.io/docs/deploying.html>将它部署到你的集群上</a>。
然后你才能创建使用该 CSI 驱动的 <a href=/zh/docs/glossary/storage-class title="StorageClass 是管理员用来描述可用的不同存储类型的一种方法。" data-toggle=tooltip data-placement=top target>StorageClass</a> 。</p>
<ul>
<li><a href=https://kubernetes.io/zh/docs/concepts/storage/volumes/#csi>Kubernetes 文档中关于 CSI 的描述</a></li>
<li><a href=https://kubernetes-csi.github.io/docs/drivers.html>可用的 CSI 驱动列表</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cf72883fae6049bb588f4e2e294daba5>8.50 - 容器网络接口（CNI）</h1>
<p>容器网络接口 (CNI) 插件是遵循 appc/CNI 协议的一类网络插件。</p>
<ul>
<li>想了解 Kubernetes 和 CNI 请参考 <a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni>&ldquo;网络插件&rdquo;</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fdb7558ef19f95a1a756fcc17e48fbdc>8.51 - ConfigMap</h1>
<p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</p>
<p>ConfigMap 将您的环境配置信息和 <a href=/zh/docs/glossary/image title=镜像是保存的容器实例，它打包了应用运行所需的一组软件。 data-toggle=tooltip data-placement=top target>镜像（Image）</a> 解耦，便于应用配置的修改。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-183f94cc1dfce9f6b913269790034e7a>8.52 - CustomResourceDefinition</h1>
<p>通过定制化的代码给您的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。</p>
<p>当 Kubernetes 公开支持的 API 资源不能满足您的需要时，定制资源对象（Custom Resource Definitions）让您可以在您的环境上扩展 Kubernetes API。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8676d1007b3be13d8efae8fe4ad081b1>8.53 - DaemonSet</h1>
<p>确保 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 的副本在<a href=/zh/docs/glossary/cluster title="集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。" data-toggle=tooltip data-placement=top target>集群（Cluster）</a>中的一组节点上运行。</p>
<p>用来部署系统守护进程，例如日志搜集和监控代理，这些进程通常必须运行在每个<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>上。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-40e2823dc04a7ea6948c6c13eb9580ad>8.54 - Deployment</h1>
<p>Deployment 是管理应用副本的 API 对象，通常通过运行没有本地状态的Pods来实现。</p>
<p>应用的每个副本就是一个 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>，
并且这些 Pod 会分散运行在集群的<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>上。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-be1e0a8cf9619ea16f8183ada08b4482>8.55 - Docker</h1>
<p>Docker（这里特指 Docker 引擎） 是一种可以提供操作系统级别虚拟化（也称作<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>）的软件技术。</p>
<p>Docker 使用了 Linux 内核中的资源隔离特性（如 cgroup 和内核命名空间）以及支持联合文件系统（如 OverlayFS 和其他），
允许多个相互独立的“容器”一起运行在同一 Linux 实例上，从而避免启动和维护虚拟机（VMs）的开销。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6ebc75f521516b9a368c873181715ca0>8.56 - EndpointSlice</h1>
<p>一种将网络端点与 Kubernetes 资源组合在一起的方法。</p>
<p>一种将网络端点组合在一起的可扩缩、可扩展方式。
它们将被 <a href=/zh/docs/glossary/kube-proxy title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top target>kube-proxy</a> 用于在
每个 <a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a> 上建立网络路由。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a4ad6a0f27e847c8fbe882d49bf8437a>8.57 - etcd</h1>
<p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p>
<p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p>
<p>要了解 etcd 更深层次的信息，请参考 <a href=https://etcd.io/docs/>etcd 文档</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8d334712ca67f6f138195b60018a0b6b>8.58 - Helm Chart</h1>
<p>Helm Chart 是一组预先配置的 Kubernetes 资源所构成的包，可以使用 Helm 工具对其进行管理。</p>
<p>Chart 提供了一种可重现的用来创建和共享 Kubernetes 应用的方法。
单个 Chart 可用来部署简单的系统（例如一个 memcached Pod），
也可以用来部署复杂的系统（例如包含 HTTP 服务器、数据库、缓存等组件的完整 Web 应用堆栈）。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-395693d4e82c66a4f10056a09b8aa236>8.59 - Ingress</h1>
<p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。</p>
<p>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c9a26032fd4c884eb5e731d92cfbbb50>8.60 - Istio</h1>
<p>Istio 是个开放平台（非 Kubernetes 特有），提供了一种统一的方式来集成微服务、管理流量、实施策略和汇总度量数据。</p>
<p>添加 Istio 时不需要修改应用代码。它是基础设施的一层，介于服务和网络之间。
当它和服务的 Deployment 相结合时，就构成了通常所谓的服务网格（Service Mesh）。
Istio 的控制面抽象掉了底层的集群管理平台，这一集群管理平台可以是 Kubernetes、Mesosphere 等。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bfc166010ce186953b96bc5f81b2006a>8.61 - Job</h1>
<p>Job 是需要运行完成的确定性的或批量的任务。</p>
<p>Job 创建一个或多个 <a href=/zh/docs/glossary/Pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 对象，并确保指定数量的 Pod 成功终止。
随着各 Pod 成功结束，Job 会跟踪记录成功完成的个数。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d15b6100b062fdecd019adb24d1e3f34>8.62 - Kops</h1>
<p>kops 是一个命令行工具，可以帮助您创建、销毁、升级和维护生产级，高可用性的 Kubernetes 集群。</p>
<blockquote class="note callout">
<div><strong>[i18n] note</strong> 注意：官方仅支持 AWS，GCE 和 VMware vSphere 的支持还处于 alpha* 阶段。</div>
</blockquote>
<p><code>kops</code> 为您的集群提供了：</p>
<ul>
<li>全自动化安装</li>
<li>基于 DNS 的集群标识</li>
<li>自愈功能：所有组件都在自动伸缩组（Auto-Scaling Groups）中运行</li>
<li>有限的操作系统支持 (推荐使用 Debian，支持 Ubuntu 16.04，试验性支持 CentOS & RHEL)</li>
<li>高可用 (HA) 支持</li>
<li>直接提供或者生成 Terraform 清单文件的能力</li>
</ul>
<p>您也可以将自己的集群作为一个构造块，使用 <a href=/zh/docs/glossary/kubeadm title="用来快速安装 Kubernetes 并搭建安全稳定的集群的工具。" data-toggle=tooltip data-placement=top target>Kubeadm</a> 构造集群。<code>kops</code> 是建立在 kubeadm 之上的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9a5b920a0a750150154840d32360318b>8.63 - kube-apiserver</h1>
<p>API 服务器是 Kubernetes <a href=/zh/docs/glossary/control-plane title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top target>控制平面（Control Plane）</a>的组件，
该组件公开了 Kubernetes API。
API 服务器是 Kubernetes 控制面的前端。</p>
<p>Kubernetes API 服务器的主要实现是 <a href=https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>。
kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。
你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4187f407e5bee751c9765710a2a5d25a>8.64 - kube-controller-manager</h1>
<p>运行<a href=/zh/docs/glossary/controller title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top target>控制器（Controller）</a>进程的控制平面组件。</p>
<p>从逻辑上讲，每个<a href=/zh/docs/glossary/controller title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top target>控制器（Controller）</a>都是一个单独的进程，
但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ce957898ebfd87795c3086298f227a21>8.65 - kube-proxy</h1>
<p><a href=https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> 是集群中每个节点上运行的网络代理，
实现 Kubernetes <a href=/zh/docs/glossary/service title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top target>服务（Service）</a> 概念的一部分。</p>
<p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e4313ba87227f104d15401e5bf459a15>8.66 - kube-scheduler</h1>
<p>控制平面组件，负责监视新创建的、未指定运行<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>的 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>，选择节点让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e758828688e74bfe2e8106f519da981c>8.67 - Kubeadm</h1>
<p>用来快速安装 Kubernetes 并搭建安全稳定的集群的工具。</p>
<p>你可以使用 kubeadm 安装控制面和
<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>
组件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-534631ac084a6a05b80b74ccda7b29fd>8.68 - Kubectl</h1>
<p>kubectl 是用来和 <a href=/zh/docs/glossary/kubernetes-api title="Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。" data-toggle=tooltip data-placement=top target>Kubernetes API</a> 服务器进行通信的命令行工具。</p>
<p>您可以使用 kubectl 创建、检查、更新和删除 Kubernetes 对象。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9f6db6f1d6533ac11b51bd825e1be62e>8.69 - Kubelet</h1>
<p>一个在集群中每个<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a>上运行的代理。
它保证<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>都
运行在 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中。</p>
<p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs
中描述的容器处于运行状态且健康。
kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6e971b5fddbc5b8e0cdb9a69368c7083>8.70 - Kubernetes API</h1>
<p>Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。</p>
<p>Kubernetes 资源和"意向记录"都是作为 API 对象储存的，并可以通过调用 RESTful 风格的 API 进行修改。
API 允许以声明方式管理配置。
用户可以直接和 Kubernetes API 交互，也可以通过 <code>kubectl</code> 这样的工具进行交互。
核心的 Kubernetes API 是很灵活的，可以扩展以支持定制资源。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0fa467227ecce48e3e883303bd2b4005>8.71 - Minikube</h1>
<p>Minikube 是用来在本地运行 Kubernetes 的一种工具。</p>
<p>Minikube 在用户计算机上的一个虚拟机内运行单节点 Kubernetes 集群。
你可以使用 Minikube
<a href=https://kubernetes.io/zh/docs/setup/learning-environment/>在学习环境中尝试 Kubernetes</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-80b9cbe70574069fc9d473270758937d>8.72 - Pod</h1>
<p>Pod 是 Kubernetes 的原子对象。Pod 表示您的集群上一组正在运行的<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>。</p>
<p>通常创建 Pod 是为了运行单个主容器。Pod 还可以运行可选的边车（sidecar）容器，以添加诸如日志记录之类的补充特性。通常用 <a href=/zh/docs/glossary/deployment title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top target>Deployment</a> 来管理 Pod。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c10a0e9fe6b2de73d4a15c380271f772>8.73 - Pod 安全策略</h1>
<p>为 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 的创建和更新操作启用细粒度的授权。</p>
<p>Pod 安全策略是集群级别的资源，它控制着 Pod 规约中的安全性敏感的内容。
<code>PodSecurityPolicy</code>对象定义了一组条件以及相关字段的默认值，Pod 运行时必须满足这些条件。Pod 安全策略控制实现上体现为一个可选的准入控制器。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4a4f0f9e529711cbdb049801f494c748>8.74 - Pod 水平自动扩缩器（Horizontal Pod Autoscaler）</h1>
<p>Horizontal Pod Autoscaler（Pod 水平自动扩缩器）是一种 API 资源，它根据目标 CPU 利用率或自定义度量目标扩缩 Pod 副本的数量。</p>
<p>HPA 通常用于 <a href=/zh/docs/glossary/replication-controller title="一种管理多副本应用的（已启用）的 API 对象。" data-toggle=tooltip data-placement=top target>副本控制器（Replication Controller）</a>
、<a href=/zh/docs/glossary/deployment title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top target>Deployment</a>
或者 <a href=/zh/docs/glossary/replica-set title="ReplicaSet 是下一代副本控制器。" data-toggle=tooltip data-placement=top target>ReplicaSet</a> 上。
HPA 不能用于不支持扩缩的对象，例如 <a href=/zh/docs/glossary/daemonset title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top target>DaemonSet</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a9824dad7ad96757a3c71cfb00833d0>8.75 - ReplicaSet</h1>
<p>ReplicaSet 是下一代副本控制器。</p>
<p>ReplicaSet 就像 ReplicationController 那样，确保一次运行指定数量的 Pod 副本。ReplicaSet 支持新的基于集合的选择器需求（在标签的用户指南中有相关描述），而副本控制器只支持基于等值的选择器需求。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-021c1f4865a3852aa3544b78aec45d31>8.76 - Secret</h1>
<p>Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。</p>
<p>Secret 允许用户对如何使用敏感信息进行更多的控制，并减少信息意外暴露的风险，包括静态<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/encrypt-data/#ensure-all-secrets-are-encrypted>encryption（加密）</a>。
<a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 通过挂载卷中的文件的方式引用 Secret，或者通过 kubelet 为 pod 拉取镜像时引用。
Secret 非常适合机密数据使用，而 <a href=https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMaps</a> 适用于非机密数据。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bb9ede0a335784b94951926f1102b805>8.77 - ServiceAccount</h1>
<p>为在 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中运行的进程提供标识。</p>
<p>当 Pod 中的进程访问集群时，API 服务器将它们作为特定的服务帐户进行身份验证，
例如 <code>default</code> ，创建 Pod 时，如果你没有指定服务帐户，它将自动被赋予同一个
<a href=/zh/docs/glossary/namespace title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top target>名字空间（Namespace）</a>中的 default 服务账户。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e741e799da64cc349e110ec1db42573d>8.78 - StatefulSet</h1>
<p>StatefulSet 用来管理某 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 集合的部署和扩缩，
并为这些 Pod 提供持久存储和持久标识符。</p>
<p>和 <a href=/zh/docs/glossary/deployment title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top target>Deployment</a> 类似，
StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是，
StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的，
但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p>
<p>如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。
尽管 StatefulSet 中的单个 Pod 仍可能出现故障，
但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b1937d67fd85a24f8674799b2a1dc9fb>8.79 - StorageClass</h1>
<p>StorageClass 是管理员用来描述不同的可用存储类型的一种方法。</p>
<p>StorageClass 可以映射到服务质量等级（QoS）、备份策略、或者管理员任意定义的策略。
每个 StorageClass 对象包含的字段有 <code>provisioner</code>、<code>parameters</code> 和 <code>reclaimPolicy</code>。
动态制备该存储类别的<a href=/zh/docs/glossary/persistent-volume title="持久卷是代表集群中一块存储空间的 API 对象。 它是通用的、可插拔的、并且不受单个 Pod 生命周期约束的持久化资源。" data-toggle=tooltip data-placement=top target>持久卷（Persistent Volume）</a>时需要用到这些字段值。
通过设置 StorageClass 对象的名称，用户可以请求特定存储类别。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fe62cb4c48d83dcbf90bcacf80117421>8.80 - UID</h1>
<p>Kubernetes 系统生成的字符串，唯一标识对象。</p>
<p>在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 uid，它旨在区分类似实体的历史事件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-74e212a8b337e50e8de05ba51f71e504>8.81 - 上游（Uptream）</h1>
<p>可能指的是：核心 Kubernetes 仓库或作为当前仓库派生来源的仓库。</p>
<ul>
<li>在 <strong>Kubernetes社区</strong>：对话中通常使用 <em>upstream</em> 来表示核心 Kubernetes 代码库，也就是更广泛的 kubernetes 生态系统、其他代码或第三方工具所依赖的仓库。 例如，<a href=#term-member>社区成员</a>可能会建议将某个功能特性贡献到 upstream，使其位于核心代码库中，而不是维护于插件或第三方工具中。</li>
<li>在 <strong>GitHub</strong> 或 <strong>git</strong> 中：约定是将源仓库称为 <em>upstream</em>，而派生的仓库则被视为 <em>downstream</em>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f41885f16367636b904b2b0927921c1f>8.82 - 下游（Downstream）</h1>
<p>可以指：Kubernetes 生态系统中依赖于核心 Kubernetes 代码库或分支代码库的代码。</p>
<ul>
<li>在 <strong>Kubernetes 社区</strong>中：<em>下游(downstream)</em> 在人们交流中常用来表示那些依赖核心 Kubernetes 代码库的生态系统、代码或者第三方工具。例如，Kubernete 的一个新特性可以被<em>下游(downstream)</em> 应用采用，以提升它们的功能性。</li>
<li>在 <strong>GitHub</strong> 或 <strong>git</strong> 中：约定用<em>下游(downstream)</em> 表示分支代码库，源代码库被认为是<em>上游(upstream)</em>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cda915385837093852ddd2c06e148a24>8.83 - 云供应商（Cloud Provider）</h1>
<p>一个提供云计算平台的商业机构或其他组织。</p>
<p>云供应商，有时也称作云服务供应商（CSPs）提供云计算平台或服务。</p>
<p>很多云供应商提供托管的基础设施（也称作基础设施即服务或 IaaS）。
针对托管的基础设施，云供应商负责服务器、存储和网络，而用户（你）
负责管理其上运行的各层软件，例如运行一个 Kubernetes 集群。</p>
<p>你也会看到 Kubernetes 被作为托管服务提供；有时也称作平台即服务或 PaaS。
针对托管的 Kubernetes，你的云供应商负责 Kubernetes 的控制面以及
<a href=/zh/docs/glossary/node title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top target>节点（Node）</a> 及他们所依赖的基础设施：
网络、存储以及其他一些诸如负载均衡器之类的元素。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66c12ebc789eac3487b595c037607155>8.84 - 云控制器管理器（Cloud Controller Manager）</h1>
<p>云控制器管理器是指嵌入特定云的控制逻辑的
<a href=/zh/docs/glossary/control-plane title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top target>控制平面（Control Plane）</a>组件。
云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上，
并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p>通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑，
云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的
步调发布新特征。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-30381eda196d48d1e5a45b654c75293d>8.85 - 代码贡献者（Code Contributor）</h1>
<p>为 Kubernetes 开源代码库开发并贡献代码的人。</p>
<p>代码贡献者也是加入一个或多个 <a href=/zh/docs/glossary/sig title="共同管理大范畴 Kubernetes 开源项目中某组件或方面的一组社区成员。" data-toggle=tooltip data-placement=top target>特别兴趣小组（SIG）</a> 的活跃的 <a href=/zh/docs/glossary/member title="K8s 社区中持续活跃的贡献者。" data-toggle=tooltip data-placement=top target>成员（Member）</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ebb1e8c2889455c952d370cac3cd0a27>8.86 - 初始化容器（Init Container）</h1>
<p>应用<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>运行前必须先运行完成的一个或多个初始化容器。</p>
<p>初始化（init）容器像常规应用容器一样，只有一点不同：初始化（init）容器必须在应用容器启动前运行完成。
Init 容器的运行顺序：一个初始化（init）容器必须在下一个初始化（init）容器开始前运行完成。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-04e79c3afe3f30f5d8fe0b28308fb1ee>8.87 - 副本控制器（Replication Controller）</h1>
<p>一种工作管理多副本应用的负载资源，能够确保特定个数的
<a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>
实例处于运行状态。</p>
<p>控制面确保所指定的个数的 Pods 处于运行状态，即使某些 Pod 会失效，
比如被你手动删除或者因为其他错误启动过多 Pod 时。</p>
<blockquote class="note callout">
<div><strong>[i18n] note</strong>
<p>ReplicationController 已被启用。请参见 Deployment 执行类似功能。</div>
</blockquote>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0c8032e77dd004415eb1a1e325441378>8.88 - 动态卷供应（Dynamic Volume Provisioning）</h1>
<p>允许用户请求自动创建存储 <a href=/zh/docs/glossary/volume title="包含可被 Pod 中容器访问的数据的目录。" data-toggle=tooltip data-placement=top target>卷（Volume）</a>。</p>
<p>动态供应让集群管理员无需再预先供应存储。相反，它通过用户请求自动地供应存储。
动态卷供应是基于 API 对象 <a href=/zh/docs/glossary/storage-class title="StorageClass 是管理员用来描述可用的不同存储类型的一种方法。" data-toggle=tooltip data-placement=top target>StorageClass</a> 的，
StorageClass 可以引用 <a href=/zh/docs/glossary/volume-plugin title="卷插件可以让 Pod 集成存储。" data-toggle=tooltip data-placement=top target>卷插件（Volume Plugin）</a> 提供的
<a href=/zh/docs/glossary/volume title="包含可被 Pod 中容器访问的数据的目录。" data-toggle=tooltip data-placement=top target>卷（Volume）</a>，也可以引用传递给卷插件（Volume Plugin）的参数集。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2f808ec7c92adb4e59947569223aa522>8.89 - 卷插件（Volume Plugin）</h1>
<p>卷插件可以让 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 集成存储。</p>
<p>卷插件让您能给 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 附加和挂载存储卷。
卷插件既可以是 <em>in tree</em> 也可以是 <em>out of tree</em> 。<em>in tree</em> 插件是 Kubernetes 代码库的一部分，
并遵循其发布周期。而 <em>Out of tree</em> 插件则是独立开发的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-15ca85091fc8c2d69131be0f17e74019>8.90 - 卷（Volume）</h1>
<p>包含可被 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>访问的数据的目录。</p>
<p>每个 Kubernetes 卷在所处的 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 存在期间保持存在状态。
因此，卷的生命期会超出 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中运行的<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>，
并且保证<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>重启之后仍保留数据。</p>
<p>更多信息可参考<a href=https://kubernetes.io/zh/docs/concepts/storage/>storage</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca9e31c41b1c901c2778067b5ceab269>8.91 - 名字空间（Namespace）</h1>
<p>名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。</p>
<p>名字空间用来组织集群中对象，并为集群资源划分提供了一种方法。同一名字空间内的资源名称必须唯一，但跨名字空间时不作要求。
在一些文档里名字空间也称为命名空间。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8a24389d4844af7a5756df688cb928c0>8.92 - 名称（Name）</h1>
<p>客户端提供的字符串，引用资源 url 中的对象，如<code>/api/v1/pods/some name</code>。</p>
<p>某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fc098dfd608da29022cd66a83a2cef1f>8.93 - 周期调度任务（CronJob）</h1>
<p>管理定期运行的 <a href=https://kubernetes.io/zh/docs/concepts/workloads/controllers/job/>任务</a>。</p>
<p>Cronjob 对象类似 <em>crontab</em> 文件中的一行命令，它声明了一个遵循 <a href=https://en.wikipedia.org/wiki/Cron>Cron</a> 格式的调度任务。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-722af529138120fa4a972487c534417e>8.94 - 基于角色的访问控制（RBAC）</h1>
<p>管理授权决策，允许管理员通过 <a href=/zh/docs/glossary/kubernetes-api title="Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。" data-toggle=tooltip data-placement=top target>Kubernetes API</a> 动态配置访问策略。</p>
<p>RBAC 使用 <em>角色</em> (包含权限规则)和 <em>角色绑定</em> (将角色中定义的权限授予一组用户)。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fa8762f5ea277f2db3d11f9c814d3449>8.95 - 安全上下文（Security Context）</h1>
<p>securityContext 字段定义 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 或
<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>的特权和访问控制设置。</p>
<p>在一个 <code>securityContext</code> 字段中，你可以设置进程所属用户和用户组、权限相关设置。你也可以设置安全策略（例如：SELinux、AppArmor、seccomp）。</p>
<p><code>PodSpec.securityContext</code> 字段配置会应用到一个 Pod 中的所有的 container 。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6e01ab45bd20c0c9fb89a30734f1dd81>8.96 - 容器环境变量（Container Environment Variables）</h1>
<p>容器环境变量提供了 name=value 形式的、在 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 中运行的容器所必须的一些重要信息。</p>
<p>容器环境变量为运行中的容器化应用提供必要的信息，同时还提供与 <a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a> 重要资源相关的其他信息，例如：文件系统信息、容器自身的信息以及其他像服务端点（Service endpoints）这样的集群资源信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-469e9bf3a6e2144d4d785d7e372180f7>8.97 - 容器（Container）</h1>
<p>容器是可移植、可执行的轻量级的镜像，包含其中的软件及其相关依赖。</p>
<p>容器使应用和底层的主机基础设施解耦，降低了应用在不同云环境或者操作系统上的部署难度，便于应用扩展。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-84e954e0f04e64ed39ee82a1cb081e6f>8.98 - 工作组（Working Group，WG）</h1>
<p>工作组是为了方便讨论和（或）推进执行一些短周期、窄范围、或者从委员会和 SIG 分离出来的项目、以及跨 SIG 的活动。</p>
<p>工作组可以将人们组织起来，一起完成一项分散的任务。</p>
<p>更多信息请参考 <a href=https://github.com/kubernetes/community>kubernetes/community</a> 代码库和当前的 <a href=https://github.com/kubernetes/community/blob/master/sig-list.md>SIGs 和工作组</a> 列表。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7d314c50ed2a11d1ec451dd074a7c9d2>8.99 - 平台开发人员（Platform Developer）</h1>
<p>定制 Kubernetes 平台以满足自己的项目需求的人。</p>
<p>平台开发人员可以使用<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>
或<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>使用汇聚层扩展 Kubernetes API</a>
来为其 Kubernetes 实例增加功能，特别是为其应用程序添加功能。
一些平台开发人员也是 kubernetes <a href=/zh/docs/glossary/contributor title="通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。" data-toggle=tooltip data-placement=top target>贡献者（Contributor）</a>，
他们会开发贡献给 Kubernetes 社区的扩展。
另一些平台开发人员则开发封闭源代码的商业扩展或用于特定网站的扩展。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6f86f5c1145b928427953057f06efe7e>8.100 - 应用开发者（Application Developer）</h1>
<p>编写可以在 Kubernetes 集群上运行的应用的人。</p>
<p>应用开发者专注于应用的某一部分。他们工作范围的大小有明显的差异。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-910283b40d8346d8f9742728a6cf64b5>8.101 - 应用架构师（Application Architect）</h1>
<p>应用架构师是负责应用高级设计的人。</p>
<p>应用架构师确保应用的实现允许它和周边组件进行可扩展的、可持续的交互。
周边组件包括数据库、日志基础设施和其他微服务。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-51228bcff4c2e9508f49024e7399c5ef>8.102 - 开发者（Developer）</h1>
<p>指的是：<a href=/zh/docs/glossary/application-developer title="编写可以在 Kubernetes 集群上运行的应用的人。" data-toggle=tooltip data-placement=top target>应用开发者（Application Developer）</a>、
<a href=/zh/docs/glossary/code-contributor title="为 Kubernetes 开源代码库开发并贡献代码的人。" data-toggle=tooltip data-placement=top target>代码贡献者（Code Contributor）</a>、
或<a href=/zh/docs/glossary/platform-developer title="定制 Kubernetes 平台以满足自己的项目需求的人。" data-toggle=tooltip data-placement=top target>平台开发人员（Platform Developer）</a>。</p>
<p>根据上下文的不同，“开发者”这个被多处使用的词条会有不同的含义。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b4e55b971b739aefdf0f3398cf4cbd05>8.103 - 成员（Member）</h1>
<p>K8s 社区中持续活跃的<a href=/zh/docs/glossary/contributor title="通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。" data-toggle=tooltip data-placement=top target>贡献者（Contributor）</a>。</p>
<p>可以将问题单（issue）和 PR 指派给成员（Member），成员（Member）也可以通过 GitHub 小组加入 <a href=/zh/docs/glossary/sig title="共同管理大范畴 Kubernetes 开源项目中某组件或方面的一组社区成员。" data-toggle=tooltip data-placement=top target>特别兴趣小组（SIG）</a>。针对成员（Member）所提交的 PR，系统自动运行提交前测试。成员（Member）应该是持续活跃的社区贡献者。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d7206a4063f74f85bff402fb2905e66d>8.104 - 托管服务</h1>
<p>由第三方供应商负责维护的一种软件产品。</p>
<p>托管服务的一些例子有 AWS EC2、Azure SQL 数据库和 GCP Pub/Sub 等，
不过它们也可以是可以被某应用使用的任何软件交付件。
<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/service-catalog/>服务目录</a>
提供了一种方法用来列举、制备和绑定到
<a href=/zh/docs/glossary/service-broker title=由第三方提供并维护的一组托管服务的访问端点。 data-toggle=tooltip data-placement=top target>服务代理（Service Broker）</a>
所提供的托管服务。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a7518a3ffe530f1bb40490e1869bab74>8.105 - 批准者（Approver）</h1>
<p>可以审核并批准 Kubernetes 代码贡献的人。</p>
<p>代码审核的重点是代码质量和正确性，而批准的重点是对贡献的整体接受。
整体接受包括向后/向前兼容性、遵守 API 和参数约定、细微的性能和正确性问题、与系统其他部分的交互等。
批准者状态的作用域是代码库的一部分。审批者以前被称为维护者。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e49264feb3ad250f4280b7ac3c78c8ef>8.106 - 持久卷申领（Persistent Volume Claim）</h1>
<p>申领<a href=/zh/docs/glossary/persistent-volume title="持久卷是代表集群中一块存储空间的 API 对象。 它是通用的、可插拔的、并且不受单个 Pod 生命周期约束的持久化资源。" data-toggle=tooltip data-placement=top target>持久卷（Persistent Volume）</a>中定义的存储资源，以便可以将其挂载为<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>中的卷。</p>
<p>指定存储的数量，如何访问存储（只读、读写或独占）以及如何回收存储（保留、回收或删除）。存储本身的详细信息在 PersistentVolume 对象中。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7b33702ae376d8e7de5839456f8f3575>8.107 - 持久卷（Persistent Volume）</h1>
<p>持久卷是代表集群中一块存储空间的 API 对象。 它是通用的、可插拔的、并且不受单个 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 生命周期约束的持久化资源。</p>
<p>持久卷（PersistentVolumes，PV）提供了一个 API，该 API 对存储的供应方式细节进行抽象，令其与使用方式相分离。
在提前创建存储（静态供应）的场景中，PV 可以直接使用。
在按需提供存储（动态供应）的场景中，需要使用 PersistentVolumeClaims (PVCs)。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-029c2d22105ac3f6911d74fc7d5b538b>8.108 - 控制器（Controller）</h1>
<p>在 Kubernetes 中，控制器通过监控<a href=/zh/docs/glossary/cluster title="集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。" data-toggle=tooltip data-placement=top target>集群（Cluster）</a>
的公共状态，并致力于将当前状态转变为期望的状态。</p>
<p>控制器（<a href=/zh/docs/glossary/control-plane title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top target>控制平面（Control Plane）</a>的一部分）
通过 <a href=/zh/docs/glossary/kube-apiserver title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top target>kube-apiserver</a> 监控你的集群中的公共状态。</p>
<p>其中一些控制器是运行在控制平面内部的，对 Kubernetes 来说，他们提供核心控制操作。
比如：部署控制器（deployment controller）、守护控制器（daemonset controller）、
命名空间控制器（namespace controller）、持久化数据卷控制器（persistent volume
controller）（等）都是运行在 <a href=/zh/docs/glossary/kube-controller-manager title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top target>kube-controller-manager</a> 中的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-125cc2f883615d755ddda13bdbe1fdac>8.109 - 服务代理（Service Broker）</h1>
<p>由第三方提供并维护的一组<a href=/zh/docs/glossary/managed-service title=由第三方供应商负责维护的一种软件产品。 data-toggle=tooltip data-placement=top target>托管服务</a>的访问端点。</p>
<p><a href=/zh/docs/glossary/service-broker title=由第三方提供并维护的一组托管服务的访问端点。 data-toggle=tooltip data-placement=top target>服务代理（Service Broker）</a>会实现
<a href=https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md>开放服务代理 API 规范</a>
并为应用提供使用其托管服务的标准接口。
<a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/service-catalog/>服务目录（Service Catalog）</a>则提供一种方法，用来列举、供应和绑定服务代理商所提供的托管服务。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-702df2603337611e5fd35b37bca45e10>8.110 - 服务目录（Service Catalog）</h1>
<p>服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。</p>
<p>服务目录可以检索、供应、和绑定由 <a href=/zh/docs/glossary/service-broker title=由第三方提供并维护的一组托管服务的访问端点。 data-toggle=tooltip data-placement=top target>服务代理（Service Broker）</a>
提供的外部<a href=/zh/docs/glossary/managed-service title=由第三方供应商负责维护的一种软件产品。 data-toggle=tooltip data-placement=top target>托管服务</a>，
而无需知道那些服务具体是怎样创建和托管的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-76a15461212f4c6a93025e68202b15fd>8.111 - 服务（Service）</h1>
<p>将运行在一组 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 上的应用程序公开为网络服务的抽象方法。</p>
<p>服务所针对的 Pod 集（通常）由<a href=/zh/docs/glossary/selector title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top target>选择算符（Selector）</a>确定。
如果有 Pod 被添加或被删除，则与选择算符匹配的 Pod 集合将发生变化。
服务确保可以将网络流量定向到该工作负载的当前 Pod 集合。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-901e4c5de2ba8dfaf9632f200c599537>8.112 - 标签（Label）</h1>
<p>用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。</p>
<p>标签是一些关联到 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a> 这类对象上的键值对。
它们通常用来组织和选择对象子集。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c0942b17e9469578411bbc091a0c8125>8.113 - 注解（Annotation）</h1>
<p>注解是以键值对的形式给资源对象附加随机的无法标识的元数据。</p>
<p>注解中的元数据可大可小，可以是结构化的也可以是非结构化的，
并且能包含<a href=/zh/docs/glossary/label title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top target>标签（Label）</a>不允许使用的字符。
像工具和软件库这样的客户端可以检索这些元数据。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-04b892fa7f5902cbd3afa5da2a3b81e6>8.114 - 特别兴趣小组（SIG）</h1>
<p>共同管理大范畴 Kubernetes 开源项目中某组件或方面的一组<a href=/zh/docs/glossary/member title="K8s 社区中持续活跃的贡献者。" data-toggle=tooltip data-placement=top target>成员（Member）</a>。</p>
<p>SIG 中的成员对推进某个领域（如体系结构、API 机制构件或者文档）具有相同的兴趣。
SIGs 必须遵从 <a href=https://github.com/kubernetes/community/blob/master/committee-steering/governance/sig-governance.md>governance guidelines</a> 的规定，
不过可以有自己的贡献策略以及通信渠道（方式）。</p>
<p>更多的详细信息可参阅 <a href=https://github.com/kubernetes/community>kubernetes/community</a> 仓库以及
<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>SIGs 和工作组（Working Groups）</a>的最新列表。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efa6404aa61ca93003cb14e37eef16f6>8.115 - 网络策略</h1>
<p>网络策略是一种规范，规定了允许 Pod 组之间、Pod 与其他网络端点之间以怎样的方式进行通信。</p>
<p>网络策略帮助您声明式地配置允许哪些 Pod 之间接、哪些命名空间之间允许进行通信，并具体配置了哪些端口号来执行各个策略。<code>NetworkPolicy</code> 资源使用标签来选择 Pod，并定义了所选 Pod 可以接受什么样的流量。网络策略由网络提供商提供的并被 Kubernetes 支持的网络插件实现。请注意，当没有控制器实现网络资源时，创建网络资源将不会生效。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8e6bdba5cb373983f4072e87b9e6daad>8.116 - 节点（Node）</h1>
<p>Kubernetes 中的工作机器称作节点。</p>
<p>工作机器可以是虚拟机也可以是物理机，取决于集群的配置。
其上部署了运行 <a href=/zh/docs/glossary/pod title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top target>Pod</a>
所必需的本地守护进程或服务，
并由主控组件来管理。
节点上的的守护进程包括 <a href=/zh/docs/glossary/kubelet title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top target>Kubelet</a>、
<a href=/zh/docs/glossary/kube-proxy title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top target>kube-proxy</a>
以及一个 <a href=/zh/docs/glossary/docker title="Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。" data-toggle=tooltip data-placement=top target>Docker</a> 这种
实现了 <a href=/zh/docs/glossary/cri title="一组与 kubelet 集成的容器运行时 API" data-toggle=tooltip data-placement=top target>容器运行时接口（CRI）</a>
的容器运行时。</p>
<p>在早期的 Kubernetes 版本中，节点也称作 &ldquo;Minions&rdquo;。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-405b9576a57a9cc2f9c4d3a0d0f38c91>8.117 - 证书（Certificate）</h1>
<p>证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。</p>
<p>证书可以让 Kubernetes 集群中运行的应用程序安全的访问 Kubernetes API。证书可以确认客户端是否被允许访问 API。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-560a73dd2bb9cec8bbd1da18399af319>8.118 - 评审者（Reviewer）</h1>
<p>评审者是负责评审项目的某部分代码以便提高代码质量和正确性的人。</p>
<p>评审者既要了解代码库又要了解软件工程规范。评审者状态是基于代码库的组成部分来设定的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4e8d4277f3d1f9b8b1f739d5d3788758>8.119 - 贡献者许可协议（CLA）</h1>
<p><a href=/zh/docs/glossary/contributor title="通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。" data-toggle=tooltip data-placement=top target>贡献者（Contributor）</a>对他们在开源项目中所贡献的代码的授权许可条款。</p>
<p>CLA 对解决贡献者在开源社区所贡献的资料和智力资产（IP）导致的法律纠纷很有帮助。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7994a3fa8dacca85f27af907c6a8a8b4>8.120 - 贡献者（Contributor）</h1>
<p>通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。</p>
<p>贡献形式包括提交拉取请求（PRs）、问题报告（Issues）、反馈、参与<a href=/zh/docs/glossary/sig title="共同管理大范畴 Kubernetes 开源项目中某组件或方面的一组社区成员。" data-toggle=tooltip data-placement=top target>特别兴趣小组（SIG）</a>或者组织社区活动等等。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5fe3da5ce19c797ae34184b232e0f489>8.121 - 资源配额（Resource Quotas）</h1>
<p>资源配额提供了限制每个 <a href=/zh/docs/glossary/namespace title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top target>名字空间（Namespace）</a> 的资源消耗总和的约束。</p>
<p>限制了命名空间中每种对象可以创建的数量，也限制了项目中可被资源对象利用的计算资源总数。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2455ffd7c42eab100b5ee18f8dfc45f2>8.122 - 选择算符（Selector）</h1>
<p>选择算符允许用户通过<a href=/zh/docs/glossary/label title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top target>标签（Label）</a>对一组资源对象进行筛选过滤。</p>
<p>在查询资源列表时，选择算符可以通过标签对资源进行过滤筛选。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fc02e65a1d95fac4d4bab5d69409a40a>8.123 - 镜像（Image）</h1>
<p>镜像是保存的<a href=/zh/docs/glossary/container title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top target>容器（Container）</a>实例，它打包了应用运行所需的一组软件。</p>
<p>镜像是软件打包的一种方式，可以将镜像存储在容器镜像仓库、拉取到本地系统并作为应用来运行。
镜像中包含的元数据指明了运行什么可执行程序、是由谁构建的以及其他信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aab941ab9aac7f6e34392580f667d906>8.124 - 集群操作者（Cluster Operator）</h1>
<p>配置、控制、监控集群的人。</p>
<p>他们的主要责任是保持集群正常运行，可能需要进行周期性的维护和升级活动。<br></p>
<p><strong>注意：</strong> 集群操作者不同于<a href=https://www.openshift.com/learn/topics/operators>操作者模式（Operator Pattern）</a>，操作者模式是用来扩展 Kubernetes API 的。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e637e8ec6c787aae6de7eaa601478b7b>8.125 - 集群架构师（Cluster Architect）</h1>
<p>集群架构师负责设计集群的基础设施，可能包含一个或多个 Kubernetes 集群。</p>
<p>集群架构师要具备分布式系统的最佳实践经验，例如：高可用性和安全性。</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank rel=noopener href=https://example.org/mail aria-label="User mailing list">
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank rel=noopener href=https://example.org/twitter aria-label=Twitter>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank rel=noopener href=https://example.org/stack aria-label="Stack Overflow">
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel=noopener href=https://github.com/klts-io/website aria-label=GitHub>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank rel=noopener href=https://example.org/slack aria-label=Slack>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list">
<a class=text-white target=_blank rel=noopener href=https://example.org/mail aria-label="Developer mailing list">
<i class="fa fa-envelope"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2021 The KLTS.io Authors 版权所有</small>
<p class=mt-2><a href=/zh/about/>关于 KLTS</a></p>
</div>
</div>
</div>
</footer>
</div>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script>
<script src=/js/main.min.3b172c13b62c2bea8b1c9d2599cddc8cf89718a92d792c680871c81ba43d8c85.js integrity="sha256-OxcsE7YsK+qLHJ0lmc3cjPiXGKkteSxoCHHIG6Q9jIU=" crossorigin=anonymous></script>
</body>
</html>